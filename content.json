{"meta":{"title":"未来的小幸运 || 致正在努力的我们--------逸如风","subtitle":"未来的小幸运 || 致正在努力的我们--------逸如风","description":"吴晓文的个人博客","author":"逸如风","url":"http://sivan0222.cn"},"pages":[{"title":"archives","date":"2017-04-08T02:08:34.000Z","updated":"2017-04-09T01:01:24.273Z","comments":true,"path":"archives/index.html","permalink":"http://sivan0222.cn/archives/index.html","excerpt":"","text":""},{"title":"About","date":"2017-03-20T02:08:41.000Z","updated":"2017-11-10T02:00:56.726Z","comments":true,"path":"about/index.html","permalink":"http://sivan0222.cn/about/index.html","excerpt":"","text":"英文名：SiVan中文名：逸如风邮箱：yirufeng@foxmail.com 瞎折腾，经常乱搞，目前J2EE，热爱前沿技术，热爱开源，经常跟随大牛脚步！ 大学在读，来自山西朔州怀仁 涉略广泛，爱好军事和政治，高三仍沉迷军事不能自拔 爱好音乐，喜欢激情歌曲和情歌 爱好电影（除了日本动漫） 华为控和苹果控 博客经历经历2016.09-2016.11wordpress受到上海的Hacker攻击，数据没有及时备份，第一个博客挂掉 2016.11-2017.01Hexo使用了所谓的静态页面，并将代码托管到GitHub2017.01-nowHexo中间主题更换n次，都是乱折腾2017.03-nowHexo主题进行优化，界面变得更加美观"},{"title":"open-source","date":"2017-12-10T09:24:23.000Z","updated":"2017-12-10T09:24:23.729Z","comments":true,"path":"open-source/index.html","permalink":"http://sivan0222.cn/open-source/index.html","excerpt":"","text":""},{"title":"reading","date":"2017-05-01T08:03:10.000Z","updated":"2017-05-01T08:24:58.626Z","comments":true,"path":"reading/index.html","permalink":"http://sivan0222.cn/reading/index.html","excerpt":"","text":""},{"title":"Wiki","date":"2017-04-08T02:08:21.000Z","updated":"2017-12-11T09:30:02.744Z","comments":true,"path":"wiki/index.html","permalink":"http://sivan0222.cn/wiki/index.html","excerpt":"","text":"问题：为什么按下了和松开键盘上的某些键位仍然没有调用对应的KeyPressed以及KeyReleased方法 因为每当你点击文本域的时候，你的输入法会自动从英文模式变成中文，而中文输入任何字符，被识别的几率很小，因此我们需要切换下输入法。或者直接点击文本域之前，关掉中文输入法，只用英文输入法。 replace 与replaceAll的区别 replace参数第一个是字符，而replaceAll第一个是正则表达式，而’.’号在正则表达式中作为通配符，指所有的！ replace(char oldChar, char newChar) 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 而生成的。 String replace(CharSequence target, CharSequence replacement) 使用指定的字面值替换序列替换此字符串匹配字面值目标序列的每个子字符串。 String replaceAll(String regex, String replacement) 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的每个子字符串。 String replaceFirst(String regex, String replacement) 使用给定的 replacement 字符串替换此字符串匹配给定的正则表达式的第一个子字符串。 1234String s = \"www.baidu.com\";System.out.println(s.replace(\".\", \"\"));System.out.println(s.replaceAll(\"\\\\.\", \"\")); //这里这个点号作为正则表达式的通配符使用博客。 关于正则表达式：移步"}],"posts":[{"title":"流程执行与输入","slug":"流程执行与输入","date":"2017-12-08T05:47:22.000Z","updated":"2017-12-08T07:08:29.886Z","comments":true,"path":"2017/12/08/流程执行与输入/","link":"","permalink":"http://sivan0222.cn/2017/12/08/流程执行与输入/","excerpt":"前言：由于博主最近开始研究机器学习，第一个首要任务便是学习Python的基本语法，因为很多机器学习库都是基于Python的，这里记录了自己的首个Python学习日志，供自己和初学者学习！ 声明：由于博主自己使用的是Python3之后的，所以代码都是基于Python3的 一个简单的入门程序记得自己之前在看别人写好的简历上发现了一句牛逼的话语：精通各种语言的HelloWorld编程。。。。。这里也是以一个Python中的Hello World程序来介绍 hello.py代码如下：123#!/usr/bin/env python-*-coding:utf-8-*-print(\"Hello World!\"); 首先，第3行代码用来打印”Hello World”，第2行代码指定解释器我们使用UTF-8编码，第1行代码是当我们希望在Linux下面希望像shell脚本一样执行Python脚本(如下)，此时我们就需要指定Python的解释器： ./hello.py Python中的注释在我们学习了一个入门程序之后，我们最迫切的便是每个编程语言的注释，尤其是对于我们自己不太理解的地方，我们往往会在代码附近通过注释做上笔记 表示单行注释，Python会把Python后面的内容全部注释 ‘’’ 或 “”” ，三个单引号或者三个双引号，用来表示多行注释，当然这里也可以是单行注释（当我们’’’的开始和结束都写在一行的时候） 示例：1234567# 这里是单行注释'''这里表示多行注释这里表示多行注释这里表示多行注释''''''这里也可以表示单行注释''' 三个单引号或者三个双引号的额外用处：例子1：12345678910111213name = input(\"请输入姓名：\");age = int(input(\"请输入年龄：\")); job = input(\"请输入工作：\");salary = input(\"请输入薪水：\");output = '''-----------info of %s-----Name: %sAge: %d Job: %sSalary: %s'''print(output % (name, name, age, job, salary));","text":"前言：由于博主最近开始研究机器学习，第一个首要任务便是学习Python的基本语法，因为很多机器学习库都是基于Python的，这里记录了自己的首个Python学习日志，供自己和初学者学习！ 声明：由于博主自己使用的是Python3之后的，所以代码都是基于Python3的 一个简单的入门程序记得自己之前在看别人写好的简历上发现了一句牛逼的话语：精通各种语言的HelloWorld编程。。。。。这里也是以一个Python中的Hello World程序来介绍 hello.py代码如下：123#!/usr/bin/env python-*-coding:utf-8-*-print(\"Hello World!\"); 首先，第3行代码用来打印”Hello World”，第2行代码指定解释器我们使用UTF-8编码，第1行代码是当我们希望在Linux下面希望像shell脚本一样执行Python脚本(如下)，此时我们就需要指定Python的解释器： ./hello.py Python中的注释在我们学习了一个入门程序之后，我们最迫切的便是每个编程语言的注释，尤其是对于我们自己不太理解的地方，我们往往会在代码附近通过注释做上笔记 表示单行注释，Python会把Python后面的内容全部注释 ‘’’ 或 “”” ，三个单引号或者三个双引号，用来表示多行注释，当然这里也可以是单行注释（当我们’’’的开始和结束都写在一行的时候） 示例：1234567# 这里是单行注释'''这里表示多行注释这里表示多行注释这里表示多行注释''''''这里也可以表示单行注释''' 三个单引号或者三个双引号的额外用处：例子1：12345678910111213name = input(\"请输入姓名：\");age = int(input(\"请输入年龄：\")); job = input(\"请输入工作：\");salary = input(\"请输入薪水：\");output = '''-----------info of %s-----Name: %sAge: %d Job: %sSalary: %s'''print(output % (name, name, age, job, salary)); 例子2：12345678910111213name = input(\"请输入姓名：\");age = int(input(\"请输入年龄：\")); job = input(\"请输入工作：\");salary = input(\"请输入薪水：\");info2 = '''---------------info of $&#123;_name_&#125; --------------Name: &#123;_name_&#125;Age: &#123;_age_&#125;Job: &#123;_job_&#125;Salary: &#123;_salary_&#125;'''.format(_name_=name,_age_=age,_job_=job,_salary_=salary);print(info2); 例子3：根据顺序12345678910111213name = input(\"请输入姓名：\");age = int(input(\"请输入年龄：\")); job = input(\"请输入工作：\");salary = input(\"请输入薪水：\");info3 = '''---------------info of $&#123;0&#125; --------------Name: &#123;0&#125;Age: &#123;1&#125;Job: &#123;2&#125;Salary: &#123;3&#125;'''.format(name,age,job,salary);print(info3); 例子4：使用拼接12345678910111213name = input(\"请输入姓名：\");age = int(input(\"请输入年龄：\")); job = input(\"请输入工作：\");salary = input(\"请输入薪水：\");info4 = '''---------------info of ''' + name + '''Name：''' + name + '''Age：''' + str(age) + '''Job：''' + job + '''Salary：''' + salary + '''''';print(info4); 注意：对于字符串，官方不建议采用字符串拼接的方式，因为每次字符串拼接都会额外开辟一块内存，对于拼接次数过多，不建议使用！ 接收用户的输入接受用户普通的输入Python可以使用input()函数来接受用户的输入，但是在Python2中还可以使用raw_input()用来获取用户的输入，等同于Python3中的input()，并且input()在python2中将会根据用户的输入自动决定类型，而不像Python3一样接受用户输入之后一定是字符串类型。 代码如下：123456#将用户输入的内容赋值给username,并且username将会是字符串username = input(\"Please input your username：\"); # 如果在Python2中，我们可以使用如下代码，等同于Python3中的input()# username2 = raw_input(\"Please input your username：\"); Python2中的代码如下：123456789101112131415&gt;&gt;&gt; a = raw_input(\"Please input your username:\");Please input your username:aaa&gt;&gt;&gt; a'aaa'&gt;&gt;&gt; a = input();\"dd\"&gt;&gt;&gt; a'dd'&gt;&gt;&gt; print(type(a));&lt;type 'str'&gt;&gt;&gt;&gt; a = input();122&gt;&gt;&gt; print(type(a));&lt;type 'int'&gt;&gt;&gt;&gt; 可以看出，在Python3中，input()将会得到一个字符串，等同于Python2中的raw_input()，但是在Python2中，当我们采用input()函数的时候，如果用户输入了双引号或者单引号，那么将会是一个字符串；如果用户输入的是纯数字，那么将会得到一个整形的数据！ 接收用户的特殊输入（不可见输入） 当我们需要用户输入一些敏感词的时候，我们希望不会以明文的形式显示，而是希望能够以特别的方式进行展示，例如当我们输入密码的时候，并不会将我们输入的密码进行显示！ 1234import getpass;username = input(\"Please input your username：\");password = getpass.getpass(\"Please input your password：\");print(username, password); 需要注意的是：由于Pycharm中不支持这样输入密码，因此我们需要进入该Python文件所在目录，执行Python test.py，当我们输入密码的时候，我们就可以看到效果 Python中的类型转换由于input()在Python3中将会返回一个字符串，所以即使我们输入了纯数字，也会被识别为一个字符串，因此我们需要进行类型转换。 1234567891011num1 = input(\"Please input first number\");print(type(num1)); ## 将字符串转换为一个整形数据num1 = int(num1);print(type(num1));# 将整形数据转换为一个字符串num1 = str(num1);print(type(num1)); 结果如下：1234Please input first number：5&lt;class 'str'&gt;&lt;class 'int'&gt;&lt;class 'str'&gt; if语句最基本的if–else语句当我们只有一个分支的时候我们只需要使用一个分支语句，也就是if-else语句 1234567891011121314username = input(\"请输入用户名：\");password = input(\"请输入密码：\");# password = getpass.getpass(\"请输入密码：\"); #这句话在pycharm中不好使，需要手动进入目录使用命令行执行，所以这里进行了注释print(username, password);# 下面实现一个逻辑判断，判断用户名和密码正确与否_username = \"admin\";_password = \"admin\";if _username == username and _password == password: print(\"Welcome &#123;name&#125; login....\".format(name=username));else: print(\"Invalid username or password\"); 注意：我们在Python中使用if语句，不仅仅需要在if和else后面的语句后面加上1个冒号；更重要的是我们在写if和else的子句的时候，前面需要缩进，这里的缩进也就是我们其他语言里面的括号。 进阶的if-elif-else语句1234567891011121314age_of_oldboy = 56;count = 0;while count &lt; 3: guess_age = int(input(\"guess age:\")); if guess_age == age_of_oldboy: print(\"Congradualtions,you got it\"); break; elif guess_age &gt; age_of_oldboy: print(\"You should think smaller!\"); else: print(\"You should think bigger!\"); count += 1;else: print(\"Sorry,you have tried too many times!\"); while语句Python中的while字句也可以搭配else子句，当while无法进行的时候，将会执行else语句 1234567891011121314age_of_oldboy = 56;count = 0;while count &lt; 3: guess_age = int(input(\"guess age:\")); if guess_age == age_of_oldboy: print(\"Congradualtions,you got it\"); break; elif guess_age &gt; age_of_oldboy: print(\"You should think smaller!\"); else: print(\"You should think bigger!\"); count += 1;else: print(\"Sorry,you have tried too many times!\"); for语句当我们使用Python中的for语句的时候，需要注意range()中可以指定3个参数，第1个参数是开始的数字，第2个参数是结束的数字n(也就是到n-1)，第3个参数是每隔多少次执行一次循环 例1：123456789101112# 将会打印0-9for i in range(10): print(i);# 将会打印22-89for i in range(22,90): print(i);# 只打印偶数,从零开始，每隔2个打印一下for i in range(0,10,2): print(i) 例2：1234567891011121314age_of_oldboy = 56;for i in range(3): guess_age = int(input(\"guess age:\")); if(guess_age == age_of_oldboy): print(\"Congratulations,you have got it...\"); break; elif guess_age &gt; age_of_oldboy: print(\"Please Think Smaller...\"); else: print(\"Please Think Bigger...\");else: print(\"Sorry,You have tried too many times\"); 综合应用：12345678910111213141516age_of_oldboy = 56;count = 0;while count &lt; 3: guess_age = int(input(\"guess age:\")); if guess_age == age_of_oldboy: print(\"Congratulations,you have got it\"); break; elif guess_age &gt; age_of_oldboy: print(\"You should think smaller!\"); else: print(\"You should think bigger!\"); count += 1; if count == 3: cotinue_confirm = input(\"Please confirm if continue:\"); if cotinue_confirm != 'n': count = 0; 总结：这篇文章仅仅是我记录学习的一小步，但是对自己来说却进步了一大步！Python，一定会是我手中的利器！","categories":[{"name":"Python","slug":"Python","permalink":"http://sivan0222.cn/categories/Python/"},{"name":"Basic","slug":"Python/Basic","permalink":"http://sivan0222.cn/categories/Python/Basic/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://sivan0222.cn/tags/Python/"}]},{"title":"创建和配置GitHub的SSH密钥","slug":"Linux下创建GitHub的SSH秘钥并配置","date":"2017-12-01T12:26:12.000Z","updated":"2017-12-03T04:15:39.311Z","comments":true,"path":"2017/12/01/Linux下创建GitHub的SSH秘钥并配置/","link":"","permalink":"http://sivan0222.cn/2017/12/01/Linux下创建GitHub的SSH秘钥并配置/","excerpt":"经常使用GitHub的童鞋一定知道，当我们每次push的时候，都会遇到一个很尴尬的问题，输入用户名和密码，一次也就够了，但是当我们每天push次数很多的时候，就已经很不耐烦了，所以为了避免这个问题，我们可以创建一个SSH秘钥，然后与GitHub进行配置，从此以后我们不需要输入任何密码！ 本次创建和配置我们是基于Linux进行的 创建生成一对秘钥，运行如下命令（注意输入自己的邮箱） ssh-keygen -t rsa -b 4096 -C “your_email@example.com” 输入命令之后，系统会让我们输入秘钥存放的位置，这里直接回车，也就是使用默认位置回车之后，输入密码，这里也是进行回车，因为密码是可选项， 注册当我们在本机创建了SSH密钥的时候，并不能够代表我们就可以使用了，我们需要在GitHub上进行注册，使用如下命令 启动SSH代理应用并重定向使用Bourne [root@localhost /]# eval “$(ssh-agent -s)” 使用代理注册SSH密钥 [root@localhost /]# ssh-add ~/.ssh/id_rsa","text":"经常使用GitHub的童鞋一定知道，当我们每次push的时候，都会遇到一个很尴尬的问题，输入用户名和密码，一次也就够了，但是当我们每天push次数很多的时候，就已经很不耐烦了，所以为了避免这个问题，我们可以创建一个SSH秘钥，然后与GitHub进行配置，从此以后我们不需要输入任何密码！ 本次创建和配置我们是基于Linux进行的 创建生成一对秘钥，运行如下命令（注意输入自己的邮箱） ssh-keygen -t rsa -b 4096 -C “your_email@example.com” 输入命令之后，系统会让我们输入秘钥存放的位置，这里直接回车，也就是使用默认位置回车之后，输入密码，这里也是进行回车，因为密码是可选项， 注册当我们在本机创建了SSH密钥的时候，并不能够代表我们就可以使用了，我们需要在GitHub上进行注册，使用如下命令 启动SSH代理应用并重定向使用Bourne [root@localhost /]# eval “$(ssh-agent -s)” 使用代理注册SSH密钥 [root@localhost /]# ssh-add ~/.ssh/id_rsa 获得SSH密钥 因为我们采用SSH密钥，因此我们需要一个公钥，一个私钥，所以当代码托管系统向我们询问 “SSH公钥”的时候，我们需要id_rsa.pub文件中的内容，通常存储在home的一个隐藏文件夹中 [root@localhost /]# cat ~/.ssh/id_rsa.pub 接下来，我们需要复制屏幕上输出的所有文本 粘贴到我们使用代码托管系统的设置页面中","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://sivan0222.cn/categories/GitHub/"},{"name":"Linux","slug":"GitHub/Linux","permalink":"http://sivan0222.cn/categories/GitHub/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sivan0222.cn/tags/Linux/"},{"name":"GitHub","slug":"GitHub","permalink":"http://sivan0222.cn/tags/GitHub/"}]},{"title":"js中取消事件冒泡的两种方式","slug":"js中取消事件冒泡的两种方式","date":"2017-11-30T05:56:02.000Z","updated":"2017-11-30T06:48:22.225Z","comments":true,"path":"2017/11/30/js中取消事件冒泡的两种方式/","link":"","permalink":"http://sivan0222.cn/2017/11/30/js中取消事件冒泡的两种方式/","excerpt":"事件冒泡的由来 当我们在给写好的控件绑定一个事件之前，它是没有绑定事件的，因此便需要将自己的相应的事件与父容器的相应的事件对应，从而就产生了事件冒泡，甚至于当我们在子容器谢了一个点击事件之后，点击子容器，子容器的点击事件执行，父容器的点击事件也会执行，但是子容器的点击事件最先执行，但是往往我们只需要子容器的点击事件，因此我们需要阻止事件冒泡！ 页面上有好多事件，也可以多个元素响应一个事件.假如: 1234567&lt;BODY onclick=\"alert('aaa');\"&gt;&lt;div onclick=\"alert('bbb');\"&gt; &lt;a href=\"#\" class=\"cooltip\" title=\"这是我的超链接提示1。\" onclick=\"alert('ddd');\"&gt; 提示 &lt;/a&gt;&lt;/div&gt;&lt;/BODY&gt; 上面这段代码一共有三个事件,body，div，a都分别绑定了单击事件。在页面中当单击a标签会连续弹出3个提示框。这就是事件冒泡引起的现象。事件冒 泡的过程是：a –&gt; div –&gt; body 。a冒泡到div冒泡到body。 本来在上面的代码中只想触发a元素的onclick事件，然而div,body事件也同时 触发了。因此我们必须要对事件的作用范围进行限制。当单击a元素的onclick事件时只触发a本身的事件。由于IE- DOM和标准DOM实现事件对象的方法各不相同，导致在不同浏览器中获取事件的对象变得比较困难。如果想阻止事件的传递，我们可以用 event.stopPropagation()阻止事件的传递行为.","text":"事件冒泡的由来 当我们在给写好的控件绑定一个事件之前，它是没有绑定事件的，因此便需要将自己的相应的事件与父容器的相应的事件对应，从而就产生了事件冒泡，甚至于当我们在子容器谢了一个点击事件之后，点击子容器，子容器的点击事件执行，父容器的点击事件也会执行，但是子容器的点击事件最先执行，但是往往我们只需要子容器的点击事件，因此我们需要阻止事件冒泡！ 页面上有好多事件，也可以多个元素响应一个事件.假如: 1234567&lt;BODY onclick=\"alert('aaa');\"&gt;&lt;div onclick=\"alert('bbb');\"&gt; &lt;a href=\"#\" class=\"cooltip\" title=\"这是我的超链接提示1。\" onclick=\"alert('ddd');\"&gt; 提示 &lt;/a&gt;&lt;/div&gt;&lt;/BODY&gt; 上面这段代码一共有三个事件,body，div，a都分别绑定了单击事件。在页面中当单击a标签会连续弹出3个提示框。这就是事件冒泡引起的现象。事件冒 泡的过程是：a –&gt; div –&gt; body 。a冒泡到div冒泡到body。 本来在上面的代码中只想触发a元素的onclick事件，然而div,body事件也同时 触发了。因此我们必须要对事件的作用范围进行限制。当单击a元素的onclick事件时只触发a本身的事件。由于IE- DOM和标准DOM实现事件对象的方法各不相同，导致在不同浏览器中获取事件的对象变得比较困难。如果想阻止事件的传递，我们可以用 event.stopPropagation()阻止事件的传递行为. 阻止事件冒泡方式一： 在子容器的方法最后添加一句(注意，这个event是事件参数，也就是我们传递过来的) event.stopPropagation() 123456789101112131415161718&lt;div id=\"mydiv\" style=\"border: 1px solid red ; width: 200px ; height: 200px;position: absolute;\"&gt; &lt;input id=\"mybtn\" type=\"button\" value=\"click me\"&gt;&lt;/div&gt;&lt;script&gt; onload = function()&#123; $(\"#mydiv\").bind(\"click\" , function()&#123;alert(123);&#125;); $(\"#mybtn\").bind(\"click\" , function(event)&#123; alert(456); /*用来阻止事件冒泡*/ event.stopPropagation(); &#125;); &#125;&lt;/script&gt; 方式二： 在子容器的代码中 可以将event.stopPropagation() 替换为 return false; 12345678910111213141516171819&lt;div id=\"mydiv\" style=\"border: 1px solid red ; width: 200px ; height: 200px;position: absolute;\"&gt; &lt;input id=\"mybtn\" type=\"button\" value=\"click me\"&gt;&lt;/div&gt;&lt;script&gt; onload = function()&#123; $(\"#mydiv\").bind(\"click\" , function()&#123; alert(123); &#125;); $(\"#mybtn\").bind(\"click\" , function(event)&#123; alert(456); return false; &#125;); &#125;&lt;/script&gt; 参照：百度百科","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sivan0222.cn/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sivan0222.cn/tags/JavaScript/"}]},{"title":"详解Java中的数组内存","slug":"Java中的数组","date":"2017-11-28T05:38:35.000Z","updated":"2017-11-28T07:24:13.249Z","comments":true,"path":"2017/11/28/Java中的数组/","link":"","permalink":"http://sivan0222.cn/2017/11/28/Java中的数组/","excerpt":"你了解数组么？ Java中，声明一个数组的过程中，内存将会如何分配Java数组初始化一共有多少种方式基本类型数组和引用类型数组之间，初始化时内存分配机制有什么区别 当我们使用Java数组之前，必须先对数组进行初始化（否则无法使用），当数组的所有元素都被分配了合适的内存空间，并指定了初始值时，数组初始化完成。程序以后将无法改变数组内存的大小以及位置。 数组初始化的两种方式数组是静态的 这里由于Java语言是典型的静态语言，因此Java的数组是静态的，即当数组被初始化之后，长度将不可以改变。而JavaScript则是动态语言，数组长度可以改变 静态初始化： 初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组的长度！ 1String[] num1= new String[] &#123;\"1\",\"2\"&#125;; 动态初始化： 初始化时程序只指定数组长度，由系统为数组元素分配初始值！ 初始值分配规则： 整数类型：byte short int long 数组元素默认值为0 浮点类型：float double 数组元素默认值为0.0 字符类型：char ，数组元素默认值为’\\u0000’ 布尔类型：boolean，数组元素的默认值为false 引用类型(类，接口，数组)：数组元素默认值为null 注意事项： 在我们初始化数组的时候，不可以同时声明数组的长度和给定数组元素的内容 一旦数组元素初始化完成，内存分配即结束，此时程序只可以改变数组元素的值，而不可以改变数组的长度 Java中的数组变量是一种引用类型的变量，数组变量本身并不是数组本身，只是指向堆内存数组对象而已！ 1String[] num2 = new String[2]; 此时，内存示意图如下： 不管采用了数组初始化的哪种方式，一旦数组初始化完成，数组的长度将无法改变！ 对于Java程序中所有的引用变量，都不需要经过初始化操作，需要初始化的是该引用变量所引用的对象！","text":"你了解数组么？ Java中，声明一个数组的过程中，内存将会如何分配Java数组初始化一共有多少种方式基本类型数组和引用类型数组之间，初始化时内存分配机制有什么区别 当我们使用Java数组之前，必须先对数组进行初始化（否则无法使用），当数组的所有元素都被分配了合适的内存空间，并指定了初始值时，数组初始化完成。程序以后将无法改变数组内存的大小以及位置。 数组初始化的两种方式数组是静态的 这里由于Java语言是典型的静态语言，因此Java的数组是静态的，即当数组被初始化之后，长度将不可以改变。而JavaScript则是动态语言，数组长度可以改变 静态初始化： 初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组的长度！ 1String[] num1= new String[] &#123;\"1\",\"2\"&#125;; 动态初始化： 初始化时程序只指定数组长度，由系统为数组元素分配初始值！ 初始值分配规则： 整数类型：byte short int long 数组元素默认值为0 浮点类型：float double 数组元素默认值为0.0 字符类型：char ，数组元素默认值为’\\u0000’ 布尔类型：boolean，数组元素的默认值为false 引用类型(类，接口，数组)：数组元素默认值为null 注意事项： 在我们初始化数组的时候，不可以同时声明数组的长度和给定数组元素的内容 一旦数组元素初始化完成，内存分配即结束，此时程序只可以改变数组元素的值，而不可以改变数组的长度 Java中的数组变量是一种引用类型的变量，数组变量本身并不是数组本身，只是指向堆内存数组对象而已！ 1String[] num2 = new String[2]; 此时，内存示意图如下： 不管采用了数组初始化的哪种方式，一旦数组初始化完成，数组的长度将无法改变！ 对于Java程序中所有的引用变量，都不需要经过初始化操作，需要初始化的是该引用变量所引用的对象！ 数组初始化的类型基本类型数组的初始化 对于基本类型数组而言，数组元素的值直接存储在对应的数组元素中 1234/*定义一个int[]类型的数组*/int[] iArr;/*静态初始化数组*/iArr = new int[] &#123;2, 5, -12, 20&#125;; 注意： 基本类型的值存储在栈内存中(这句话是完全错误的)，例如上面的iArr数组，都存储在堆内存中。事实上是局部变量是保存在栈内存里保存的，不管是基本类型的变量，还是引用类型的变量，都是存储在各自的方法栈区中，但引用类型变量所引用的对象则总是存储在堆内存中！ Java中，堆内存中的对象不允许直接访问，为了访问堆内存中的对象，通常只能通过引用变量进行访问。(体现了Java的健壮性，避免程序crash) 事实上，引用变量实际上就是一个指针，只要程序通过引用变量访问属性，或者通过引用变量来调用方法，则该引用变量将会由它所引用的对象替代！ 引用类型数组的初始化 引用类型数组的数组元素依然是引用类型的，因此数组元素里存储的还是引用，它指向另一块内存，这块内存里面存储了该引用变量所引用的对象！ 123456789101112131415161718192021222324252627282930313233343536373839404142public class Person &#123; /*年龄*/ public int age; /*身高*/ public double height; public void info() &#123; System.out.println(\"我的年龄是：\" + age + \"，我的身高是：\" + height); &#125;&#125;public class ReferenceArrayTest &#123; public static void main(String[] args) &#123; /*定义一个students数组变量*/ Person[] students; students = new Person[2]; System.out.println(\"students所引用的数组长度是：\" + students.length); Person zhang = new Person(); zhang.age = 15; zhang.height = 158; Person lee = new Person(); lee.age = 16; lee.height = 161; students[0] = zhang; students[1] = lee; lee.info(); students[1].info(); &#125;&#125; 对于上面这段代码，内存分配如下： 最后的内存如下： 注意事项： 对于引用类型的数组而言，它的数组元素其实就是一个引用类型的变量，因此可以指向任何有效的内存(有效指的是强类型的约束,比如Person类型的数组，数组中每个元素的类型都相当于Person类型的变量)","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"数组","slug":"Java/数组","permalink":"http://sivan0222.cn/categories/Java/数组/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"数组","slug":"数组","permalink":"http://sivan0222.cn/tags/数组/"}]},{"title":"dom4j与XStream的使用","slug":"dom4j与XStream的使用","date":"2017-11-24T08:31:11.000Z","updated":"2017-11-23T08:43:54.375Z","comments":true,"path":"2017/11/24/dom4j与XStream的使用/","link":"","permalink":"http://sivan0222.cn/2017/11/24/dom4j与XStream的使用/","excerpt":"对于XML的处理，这里简单的使用开源框架Dom4j和XStream来实现 Dom4j Dom4j是一个优秀的Java XML API ,主要用于读写XML格式的数据，Dom4j具有性能优异，功能强大，易于使用等特点，同时也是一个开源的软件 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @date 2017年11月23日 下午3:54:48 * @author SiVan */package com.test;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.DocumentHelper;import org.dom4j.Element;/** * @author SiVan * @time 2017年11月23日 下午3:54:48 * @TODO TODO */public class Dom4jTest &#123; public static void main(String[] args) throws DocumentException &#123; StringBuffer sb = new StringBuffer(); sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?&gt;\") .append(\"&lt;person&gt;\") .append(\"&lt;name&gt;吴晓文&lt;/name&gt;\") .append(\"&lt;sex&gt;男&lt;/sex&gt;\") .append(\"&lt;address&gt;山西省朔州市&lt;/address&gt;\") .append(\"&lt;/person&gt;\"); /* 通过解析XML字符串创建Document对象 */ Document document = DocumentHelper.parseText(sb.toString()); Element root = document.getRootElement(); /* 得到根元素下面的所有子节点 */ List&lt;Element&gt; elementList = root.elements(); /* 遍历所有子节点 */ for (Element element : elementList) &#123; System.out.println(element.getName() + \"=&gt; \" + element.getText()); &#125; &#125;&#125;","text":"对于XML的处理，这里简单的使用开源框架Dom4j和XStream来实现 Dom4j Dom4j是一个优秀的Java XML API ,主要用于读写XML格式的数据，Dom4j具有性能优异，功能强大，易于使用等特点，同时也是一个开源的软件 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * @date 2017年11月23日 下午3:54:48 * @author SiVan */package com.test;import java.util.List;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.DocumentHelper;import org.dom4j.Element;/** * @author SiVan * @time 2017年11月23日 下午3:54:48 * @TODO TODO */public class Dom4jTest &#123; public static void main(String[] args) throws DocumentException &#123; StringBuffer sb = new StringBuffer(); sb.append(\"&lt;?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?&gt;\") .append(\"&lt;person&gt;\") .append(\"&lt;name&gt;吴晓文&lt;/name&gt;\") .append(\"&lt;sex&gt;男&lt;/sex&gt;\") .append(\"&lt;address&gt;山西省朔州市&lt;/address&gt;\") .append(\"&lt;/person&gt;\"); /* 通过解析XML字符串创建Document对象 */ Document document = DocumentHelper.parseText(sb.toString()); Element root = document.getRootElement(); /* 得到根元素下面的所有子节点 */ List&lt;Element&gt; elementList = root.elements(); /* 遍历所有子节点 */ for (Element element : elementList) &#123; System.out.println(element.getName() + \"=&gt; \" + element.getText()); &#125; &#125;&#125; XStream XStream是Thoughtworks公司发布的一个开源Java类库，能够实现XML与Java对象之间的转换。使用非常简单，不需要预先生成其他辅助类，也不需要依赖于任何映射文件，还具有很强大的扩展功能！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/** * @date 2017年11月23日 下午4:12:49 * @author SiVan */package com.test;import com.thoughtworks.xstream.XStream;import com.thoughtworks.xstream.io.xml.DomDriver;/** * @author SiVan * @time 2017年11月23日 下午4:12:49 * @TODO TODO XStream的使用示例 */public class XStreamTest &#123; static class Person &#123; private String name; private String sex; private String address; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getAddress() &#123; return address; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; /** * Java对象转换为XML * @param person Java对象 * @return */ public static String javaObject2Xml(Person person) &#123; XStream xs = new XStream(new DomDriver()); /*给Person类定义别名*/ xs.alias(\"person\", person.getClass()); return xs.toXML(person); &#125; /** * XML对象转换为Java对象 * @param xml * @return */ public static Object xml2JavaObject(String xml) &#123; XStream xs = new XStream(new DomDriver()); /*给Person类定义别名*/ xs.alias(\"person\", Person.class); Person person = (Person) xs.fromXML(xml); return person; &#125; public static void main(String[] args) &#123; /*创建Person对象*/ Person p1 = new Person(); p1.setName(\"吴晓文\"); p1.setSex(\"男\"); p1.setAddress(\"山西省朔州市\"); /*将p1对象转换为XML字符串*/ System.out.println(javaObject2Xml(p1)); /*构造XML字符串*/ String xml = \"&lt;person&gt;&lt;name&gt;路遥&lt;/name&gt;&lt;sex&gt;男&lt;/sex&gt;&lt;address&gt;贵州贵阳&lt;/address&gt;&lt;/person&gt;\"; Person p2 = (Person) xml2JavaObject(xml); System.out.println(p2.getName() + \"\\t\" + p2.getSex() + \"\\t\" + p2.getAddress()); &#125;&#125; 注意：默认情况下，使用XStream转换Java对象得到的XML文档根节点为完整的Java类名，但当我们使用了如下代码设置别名的时候将会返回一个Person根节点 xs.alias(“person”, person.getClass); 当我们使用内部类的时候，需要注意，如果报出如下错误（因为我们在静态方法中创建了动态内部类） No enclosing instance of type AA is accessible. Must qualify the allocation with an enclosing instance of type SimpleTh","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"XML","slug":"Java/XML","permalink":"http://sivan0222.cn/categories/Java/XML/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"XML","slug":"XML","permalink":"http://sivan0222.cn/tags/XML/"}]},{"title":"微信开发(1)","slug":"微信开发-1","date":"2017-11-23T07:25:22.000Z","updated":"2017-11-26T01:38:53.398Z","comments":true,"path":"2017/11/23/微信开发-1/","link":"","permalink":"http://sivan0222.cn/2017/11/23/微信开发-1/","excerpt":"前言： 在我写这篇文章之前，博主就已经看了一下微信公众号以及微信小程序的历史，不得不感叹自己老了！随着最近几年Native App的兴起和衰落，自己本认为可以火的Native App现在逐渐被一些light App所挤占，很大一部分尤以腾讯的微信为平台！ 这篇文章主要是记录自己开始微信开发的第一页，也是目前比较紧急的事情，因为要为公司开发一款微信公众号，虽然开发已经过去2个月了，2个月自己也是跌跌撞撞，做了很多自己不擅长的事情，产品需求的分析与设计，界面的设计与编写，产品的架构…..很多自己不敢想象的事情还是做了！ 准备工作 拥有一款已经注册且通过的认证号或者服务号 拥有一个独立服务器(自己用的花生壳，可以免费内网映射1G流量) ….貌似没有了(其实读者应该去看一下开发文档文档) 接入微信公众号 接入微信公众号也就是通俗上的告诉微信服务器，你的服务器就是你自己申请的微信公众号的服务器。(验证服务器是否被微信识别) 如何接入微信公众号 登录微信公众平台-&gt;开发-&gt;开发者工具-&gt;公众平台测试帐号-&gt;接口配置信息-&gt;修改 配置url 配置token 流程： 配置URL和token之后，微信公众号会向配置好的url发送一个get请求，将会携带如下4个参数（token就是我们刚刚配置的）signature微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。timestamp时间戳nonce随机数echostr随机字符串 将token、timestamp、nonce三个参数进行字典序排序(升序) 将三个参数字符串拼接成一个字符串进行sha1加密(得到的是一个加密后的十六进制字符串) 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 如果请求通过，我们需要返回一个echostr(微信服务器传给我们的)给微信服务器","text":"前言： 在我写这篇文章之前，博主就已经看了一下微信公众号以及微信小程序的历史，不得不感叹自己老了！随着最近几年Native App的兴起和衰落，自己本认为可以火的Native App现在逐渐被一些light App所挤占，很大一部分尤以腾讯的微信为平台！ 这篇文章主要是记录自己开始微信开发的第一页，也是目前比较紧急的事情，因为要为公司开发一款微信公众号，虽然开发已经过去2个月了，2个月自己也是跌跌撞撞，做了很多自己不擅长的事情，产品需求的分析与设计，界面的设计与编写，产品的架构…..很多自己不敢想象的事情还是做了！ 准备工作 拥有一款已经注册且通过的认证号或者服务号 拥有一个独立服务器(自己用的花生壳，可以免费内网映射1G流量) ….貌似没有了(其实读者应该去看一下开发文档文档) 接入微信公众号 接入微信公众号也就是通俗上的告诉微信服务器，你的服务器就是你自己申请的微信公众号的服务器。(验证服务器是否被微信识别) 如何接入微信公众号 登录微信公众平台-&gt;开发-&gt;开发者工具-&gt;公众平台测试帐号-&gt;接口配置信息-&gt;修改 配置url 配置token 流程： 配置URL和token之后，微信公众号会向配置好的url发送一个get请求，将会携带如下4个参数（token就是我们刚刚配置的）signature微信加密签名，signature结合了开发者填写的token参数和请求中的timestamp参数、nonce参数。timestamp时间戳nonce随机数echostr随机字符串 将token、timestamp、nonce三个参数进行字典序排序(升序) 将三个参数字符串拼接成一个字符串进行sha1加密(得到的是一个加密后的十六进制字符串) 开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 如果请求通过，我们需要返回一个echostr(微信服务器传给我们的)给微信服务器 代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/** * @date 2017年11月23日 下午2:44:22 * @author SiVan */package com.util;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Arrays;/** * @param signature 微信加密签名， * @param timestamp 时间戳 * @param nonce 随机数 * @author SiVan * @time 2017年11月23日 下午2:44:22 * @TODO TODO 请求校验程序的实现 */public class CheckUtil &#123; /*微信测试号接口配置信息的Token，内容要完全一致*/ private static final String token = \"123456\"; /** * 将token，timestamp，nonce 三个参数的内容进行字典序排序， * 拼接成字符串，并且进行SHA-1加密，与signature进行比对，如果一致返回true,否则返回false * @param signature 微信加密签名， * @param timestamp 时间戳 * @param nonce 随机数 * @return */ public static boolean check(String signature, String timestamp, String nonce) &#123; /*进行字典序排序*/ String[] params = new String[] &#123; token, timestamp, nonce &#125;; Arrays.sort(params); /*排序后的字符串进行拼接*/ StringBuffer sb = new StringBuffer(); sb = sb.append(params[0]).append(params[1]).append(params[2]); /*进行加密*/ String cipherText = sb.toString(); MessageDigest md = null; try &#123; md = MessageDigest.getInstance(\"SHA-1\"); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; byte[] digest = md.digest(cipherText.getBytes()); cipherText = byteToString(digest); return cipherText != null ? cipherText.equals(signature.toUpperCase()) : false; &#125; /*字节数组转换为十六进制字符串*/ private static String byteToString(byte[] byteArray) &#123; String strDigest = \"\"; for (int i = 0; i &lt; byteArray.length; i++) &#123; strDigest += byteToHexStr(byteArray[i]); &#125; return strDigest; &#125; /*字节转换为十六进制字符串*/ private static String byteToHexStr(byte mByte) &#123; char[] Digit = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'&#125;; char[] tempArr = new char[2]; tempArr[0] = Digit[(mByte &gt;&gt;&gt; 4) &amp; 0X0F]; tempArr[1] = Digit[mByte &amp; 0X0F]; String s = new String(tempArr); return s; &#125;&#125; 测试程序：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @date 2017年11月22日 下午8:05:42 * @author SiVan */package com.servlet;import java.io.IOException;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.Arrays;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.util.CheckUtil;/** * @author SiVan * @time 2017年11月22日 下午8:05:42 * @TODO TODO 验证消息来自微信服务器 * * 请求 * */public class SignUtil extends HttpServlet&#123; /** * 1）将token、timestamp、nonce三个参数进行字典序排序 2）将三个参数字符串拼接成一个字符串进行sha1加密,加密后的字符串是十六进制的 3）开发者获得加密后的字符串可与signature对比，标识该请求来源于微信 */ @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; checkSign( request, response); &#125; /** * @param request * @param response * @throws IOException */ private void checkSign(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String signature = request.getParameter(\"signature\"); String timestamp = request.getParameter(\"timestamp\"); String nonce = request.getParameter(\"nonce\"); String echostr = request.getParameter(\"echostr\"); /*验证通过回写echostr*/ if( CheckUtil.check(signature, timestamp, nonce)) &#123; response.getWriter().print(echostr); &#125;else&#123; response.getWriter().print(\"false\"); &#125; &#125;&#125; 注意：url配置的时候需要具体到我们接收参数的地址 请求校验的原因： 为了防止他人向公众号服务器发送恶意请求，需要对每个消息请求进行合法校验，微信服务器向公众号服务器POST消息时，也会在URL后面追加4个参数，分别是signature,timestamp,nonce,echostr，依然是通过校验签名判断消息的真实性！与上面讲的完全一致！ 总结：当你点击在配置URL和Token点击提交的时候，如果配置失败，那么请你重新检查一下你的程序，确保你返回了echostr，如果配置成功，那么恭喜你，你的服务器算得上一个微信公众号服务器了2333！","categories":[{"name":"微信","slug":"微信","permalink":"http://sivan0222.cn/categories/微信/"},{"name":"开发","slug":"微信/开发","permalink":"http://sivan0222.cn/categories/微信/开发/"}],"tags":[{"name":"微信开发","slug":"微信开发","permalink":"http://sivan0222.cn/tags/微信开发/"}]},{"title":"MyBatis中的基本概念","slug":"MyBatis中的基本概念","date":"2017-11-22T11:25:15.000Z","updated":"2017-11-22T11:32:15.712Z","comments":true,"path":"2017/11/22/MyBatis中的基本概念/","link":"","permalink":"http://sivan0222.cn/2017/11/22/MyBatis中的基本概念/","excerpt":"前言 pojo：不按MVC进行分层，只有Java Bean有一些属性，还有get以及set方法 domain：不按MVC进行分层，只有Java Bean有一些属性，还有get以及set方法 po：用在持久层，相当于 pojo+xml！在页面中进行添加或者修改的时候，直接传入到action中！ po中的类名等于表名，属性名等于字段名，还有对应的set以及get方法 vo：View Object表现层对象，主要用于在高级查询中接收从页面中传过来的参数，好处是扩展性强！ bo：用在service层，现在基本不用 pojo,domain.po,vo,bo可以用在各种层面，不会报错！（也就是说po用在表现层，vo用在表现层不报错，因为都是普通的java bean没有语法错误）最好不用混着用，不利于代码维护！ MyBatis中的原理 输入映射：对于每条Sql语句指定的输入参数的类型（只可以指定Map,基本数据类型(包括String)，以及POJO）输出映射：返回的结果集类型（只可以指定Map,List,基本数据类型(包括String)，以及POJO） MyBatis中的执行器 当我们使用MyBatis中的SqlSession执行Sql语句的时候，MyBatis会内部调用Executor接口来执行映射文件中配置好的(也就是通过调用MappedStatement)Sql语句 基本执行器 缓存执行器 返回数据库自增主键数据库中我们可以使用如下代码，来查询刚刚插入的记录的主键值，会返回1个01SELECT LAST_INSERT_ID; 但是如果我们在MyBatis中配置了如下代码，将会返回刚刚插入的主键记录的值 1234567891011121314151617&lt;!-- 方法1 --&gt;&lt;insert id=\"addStudent\" parameterType=\"com.pojo.Student\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; insert into student(name,sex,birthday) values(#&#123;name&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)&lt;/insert&gt;&lt;!-- 方法2 --&gt;&lt;insert id=\"addStudent2\" parameterType=\"com.pojo.Student\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; &lt;!-- keyProperty指定自增主键的值返回到POJO的哪个属性中 order指相对于下面insert插入语句的执行顺序 --&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; SELECT LAST_INSERT_ID(); &lt;/selectKey&gt; insert into student(name,sex,birthday) values(#&#123;name&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)&lt;/insert&gt;","text":"前言 pojo：不按MVC进行分层，只有Java Bean有一些属性，还有get以及set方法 domain：不按MVC进行分层，只有Java Bean有一些属性，还有get以及set方法 po：用在持久层，相当于 pojo+xml！在页面中进行添加或者修改的时候，直接传入到action中！ po中的类名等于表名，属性名等于字段名，还有对应的set以及get方法 vo：View Object表现层对象，主要用于在高级查询中接收从页面中传过来的参数，好处是扩展性强！ bo：用在service层，现在基本不用 pojo,domain.po,vo,bo可以用在各种层面，不会报错！（也就是说po用在表现层，vo用在表现层不报错，因为都是普通的java bean没有语法错误）最好不用混着用，不利于代码维护！ MyBatis中的原理 输入映射：对于每条Sql语句指定的输入参数的类型（只可以指定Map,基本数据类型(包括String)，以及POJO）输出映射：返回的结果集类型（只可以指定Map,List,基本数据类型(包括String)，以及POJO） MyBatis中的执行器 当我们使用MyBatis中的SqlSession执行Sql语句的时候，MyBatis会内部调用Executor接口来执行映射文件中配置好的(也就是通过调用MappedStatement)Sql语句 基本执行器 缓存执行器 返回数据库自增主键数据库中我们可以使用如下代码，来查询刚刚插入的记录的主键值，会返回1个01SELECT LAST_INSERT_ID; 但是如果我们在MyBatis中配置了如下代码，将会返回刚刚插入的主键记录的值 1234567891011121314151617&lt;!-- 方法1 --&gt;&lt;insert id=\"addStudent\" parameterType=\"com.pojo.Student\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; insert into student(name,sex,birthday) values(#&#123;name&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)&lt;/insert&gt;&lt;!-- 方法2 --&gt;&lt;insert id=\"addStudent2\" parameterType=\"com.pojo.Student\" keyProperty=\"id\" useGeneratedKeys=\"true\"&gt; &lt;!-- keyProperty指定自增主键的值返回到POJO的哪个属性中 order指相对于下面insert插入语句的执行顺序 --&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; SELECT LAST_INSERT_ID(); &lt;/selectKey&gt; insert into student(name,sex,birthday) values(#&#123;name&#125;, #&#123;sex&#125;, #&#123;birthday&#125;)&lt;/insert&gt; 使用UUID生成主键 由于数据库中的主键无法使用字符串进行自动增长，所以当我们使用字符串作为主键的时候，我们需要用到UUID算法，帮助我们生成主键，这里原理就是利用了数据库中的UUID()函数 12345678&lt;!-- 使用UUID主键方式,uuid必须是先生成，然后传入到student对象里面 --&gt; &lt;insert id=\"addStudent3\" parameterType=\"com.pojo.Student\"&gt; &lt;selectKey keyProperty=\"id\" order=\"BEFORE\"&gt; &lt;!-- 使用数据库的自动生成策略 --&gt; SELECT UUID() &lt;/selectKey&gt; insert into student(id,sex,name,birthday) values(#&#123;id&#125;,#&#123;sex&#125;,#&#123;name&#125;,#&#123;birthday&#125;) &lt;/insert&gt; 1234567891011121314151617181920212223242526/** * 使用UUID生成主键 * @author SiVan * */public class Demo4 &#123; public static void main(String[] args) &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); Student student = new Student(); student.setBirthday(Timestamp.valueOf(\"1997-02-22 10:10:10\")); student.setName(\"吴晓文\"); student.setSex(\"1\"); student.setId(UUID.randomUUID().toString()); int i = session.insert(\"com.dao.StudentDao.addStudent3\",student); session.commit(); session.close(); System.out.println(student.getId()); System.out.println(i); &#125;&#125; 核心配置文件中引入资源文件 对于MyBatis,有时候我们需要配置参数在额外的资源文件中，下面以JDBC4个参数例子进行配置 编写资源文件 db.properties 注意：后面的参数不可以包含空格 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/s59jdbc.username=rootjdbc.password=root 在SqlMapConfig文件中进行配置(引入配置文件)：123456789101112131415161718192021&lt;configuration&gt; &lt;!-- 引入配置文件 --&gt; &lt;properties resource=\"db.properties\"&gt;&lt;/properties&gt; &lt;environments default=\"MySql\"&gt; &lt;environment id=\"MySql\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;jdbc.driver&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt;&lt;mappers&gt; &lt;mapper resource=\"com/pojo/Student.xml\"/&gt;&lt;/mappers&gt;&lt;/configuration&gt;","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"MyBatis","slug":"框架/MyBatis","permalink":"http://sivan0222.cn/categories/框架/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://sivan0222.cn/tags/MyBatis/"},{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/tags/框架/"}]},{"title":"MyBatis中Dao开发的两种方式","slug":"MyBatis两种生成Dao的方式","date":"2017-11-20T11:02:52.000Z","updated":"2017-11-22T11:21:19.265Z","comments":true,"path":"2017/11/20/MyBatis两种生成Dao的方式/","link":"","permalink":"http://sivan0222.cn/2017/11/20/MyBatis两种生成Dao的方式/","excerpt":"Dao的两种开发方式 原始Dao的开发方法(接口与实现类，手动编写) 动态代理方式(使用Mapper接口代理的方式) 原始Dao编写编写StudentDao接口：12345678910111213/** * 一个user的持久化接口 * @author SiVan * */public interface UserDao &#123; /*查找所有学生*/ public List&lt;Student&gt; findAll(); public Student findStudentById(Integer id);&#125; 编写UserDaoImpl(也就是UserDao的实现类) 编写实现类的时候，我们注意到每个具体的方法都会有一个session，由于session是线程不安全的，所以session最好的作用范围便是方法之内！ 12345678910111213141516171819202122232425262728/** * 具体的UserDao实现类 */import com.pojo.Student;public class UserDaoImpl implements UserDao&#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; @Override public List&lt;Student&gt; findAll() &#123; /*由于SqlSession是线程不安全的，因此SqlSession最好的作用域便是方法内*/ SqlSession session = factory.openSession(); return session.selectList(\"com.dao.StudentDao.findAll\"); &#125; @Override public Student findStudentById(Integer id) &#123; SqlSession session = factory.openSession(); return (Student) session.selectOne(\"com.dao.StudentDao.findStudentById\",id); &#125;&#125; 编写测试类（需要初始化factory）123456789101112131415161718192021222324252627282930313233package com.demo;import java.io.InputStream;import java.util.List;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.dao.UserDao;import com.dao.UserDaoImpl;import com.pojo.Student;public class UserDaoTest &#123; private static SqlSessionFactory factory; /*初始化*/ public static void setUp() &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); System.out.println(\"s\"); &#125; public static void main(String[] args) &#123; setUp(); UserDao userDao = new UserDaoImpl(factory); System.out.println(factory); System.out.println(userDao); List list = userDao.findAll(); System.out.println(list); &#125;&#125;","text":"Dao的两种开发方式 原始Dao的开发方法(接口与实现类，手动编写) 动态代理方式(使用Mapper接口代理的方式) 原始Dao编写编写StudentDao接口：12345678910111213/** * 一个user的持久化接口 * @author SiVan * */public interface UserDao &#123; /*查找所有学生*/ public List&lt;Student&gt; findAll(); public Student findStudentById(Integer id);&#125; 编写UserDaoImpl(也就是UserDao的实现类) 编写实现类的时候，我们注意到每个具体的方法都会有一个session，由于session是线程不安全的，所以session最好的作用范围便是方法之内！ 12345678910111213141516171819202122232425262728/** * 具体的UserDao实现类 */import com.pojo.Student;public class UserDaoImpl implements UserDao&#123; private SqlSessionFactory factory; public UserDaoImpl(SqlSessionFactory factory) &#123; this.factory = factory; &#125; @Override public List&lt;Student&gt; findAll() &#123; /*由于SqlSession是线程不安全的，因此SqlSession最好的作用域便是方法内*/ SqlSession session = factory.openSession(); return session.selectList(\"com.dao.StudentDao.findAll\"); &#125; @Override public Student findStudentById(Integer id) &#123; SqlSession session = factory.openSession(); return (Student) session.selectOne(\"com.dao.StudentDao.findStudentById\",id); &#125;&#125; 编写测试类（需要初始化factory）123456789101112131415161718192021222324252627282930313233package com.demo;import java.io.InputStream;import java.util.List;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.dao.UserDao;import com.dao.UserDaoImpl;import com.pojo.Student;public class UserDaoTest &#123; private static SqlSessionFactory factory; /*初始化*/ public static void setUp() &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); factory = new SqlSessionFactoryBuilder().build(in); System.out.println(\"s\"); &#125; public static void main(String[] args) &#123; setUp(); UserDao userDao = new UserDaoImpl(factory); System.out.println(factory); System.out.println(userDao); List list = userDao.findAll(); System.out.println(list); &#125;&#125; 动态代理实现Dao MyBatis希望我们能够以1个接口的形式来书写规范，然后会自动根据我们书写的接口自动生成相应的实现类，我们只需要调用相应的方法就可以了 注意：动态代理实现Dao需要MyBatis3.2以上的支持！！！ 编写Dao接口MyBatis严格控制书写对应Mapper的接口规则： 接口名字必须等于Mapper映射文件的namespace名字 接口的方法名字必须等于Mapper映射文件的id名字 接口的方法参数类型必须等于Mapper映射文件的参数类型 接口的方法返回类型必须等于Mapper映射文件的结果集类型 注意事项： Mapper对应的配置文件与我们自己书写的Mapper接口必须在同一个文件夹下 Mapper对应的配置文件与我们自己书写的Mapper接口名字必须相同，后缀不同 编写Mapper对应的配置文件编写Mapper对应的接口12345678910111213package com.mapper;import java.util.List;import com.pojo.Student;public interface UserMapper &#123; public List findAll(); public Student findStudentById(Integer id);&#125; 在总配置文件中添加刚刚编写的Mapper对应的配置文件123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 编写UserMapper接口的配置文件， 编写规则（4点） --&gt; &lt;mapper namespace=\"com.mapper.UserMapper\"&gt; &lt;!-- 查询所有学生 --&gt; &lt;select id=\"findAll\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student &lt;/select&gt; &lt;select id=\"findStudentById\" parameterType=\"java.lang.Integer\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 编写测试类1234567891011121314151617181920212223242526package com.demo;import java.io.InputStream;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.mapper.UserMapper;import com.pojo.Student;public class UserMapperTest &#123; public static void main(String[] args) &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); UserMapper mapper = session.getMapper(UserMapper.class); List&lt;Student&gt; list = mapper.findAll(); System.out.println(list); &#125;&#125;","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"MyBatis","slug":"框架/MyBatis","permalink":"http://sivan0222.cn/categories/框架/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://sivan0222.cn/tags/MyBatis/"},{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/tags/框架/"}]},{"title":"深入使用MyBatis","slug":"深入使用MyBatis","date":"2017-11-19T11:02:52.000Z","updated":"2017-11-22T11:17:20.709Z","comments":true,"path":"2017/11/19/深入使用MyBatis/","link":"","permalink":"http://sivan0222.cn/2017/11/19/深入使用MyBatis/","excerpt":"前言 前面几篇文章简要介绍了MyBatis的基本使用，以及一些基本概念，包括我们经常所用到的POJO，还有Dao的两种开发方式，但是我们经常使用的便是VO(View Object)，通过VO我们直接进行业务调用更加容易理解，因为我们每次传递的都是一个VO对象，而不是一个页面传入多个对象，尤其是对于MyBatis中的Sql操作而言，只能传入一个对象，我们可以传入Map，但是不建议这么做，建议使用我们下面所说的VO 使用VO进行MyBatis的高级查询输入映射输入映射就是我们在Mapper配置文件中所配置的parameterType，不仅仅是基本数据类型，还可以是POJO类型，还可以是VO类型！ 假设有一个页面只是对于用户进行操作，VO便是从页面传过来的对象。使用VO可以给我们带来很大的扩展性，进行任何的操作都可以通过VO来进行，可以用来避免使用Map， 用到的POJO类的编写：1234567891011121314151617181920212223242526272829303132333435363738package com.pojo;import java.io.Serializable;import java.sql.Timestamp;public class Student implements Serializable&#123; private Integer id; private String name; private String sex; private Timestamp birthday; public Student() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Timestamp getBirthday() &#123; return birthday; &#125; public void setBirthday(Timestamp birthday) &#123; this.birthday = birthday; &#125;&#125;","text":"前言 前面几篇文章简要介绍了MyBatis的基本使用，以及一些基本概念，包括我们经常所用到的POJO，还有Dao的两种开发方式，但是我们经常使用的便是VO(View Object)，通过VO我们直接进行业务调用更加容易理解，因为我们每次传递的都是一个VO对象，而不是一个页面传入多个对象，尤其是对于MyBatis中的Sql操作而言，只能传入一个对象，我们可以传入Map，但是不建议这么做，建议使用我们下面所说的VO 使用VO进行MyBatis的高级查询输入映射输入映射就是我们在Mapper配置文件中所配置的parameterType，不仅仅是基本数据类型，还可以是POJO类型，还可以是VO类型！ 假设有一个页面只是对于用户进行操作，VO便是从页面传过来的对象。使用VO可以给我们带来很大的扩展性，进行任何的操作都可以通过VO来进行，可以用来避免使用Map， 用到的POJO类的编写：1234567891011121314151617181920212223242526272829303132333435363738package com.pojo;import java.io.Serializable;import java.sql.Timestamp;public class Student implements Serializable&#123; private Integer id; private String name; private String sex; private Timestamp birthday; public Student() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Timestamp getBirthday() &#123; return birthday; &#125; public void setBirthday(Timestamp birthday) &#123; this.birthday = birthday; &#125;&#125; VO类的书写：123456789101112public class StudentVo &#123; private Student student; public Student getStudent() &#123; return student; &#125; public void setStudent(Student student) &#123; this.student = student; &#125;&#125; UserMapper的编写：12345678910package com.mapper;import java.util.List;import com.pojo.Student;import com.vo.StudentVo;public interface UserMapper &#123; public List&lt;Student&gt; findStudentByNameAndSex(StudentVo student);&#125; 配置文件的编写：注意这里参数的类型是VO类型，传值的时候是POJO.属性(因为POJO已经是VO的属性了)12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.mapper.UserMapper\"&gt; &lt;select id=\"findStudentByNameAndSex\" parameterType=\"com.vo.StudentVo\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student where name like '%$&#123;student.name&#125;%' and sex = $&#123;student.sex&#125; &lt;/select&gt; &lt;/mapper&gt; 测试类的编写：123456789101112131415161718192021222324252627282930import java.util.List;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.mapper.UserMapper;import com.pojo.Student;import com.vo.StudentVo;public class StudentVoTest &#123; public static void main(String[] args) &#123; SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(Student.class.getResourceAsStream(\"/SqlMapConfig.xml\")); SqlSession session = factory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); Student student = new Student(); student.setName(\"吴\"); student.setSex(\"1\"); StudentVo studentVo = new StudentVo(); studentVo.setStudent(student); List&lt;Student&gt; list = userMapper.findStudentByNameAndSex(studentVo); for (Student student2 : list) &#123; System.out.println(student2.getId() + \"\\t\" + student2.getName() + \"\\t\" + student2.getBirthday()); &#125; session.close(); &#125;&#125; 注意事项：由于这里使用了VO，并且VO里面配置了一个POJO属性，并且设置了相应的set以及get方法，之后在POJO的配置文件中编写了具体的配置，并且参数类型是一个VO 输出映射 输出映射就是返回的结果集，可以有包装类，基本数据类型 只有在数据库返回的结果为1行1列数据的时候我们才可以使用基本数据类型 聚合数据查询例子配置文件12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 编写UserMapper接口的配置文件， 编写规则（4点） --&gt; &lt;mapper namespace=\"com.mapper.UserMapper\"&gt; &lt;!-- 查询学生总人数 --&gt; &lt;select id=\"getStudentCount\" resultType=\"java.lang.Integer\"&gt; select count(*) from student &lt;/select&gt; &lt;/mapper&gt; UserMapper接口1234567891011package com.mapper;import java.util.List;import com.pojo.Student;import com.vo.StudentVo;public interface UserMapper &#123; public int getStudentCount();&#125; 测试实例1234567891011121314151617181920package com.demo;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.mapper.UserMapper;import com.pojo.Student;public class GetStudentCountTest &#123; public static void main(String[] args) &#123; SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(Student.class.getResourceAsStream(\"/SqlMapConfig.xml\")); SqlSession session = factory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); int c = userMapper.getStudentCount(); System.out.println(c); &#125;&#125; MyBatis中的动态语句动态Where子句 之前我们在使用JDBC的时候，需要自己手动一个条件一个条件的进行拼接，但是MyBatis却给了我们极大的便利，以至于我们使用一个标签就可以解决问题！ 根据姓名以及性别查询学生，如果输入了姓名和性别，则根据两个条件进行查询；如果输入了姓名，则根据姓名进行查询;如果输入了性别，则根据性别进行查询！ UserMapper.xml配置文件12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.mapper.UserMapper\"&gt; &lt;!-- 动态Sql查询语句 --&gt; &lt;select id=\"dynamicWhere\" parameterType=\"com.pojo.Student\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student &lt;!-- 动态where子句会自动根据需要去掉行首的and --&gt; &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; and name like '%$&#123;name&#125;%' &lt;/if&gt; &lt;if test=\"sex != null\"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; &lt;/mapper&gt; Mapper代理接口123456789101112package com.mapper;import java.util.List;import com.pojo.Student;import com.vo.StudentVo;public interface UserMapper &#123; public List&lt;Student&gt; dynamicWhere(Student student);&#125; 测试：12345678910111213141516171819202122232425package com.demo;import java.util.List;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import com.mapper.UserMapper;import com.pojo.Student;public class DynamicWhereTest &#123; public static void main(String[] args) &#123; SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(Student.class.getResourceAsStream(\"/SqlMapConfig.xml\")); SqlSession session = factory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); Student student = new Student(); student.setName(\"吴\"); List&lt;Student&gt; list = userMapper.dynamicWhere(student); System.out.println(list); &#125;&#125; 配置文件中封装SQL语句 有时候我们在配置文件中大量书写重复的SQL语句，效率低下，因此MyBatis可以让我们手动配置Sql语句，以便能够重用提高我们的开发效率 配置之后的UserMapper.xml1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.mapper.UserMapper\"&gt; &lt;sql id=\"user_Where\"&gt; &lt;!-- 动态where子句会自动根据需要去掉行首的and --&gt; &lt;where&gt; &lt;if test=\"name != null and name != ''\"&gt; and name like '%$&#123;name&#125;%' &lt;/if&gt; &lt;if test=\"sex != null\"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/sql&gt; &lt;!-- 动态Sql查询语句 --&gt; &lt;select id=\"dynamicWhere\" parameterType=\"com.pojo.Student\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student &lt;!-- 动态where子句会自动根据需要去掉行首的and --&gt; &lt;include refid=\"user_Where\"&gt;&lt;/include&gt; &lt;/select&gt; &lt;/mapper&gt; 测试：123456789101112131415public class DynamicWhereTest &#123; public static void main(String[] args) &#123; //dynamicWhere SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(Student.class.getResourceAsStream(\"/SqlMapConfig.xml\")); SqlSession session = factory.openSession(); UserMapper userMapper = session.getMapper(UserMapper.class); Student student = new Student(); student.setName(\"吴\"); List&lt;Student&gt; list = userMapper.dynamicWhere(student); System.out.println(list); &#125;&#125; 总结：Dao配置文件中可以自己配置重用性高的SQL语句以便提高我们的开发效率","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"MyBatis","slug":"框架/MyBatis","permalink":"http://sivan0222.cn/categories/框架/MyBatis/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://sivan0222.cn/tags/MyBatis/"},{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/tags/框架/"}]},{"title":"入门Mybatis","slug":"入门Mybatis","date":"2017-11-18T08:28:03.000Z","updated":"2017-11-18T12:42:36.992Z","comments":true,"path":"2017/11/18/入门Mybatis/","link":"","permalink":"http://sivan0222.cn/2017/11/18/入门Mybatis/","excerpt":"前言： Mybatis与Hibernate一样，作为轻量级持久层框架，是现在的主流，并且MyBatis与Hibernate不同，MyBatis的灵活性与Hibernate不可同日而语，当我们能够以SQL语句进行轻便操作的时候，你可知道MyBatis带给我们的便利，虽然没有Hibernate封装的好，但是MyBatis扩展性更好些，也更灵活些！有人曾说Hibernate是全自动的，但是MyBatis是半自动的！ 搭建基本环境 使用任何框架的第一步都是搭建框架的基本环境，当我们环境搭建好之后，所谓的半个成品就出来了233333 引入使用数据库的JDBC驱动jar包 引入MyBatis的核心开发包 引入MyBatis的依赖包，也就是log4j等 创建POJO类 引入log4j的配置文件 引入MyBatis的POJO配置文件 引入MyBatis核心配置文件 具体文件缺失，参考 POJO类文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.pojo;import java.io.Serializable;import java.sql.Timestamp;public class Student implements Serializable&#123; private Integer id; private String name; private String sex; private Timestamp birthday; public Student() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Timestamp getBirthday() &#123; return birthday; &#125; public void setBirthday(Timestamp birthday) &#123; this.birthday = birthday; &#125;&#125; POJO的配置文件头约束123&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; 核心配置文件头约束123&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; 基本使用 创建一个输入流，通过流加载总配置文件 通过加载进来的总配置文件创建SqlSessionFactoryBuilder来创建SessionFactory 创建session 编写具体的业务(增删改查，MyBatis中自动开启事务，我们只需要操作和提交事务就可以) 提交事务 关闭session","text":"前言： Mybatis与Hibernate一样，作为轻量级持久层框架，是现在的主流，并且MyBatis与Hibernate不同，MyBatis的灵活性与Hibernate不可同日而语，当我们能够以SQL语句进行轻便操作的时候，你可知道MyBatis带给我们的便利，虽然没有Hibernate封装的好，但是MyBatis扩展性更好些，也更灵活些！有人曾说Hibernate是全自动的，但是MyBatis是半自动的！ 搭建基本环境 使用任何框架的第一步都是搭建框架的基本环境，当我们环境搭建好之后，所谓的半个成品就出来了233333 引入使用数据库的JDBC驱动jar包 引入MyBatis的核心开发包 引入MyBatis的依赖包，也就是log4j等 创建POJO类 引入log4j的配置文件 引入MyBatis的POJO配置文件 引入MyBatis核心配置文件 具体文件缺失，参考 POJO类文件：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package com.pojo;import java.io.Serializable;import java.sql.Timestamp;public class Student implements Serializable&#123; private Integer id; private String name; private String sex; private Timestamp birthday; public Student() &#123; &#125; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public Timestamp getBirthday() &#123; return birthday; &#125; public void setBirthday(Timestamp birthday) &#123; this.birthday = birthday; &#125;&#125; POJO的配置文件头约束123&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; 核心配置文件头约束123&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; 基本使用 创建一个输入流，通过流加载总配置文件 通过加载进来的总配置文件创建SqlSessionFactoryBuilder来创建SessionFactory 创建session 编写具体的业务(增删改查，MyBatis中自动开启事务，我们只需要操作和提交事务就可以) 提交事务 关闭session 查询查询所有的学生1234567891011121314151617181920/* * 查询所有学生 * */public class Demo &#123; public static void main(String[] args) &#123; InputStream in = User.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDao.findAll\"); for (Student student : list) &#123; System.out.println(student.getId() + \"\\t\" + student.getName() + \"\\t\" + student.getSex() + \"\\t\" + student.getBirthday()); &#125; session.close(); &#125;&#125; 对应的POJO映射文件中添加如下代码：123456789101112&lt;!-- 查询所有学生 ，注意：尽管这里查询出来的是一个集合，但是结果类型依然是学生类型， 因为我们要往集合里面添加学生类型 id:sql语句唯一表示 parameterType：指定传入参数类型 resultType：返回结果类型 #&#123;&#125;：占位符，起到占位作用，如果返回的结果是基本类型(string int long ....),则#&#123;&#125;中的变量可以任意写 简单的根据ID查询一个用户 %&#123;&#125;：拼接符，字符串原样拼接，如果传入的参数是基本类型，那么$&#123;&#125;中的变量必须是value --&gt; &lt;select id=\"findAll\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student &lt;/select&gt; 通过id查询学生采用?号赋值123456789101112public class Demo2 &#123; public static void main(String[] args) &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); Student student = (Student) session.selectOne(\"com.dao.StudentDao.findStudentById\",1); System.out.println(student.getId() + \"\\t\" + student.getName() + \"\\t\" + student.getSex() + \"\\t\" + student.getBirthday()); session.close(); &#125;&#125; 对应的POJO映射文件中添加如下代码：1234&lt;!-- 根据编号查询学生,采用sql语句中?号的形式进行赋值的方法进行查取 --&gt; &lt;select id=\"findStudentById\" parameterType=\"java.lang.Integer\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student where id = #&#123;ss&#125; &lt;/select&gt; 采用拼接字符1234567891011121314public class Demo3 &#123; public static void main(String[] args) &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); Student student = (Student) session.selectOne(\"com.dao.StudentDao.findStudentById2\",2); System.out.println(student.getId() + \"\\t\" + student.getName() + \"\\t\" + student.getSex()); session.close(); &#125;&#125; 对应的POJO映射文件中添加如下代码：12345&lt;!-- 根据编号查询学生，采用拼接的方式进行查取， 这里由于传入的是基本类型，并且采用了拼接，所以只可以传入value --&gt; &lt;select id=\"findStudentById2\" parameterType=\"java.lang.Integer\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student where id = $&#123;value&#125; &lt;/select&gt; 根据编号区间进行查询123456789101112131415161718192021222324252627/** * 根据id区间进行查询 * @author SiVan * */public class Demo4 &#123; public static void main(String[] args) &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); Map map = new HashMap(); map.put(\"min\", 1); map.put(\"max\", 2); /*通过将最大值与最小值存到Map集合中，我们可以获取map集合中的最大值，与最小值*/ List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDao.findStudentBetween\", map ); for (Student student : list) &#123; System.out.println(student.getId() + \"\\t\" + student.getName() + \"\\t\" + student.getSex() + \"\\t\" + student.getBirthday()); &#125; session.close(); &#125;&#125; 对应的POJO映射文件中添加如下代码：12345&lt;!-- 根据编号查询学生，采用拼接的方式进行查取， 这里由于传入的是基本类型，并且采用了拼接，所以只可以传入value --&gt; &lt;select id=\"findStudentById2\" parameterType=\"java.lang.Integer\" resultType=\"com.pojo.Student\"&gt; select id,name,sex,birthday from student where id = $&#123;value&#125; &lt;/select&gt; 根据编号大小进行查询123456789101112131415161718192021222324/** * 查询编号小于2号的学生 * @author SiVan * */public class Demo5 &#123; public static void main(String[] args) &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder() .build(in); SqlSession session = factory.openSession(); List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDao.findLess\",2); for (Student student : list) &#123; System.out.println(student.getId() + \"\\t\" + student.getName() + \"\\t \"+ student.getSex()); &#125; session.close(); &#125;&#125; 对应的POJO映射文件中添加如下代码：1234&lt;!-- 查编号小于参数的学生 --&gt; &lt;select id=\"findLess\" resultType=\"com.pojo.Student\" parameterType=\"java.lang.Integer\"&gt; select id,name,sex,birthday from student where id &amp;lt; #&#123;id&#125; &lt;/select&gt; 动态Where子句进行查询123456789101112131415161718192021222324/** * 使用动态where子句，只可以去掉前面的and而不可以去掉后面的and * @author SiVan * */public class Demo6 &#123; public static void main(String[] args) &#123; InputStream in = Student.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); SqlSession session = factory.openSession(); Map map = new HashMap(); map.put(\"id\", 1); map.put(\"name\", \"李飞\"); List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDao.dynamicWhere\", map); for (Student student : list) &#123; System.out.println( student.getId() + \"\\t\" + student.getName() + \"\\t\" + student.getSex() + \"\\t\" + student.getBirthday()); &#125; session.close(); &#125;&#125; 对应的POJO映射文件中添加如下代码：123456789101112131415&lt;!-- 动态SQL之Where子句，也就是where中的部分条件可以有可以没有 --&gt; &lt;select id=\"dynamicWhere\" resultType=\"com.pojo.Student\" parameterType=\"map\"&gt; select id,name,sex,birthday from student &lt;where&gt; &lt;if test=\"id!=null\"&gt; and id = #&#123;id&#125; &lt;/if&gt; &lt;if test=\"name!=null\"&gt; and name = #&#123;name&#125; &lt;/if&gt; &lt;if test=\"sex!=null\"&gt; and sex = #&#123;sex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; MyBatis中的物理分页 MyBatis中的物理分页可以通过RowBounds进行分页，与逻辑分页相比，物理分页效率更加低下，当我们需要编号为23-50的人的数据的时候，其实通过物理分页我们将会查询到50个人的数据，而通过逻辑分页我们只需要查询编号为23-50的人的数据 123456789&lt;!-- 查所有学生 ：逻辑分页 --&gt; &lt;select id=\"getAll\" resultType=\"stu\"&gt; select &lt;include refid=\"fields\"/&gt; from student &lt;/select&gt; &lt;!-- 查所有学生 ：物理分页 --&gt; &lt;select id=\"fenye\" resultType=\"stu\" parameterType=\"map\"&gt; select &lt;include refid=\"fields\"/&gt; from student limit #&#123;x&#125;,#&#123;y&#125; &lt;/select&gt; 123456789101112131415161718192021/*这里是使用了物理分页*/public class fenye &#123; public static void main(String[] args) &#123; InputStream is = fenye.class.getResourceAsStream(\"/SqlMapConfig.xml\"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(is,\"MySQL\"); SqlSession session = factory.openSession(); Map map = new HashMap(); map.put(\"x\", 5); map.put(\"y\", 5); List&lt;Student&gt; list = session.selectList(\"com.dao.StudentDAO.fenye\", map); for (Student s : list) &#123; System.out.println(s.getId()+\"\\t\"+s.getSname()); &#125; session.commit(); session.close(); &#125;&#125; 得到主键 项目中我们经常会使用到获取刚刚插入数据的主键，但是如果我们没有进行特别的配置，MyBatis将不会给我们返回主键，而是返回一个NULL或者0，所以我们需要进行如下配置来获取刚刚插入数据的键值 主键自动增长的时候123456789101112&lt;!-- 新增学生 --&gt; &lt;insert keyProperty=\"id\" useGeneratedKeys=\"true\" id=\"add\" parameterType=\"com.pojo.Student\"&gt; &lt;!-- keyProperty指定主键返回的值存入到哪个属性里面，order值的是获取主键的时机，实在插入语句执行前还是执行后， --&gt; &lt;selectKey keyProperty=\"id\" order=\"AFTER\" resultType=\"java.lang.Integer\"&gt; select LAST_INSERT_ID() &lt;/selectKey&gt; insert into student(sname,sex,sage) values(#&#123;sname&#125;,#&#123;sex&#125;,#&#123;sage&#125;) &lt;/insert&gt;","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"Mybatis","slug":"框架/Mybatis","permalink":"http://sivan0222.cn/categories/框架/Mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"MyBatis","slug":"MyBatis","permalink":"http://sivan0222.cn/tags/MyBatis/"}]},{"title":"Hibernate中的知识点","slug":"Hibernate中的知识点","date":"2017-11-13T08:49:12.000Z","updated":"2017-11-18T12:44:57.036Z","comments":true,"path":"2017/11/13/Hibernate中的知识点/","link":"","permalink":"http://sivan0222.cn/2017/11/13/Hibernate中的知识点/","excerpt":"持久化类(Persistent Object 简称PO) 持久化类就是一个Java类，当这个类与表建立了映射关系(通过XML配置文件) PO = POJO(JavaBean) + XML配置文件 JavaBean规范： 必须有构造方法，如果没有无参的需要自己加上一个无参构造方法 属性必须私有，并且必须提供set以及get方法 PO编写规则 提供一个无参的public修饰符的构造器（因为底层要通过反射创建对象） 提供一个标识属性，映射表的主键字段（唯一标识ID,也就是所说的OId） 所有属性提供public访问控制符的set以及get方法 标识属性应尽量使用基本类型的包装类 持久化类的三种状态 瞬时态 刚创建的对象，没有被持久化到数据库（没有持久化表示OId,OId就是数据库中的主键，也就是唯一区分JavaBean对象的属性），没有被纳入Session管理（没有缓存到Session中） 持久态 存在于数据库中（有唯一标识OId），并且被Session进行管理（缓存到了Session中） 注意事项：持久态的对象有更新数据库的能力，示例如下(正常情况下，我们需要执行session.update()方法进行修改，但是这里是由于session的一级缓存，所以持久态对象在不执行session.update()方法的时候依然具有更新数据库的能力)&gt; 123456789101112131415161718192021222324import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itheima.domain.User;import com.itheima.util.HibernateUtils;public class Demo2 &#123; @Test public void run() &#123; Session session = HibernateUtils.getSession(); Transaction transaction = session.beginTransaction(); User user = session.get(User.class, 18); user.setName(\"wxwddd\"); transaction.commit(); session.close(); &#125;&#125;","text":"持久化类(Persistent Object 简称PO) 持久化类就是一个Java类，当这个类与表建立了映射关系(通过XML配置文件) PO = POJO(JavaBean) + XML配置文件 JavaBean规范： 必须有构造方法，如果没有无参的需要自己加上一个无参构造方法 属性必须私有，并且必须提供set以及get方法 PO编写规则 提供一个无参的public修饰符的构造器（因为底层要通过反射创建对象） 提供一个标识属性，映射表的主键字段（唯一标识ID,也就是所说的OId） 所有属性提供public访问控制符的set以及get方法 标识属性应尽量使用基本类型的包装类 持久化类的三种状态 瞬时态 刚创建的对象，没有被持久化到数据库（没有持久化表示OId,OId就是数据库中的主键，也就是唯一区分JavaBean对象的属性），没有被纳入Session管理（没有缓存到Session中） 持久态 存在于数据库中（有唯一标识OId），并且被Session进行管理（缓存到了Session中） 注意事项：持久态的对象有更新数据库的能力，示例如下(正常情况下，我们需要执行session.update()方法进行修改，但是这里是由于session的一级缓存，所以持久态对象在不执行session.update()方法的时候依然具有更新数据库的能力)&gt; 123456789101112131415161718192021222324import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itheima.domain.User;import com.itheima.util.HibernateUtils;public class Demo2 &#123; @Test public void run() &#123; Session session = HibernateUtils.getSession(); Transaction transaction = session.beginTransaction(); User user = session.get(User.class, 18); user.setName(\"wxwddd\"); transaction.commit(); session.close(); &#125;&#125; 脱管态 存在于数据库中（有唯一标识OId），没有被Session进行管理（没有被Session进行缓存） 下面代码的注意事项： 当我们session执行save方法的时候，其实session已经从连接那里取得了id值，因此当我们执行save方法的时候，user对象将会得到一个session获取到的id，并且缓存到session中，尽管事务没有提交 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.Serializable;import org.hibernate.Hibernate;import org.hibernate.Session;import org.hibernate.Transaction;import org.junit.Test;import com.itheima.domain.User;import com.itheima.util.HibernateUtils;public class Demo1 &#123; @Test public void run() &#123; Session session = HibernateUtils.getSession(); Transaction transaction = session.beginTransaction(); User user = new User(); user.setAge(29); user.setName(\"wxw\"); /* 这里其实已经获取到了id值，因为session已经与数据库连接上了 当session执行save方法的时候，将会把user对象缓存到session中，尽管这时还没有提交事务 */ Serializable s = session.save(user); /*此时user已经成为了持久态，既进入了缓存，又得到了OId*/ System.out.println(s); System.out.println(user.getId()); transaction.commit(); session.close(); /*此时user依然存在，但是session不存在，此时变成了脱管态*/ &#125;&#125;` 三个状态的转换 主键自然主键 当我们创建表结构的时候，有的时候表结构中就有唯一可以确定某个记录的时候，则该列称为自然主键，但是我们在开发中一般不会采用自然主键，因为自然主键可以能随着规则被打破而受到影响 代理主键 既然自然主键不可以用来充当主键，所以在表结构定义的时候，我们一般加上一列用来唯一区分每一条记录，称为代理主键！ 主键的生成策略 increment 适合于short int long 作为主键，不是使用数据库的自动增长机制，一般不建议使用 先找数据库中id的最大值，然后给最大值+1，作为下一条记录的主键，Hibernate执行代码如下 123456789101112Hibernate: select max(id) from UserHibernate: insert into User (name, age, id) values (?, ?, ?) 使用increment在并发访问的情况下，由于多个人并发查询最大值的时候极有可能相同，因此在插入的时候将会产生问题！ identity 适用于short int long作为主键，并且使用该生成策略的时候，要求数据库的主键必须可以自动增长！因为该策略采用了数据库底层的自动增长机制！所以对于oracle这种不可以自动增长的数据库，是不可以采用这种策略的！ 不经常使用，因为如果中途更换数据库，这个策略将不会适用于oracle数据库 sequence 适用于short int long作为主键，底层采用的是序列增长的方式 只支持oracle数据库，也支持DB2数据库，因为oracle自动增长使用的是序列进行自动增长,不支持MySQL数据库 uuid 适用于char varchar 数据类型，使用随机的字符串作为主键 native 本地策略，根据底层数据库的不同，自动选择适用于该种数据库的生成策略 (适用于 short int long 数据类型) 如果本地使用MySQL数据库，将会使用identity，如果使用oracle，将会使用sequence assigned 主键自己进行维护，不使用Hibernate框架进行维护 Hibernate中的缓存Session级别的缓存(一级缓存) Hibernate内部采用了缓存机制，就是说将数据存放到一块单独的内存空间中，以便增强我们操控数据的效率 一级缓存是Session级别的，不可以卸载的，一级缓存的生命周期与session一致 session内部存放了很多集合，用来存放缓存的数据 Session中的快照机制 正是因为Session中快照机制的存在，所以我们的持久化对象才有操纵数据库的能力Session中可以划分为两个区域，一个缓存区域，一个快照区域 当我们执行查询方法的时候，数据将会缓存到Hibernate中的缓存区，和快照区域，但是当我们修改数据的时候，缓存区域的数据进行修改，快照区域的数据不会进行修改，但是当我们使用事务进行提交的时候，事务会自动判别快照区域与内存区域的数据，并对其进行比较，如果两者一致，则不进行修改，如果两者不一致，则进行修改！ SessionFactory级别的缓存(二级缓存) 由于Session生命周期的短暂，所以Hibernate也提供了二级缓存，二级缓存默认没有开启，需要手动配置才可以使用，二级缓存可以在多个session中共享数据，有点类似于我们进程与线程 Hibernate中的事务事务的4个特性： 原子性（atomicity）：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。 隔离性（isolation）：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。 一致性（consistency）：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。 持久性（durability）：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。 并发事务引发的问题（隔离性所引发的问题） 脏读：一个事务读取了另一个事务未提交的数据 不可重复读：一个事务读到了另一个事务更新之后的数据，导致多次查询结果不一致 虚读（幻读）：一个事务读到了另一个事务新增之后的数据，导致多次查询结果不一致 不可重复读与虚读违背了事务的一致性，多个事务读取同一个数据，读取到的数据应该是一致的，也就是事务的一致性！ 避免并发事务引发的问题 通过设置隔离级别来避免事务并发所引起的问题 read-uncommited 读未提交 脏读，不可重复读，虚读都有可能发生 read-commited 读已提交 避免了脏读，但是不可重复读，虚读都有可能发生 repeatable read 重复读 不可重复读，但是虚读有可能发生 Serializable 串行化 以上情况都可以避免，但是效率低，有点类似于线程的同步 MySQL 默认隔离级别为 repeatable read ,可以避免脏读和不可以重复读，而幻读则发生几率很低，忽略不计oracle 默认隔离级别为 read-commited Hibernate核心配置文件配置事务隔离级别 通过设置hibernate.connection.isolation read-uncommited 值为1 read-commited 值为2 repeatable read 值为4 serializable 值为8 丢失更新问题 上面讲的脏读，不可重复读，幻读，都是针对Hibernate中读取数据因数据库不同隔离级别而产生的问题，而丢失更新则是对数据库进行修改所产生的问题 丢失更新问题的产生 丢失更新问题的产生很简单，就是当我们访问数据库的时候，两个人分别获取到了同一条数据，并且内容一致，但是一个人修改了自己读取到的数据的一个字段，另一个人修改了自己读取到的数据的另一个字段，结果可想而知，也就是修改了一个字段，并没有两个字段都进行修改，也就产生了丢失更新的问题 如图所示： 解决丢失更新问题 悲观锁（不常用），采用数据库的锁机制进行操作，对于我们每次操作，数据库都会在sql语句后面加上for update，操作完成之后，再把锁进行释放，效率很低 乐观锁：JavaBean属性添加一个新的属性(version) 数据库首先查询数据，然后进行修改，提交的时候，将会比较版本号是否与查出的版本号一致，如果不一致，将会报错，否则根据版本号与主键值进行修改 悲观锁的使用1session.get(Customer.class, 1, LockMode.UPGRADE); 乐观锁的使用 JavaBean中添加version属性，并且设置相应的set以及get方法 在映射文件中 添加 如下代码","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"Hibernate","slug":"框架/Hibernate","permalink":"http://sivan0222.cn/categories/框架/Hibernate/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://sivan0222.cn/tags/Hibernate/"}]},{"title":"理解Hibernate中的SessionFactory与Session","slug":"理解Hibernate中的SessionFactory","date":"2017-11-13T02:08:27.000Z","updated":"2017-11-18T12:47:36.796Z","comments":true,"path":"2017/11/13/理解Hibernate中的SessionFactory/","link":"","permalink":"http://sivan0222.cn/2017/11/13/理解Hibernate中的SessionFactory/","excerpt":"前言： SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。 – 摘自百度百科 SessionFactory内部构造 sessionFactory 内部分为两个部分 内部机构：用来存放当前数据库的配置文件，以及映射文件和预定义的SQL语句 外部结构：用来存放每个session缓存的内容(session是一级缓存，每次都会将内容同步到二级缓存中，也就是SessionFactory就是二级缓存) SessionFactory的线程安全性 相比Session来说，因为SessionFactory采用了工厂模式，也就是单例，并且使用了synchronized，在每个项目中只有1个，所以SessionFactory是线程安全的，但是Session则是线程不安全的，对于同一个Session，如果执行了多个操作，那么多个线程同时访问同一个Session，将会使得Session中的内容的逻辑异常混乱！ 因此创建的Session实例必须在本地存取空上运行，使之总与当前的线程相关。这里就需要用到ThreadLocal,在很多种Session 管理方案中都用到了它.ThreadLocal 是Java中一种较为特殊的线程绑定机制，通过ThreadLocal存取的数据， 总是与当前线程相关， 也就是说，JVM 为每个运行的线程，绑定了私有的本地实例存取空间，从而为多线程环境常出现的并发访问问题提供了一种隔离机制,ThreadLocal并不是线程本地化的实现,而是线程局部变量。也就是说每个使用该变量的线程都必须为该变量提供一个副本,每个线程改变该变量的值仅仅是改变该副本的值,而不会影响其他线程的该变量的值,ThreadLocal是隔离多个线程的数据共享，不存在多个线程之间共享资源,因此不再需要对线程同步 SessionFactory 的特点 由Configuration通过加载配置文件而创建 SessionFactory对象中保存了当前的数据库配置信息以及所有映射关系和预定义的SQL语句，同时SessionFactory负责维护Hibernate的二级缓存 一个SessionFactory对应一个数据库，并且应用可以通过SessionFactory来获取Session实例 SessionFactory是线程安全的，也就是说可以被多个线程所共享 SessionFactory是重量级的，创建以及销毁格外消耗时间 SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 一个建议的HibernateUtils类（封装了HibernateSessionFactory）12345678910111213141516171819import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtils &#123; private static final Configuration CONFIG; private static final SessionFactory FACTORY; static &#123; CONFIG = new Configuration().configure(); FACTORY = CONFIG.buildSessionFactory(); &#125; public Session getSession() &#123; return FACTORY.openSession(); &#125;&#125; Session常用的方法 save() 将数据持久化到数据库中 update() 对查出来的数据进行修改，根据id值进行修改 get() 根据相应的反射类以及id值进行查询 delete() 虽然传递的是一个对象类型的参数，但是实际上是根据id值进行删除 saveOrUpdate() 如果数据存在，则进行修改，反之将数据持久化到数据库中 clear() 将session中的缓存全部清空 evict(Object object) 将缓存中的指定对象从缓存中清除 flush() 刷出缓存，与Session快照机制相吻合，如果快照区与缓存区域一致，则进行修改；也就是说与数据库的内容进行同步 注意：如果数据库表中的主键采用了自增策略，我们不可以对id值进行设置，如果设置将会报错，因为id值已经交给Hibernate进行管理，无需我们自己进行设值","text":"前言： SessionFactory接口负责初始化Hibernate。它充当数据存储源的代理，并负责创建Session对象。这里用到了工厂模式。需要注意的是SessionFactory并不是轻量级的，因为一般情况下，一个项目通常只需要一个SessionFactory就够，当需要操作多个数据库时，可以为每个数据库指定一个SessionFactory。 – 摘自百度百科 SessionFactory内部构造 sessionFactory 内部分为两个部分 内部机构：用来存放当前数据库的配置文件，以及映射文件和预定义的SQL语句 外部结构：用来存放每个session缓存的内容(session是一级缓存，每次都会将内容同步到二级缓存中，也就是SessionFactory就是二级缓存) SessionFactory的线程安全性 相比Session来说，因为SessionFactory采用了工厂模式，也就是单例，并且使用了synchronized，在每个项目中只有1个，所以SessionFactory是线程安全的，但是Session则是线程不安全的，对于同一个Session，如果执行了多个操作，那么多个线程同时访问同一个Session，将会使得Session中的内容的逻辑异常混乱！ 因此创建的Session实例必须在本地存取空上运行，使之总与当前的线程相关。这里就需要用到ThreadLocal,在很多种Session 管理方案中都用到了它.ThreadLocal 是Java中一种较为特殊的线程绑定机制，通过ThreadLocal存取的数据， 总是与当前线程相关， 也就是说，JVM 为每个运行的线程，绑定了私有的本地实例存取空间，从而为多线程环境常出现的并发访问问题提供了一种隔离机制,ThreadLocal并不是线程本地化的实现,而是线程局部变量。也就是说每个使用该变量的线程都必须为该变量提供一个副本,每个线程改变该变量的值仅仅是改变该副本的值,而不会影响其他线程的该变量的值,ThreadLocal是隔离多个线程的数据共享，不存在多个线程之间共享资源,因此不再需要对线程同步 SessionFactory 的特点 由Configuration通过加载配置文件而创建 SessionFactory对象中保存了当前的数据库配置信息以及所有映射关系和预定义的SQL语句，同时SessionFactory负责维护Hibernate的二级缓存 一个SessionFactory对应一个数据库，并且应用可以通过SessionFactory来获取Session实例 SessionFactory是线程安全的，也就是说可以被多个线程所共享 SessionFactory是重量级的，创建以及销毁格外消耗时间 SessionFactory需要一个较大的缓存，用来存放预定义的SQL语句及实体的映射信息。另外可以配置一个缓存插件，这个插件被称之为Hibernate的二级缓存，被多线程所共享 一个建议的HibernateUtils类（封装了HibernateSessionFactory）12345678910111213141516171819import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;public class HibernateUtils &#123; private static final Configuration CONFIG; private static final SessionFactory FACTORY; static &#123; CONFIG = new Configuration().configure(); FACTORY = CONFIG.buildSessionFactory(); &#125; public Session getSession() &#123; return FACTORY.openSession(); &#125;&#125; Session常用的方法 save() 将数据持久化到数据库中 update() 对查出来的数据进行修改，根据id值进行修改 get() 根据相应的反射类以及id值进行查询 delete() 虽然传递的是一个对象类型的参数，但是实际上是根据id值进行删除 saveOrUpdate() 如果数据存在，则进行修改，反之将数据持久化到数据库中 clear() 将session中的缓存全部清空 evict(Object object) 将缓存中的指定对象从缓存中清除 flush() 刷出缓存，与Session快照机制相吻合，如果快照区与缓存区域一致，则进行修改；也就是说与数据库的内容进行同步 注意：如果数据库表中的主键采用了自增策略，我们不可以对id值进行设置，如果设置将会报错，因为id值已经交给Hibernate进行管理，无需我们自己进行设值 绑定本地Session ThreadLocal 底层是Map集合，键是当前的线程，值（存什么就是什么）","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"Hibernate","slug":"框架/Hibernate","permalink":"http://sivan0222.cn/categories/框架/Hibernate/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://sivan0222.cn/tags/Hibernate/"}]},{"title":"手动搭建Hibernate开发环境","slug":"Hibernate入门","date":"2017-11-12T13:40:57.000Z","updated":"2017-11-18T12:44:35.279Z","comments":true,"path":"2017/11/12/Hibernate入门/","link":"","permalink":"http://sivan0222.cn/2017/11/12/Hibernate入门/","excerpt":"前言 Hibernate框架是一个开源的轻量级框架，与传统的EJB（Sun 公司提供的J2EE开发规范，重量级的一个框架，重量级是因为EJB框架依赖jar包较大，使用很麻烦）完全不同 Hibernate的核心便是ORM（Object Relation Mapping）,也就是我们传统Java中的面向对象的关系应用到了数据库中（并不是使得数据库成为面向对象数据库，而是通过一种XML的配置文件，将我们的操作转变为Hibernate所提及的面向对象操作） Object：特指我们常说的Java中的对象类 Relation：也就是我们常说的表的结构 Mapping：XML配置文件，作为两者（Object与Relation）的中间桥梁 优点 Hibernate对于不同的数据库都可以使用Hibernate中特有的hql语句进行操作，只是配置文件相差而已！ Hibernate封装了我们之前的JDBC的操作，极大程度的避免了重复繁琐的代码 Hibernate性能较前任EJB相比有极大的提高，映射文件也很灵活，支持多种关系映射，例如一对多，多对多等 相比Mybatis来说，Hibernate封装更为彻底，所以相比Mybatis来说，灵活性比较欠缺 手动搭建Hibernate开发环境 将数据库驱动包导入到WEB-INF下面的lib里面，（很多人可能会问Hibernate不是已经可以用面向对象的思维来操作数据库了么，但是为什么还是需要导入数据库jar包呢，原因很简单，因为Hibernate是跨数据库的，它无法识别我们使用的是哪个数据库来进行开发，所以需要我们收到导入相对应数据库的jar包） 导入Hibernate开发所必须的core开发包，点击下载 导入Hibernate所依赖的jar包(1个是log4j规范接口包，1个实现包，另一个Hibernate规范接口包) 手动编写一个JavaBean（JavaBean中的所有属性全部使用包装类，而不是基本类型，例如当我们插入一个顾客，如果年龄忘记赋值，则为0，但是包装类型则为null，因此建议使用包装类）：123456789101112131415161718SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `cst_customer`-- ----------------------------DROP TABLE IF EXISTS `cst_customer`;CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT, `cust_name` varchar(32) NOT NULL, `cust_user_id` bigint(32) DEFAULT NULL, `cust_create_id` bigint(32) DEFAULT NULL, `cust_source` varchar(32) DEFAULT NULL, `cust_industry` varchar(32) DEFAULT NULL, `cust_level` varchar(32) DEFAULT NULL, `cust_linkman` varchar(64) DEFAULT NULL, `cust_phone` varchar(64) DEFAULT NULL, `cust_mobile` varchar(16) DEFAULT NULL, PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8;","text":"前言 Hibernate框架是一个开源的轻量级框架，与传统的EJB（Sun 公司提供的J2EE开发规范，重量级的一个框架，重量级是因为EJB框架依赖jar包较大，使用很麻烦）完全不同 Hibernate的核心便是ORM（Object Relation Mapping）,也就是我们传统Java中的面向对象的关系应用到了数据库中（并不是使得数据库成为面向对象数据库，而是通过一种XML的配置文件，将我们的操作转变为Hibernate所提及的面向对象操作） Object：特指我们常说的Java中的对象类 Relation：也就是我们常说的表的结构 Mapping：XML配置文件，作为两者（Object与Relation）的中间桥梁 优点 Hibernate对于不同的数据库都可以使用Hibernate中特有的hql语句进行操作，只是配置文件相差而已！ Hibernate封装了我们之前的JDBC的操作，极大程度的避免了重复繁琐的代码 Hibernate性能较前任EJB相比有极大的提高，映射文件也很灵活，支持多种关系映射，例如一对多，多对多等 相比Mybatis来说，Hibernate封装更为彻底，所以相比Mybatis来说，灵活性比较欠缺 手动搭建Hibernate开发环境 将数据库驱动包导入到WEB-INF下面的lib里面，（很多人可能会问Hibernate不是已经可以用面向对象的思维来操作数据库了么，但是为什么还是需要导入数据库jar包呢，原因很简单，因为Hibernate是跨数据库的，它无法识别我们使用的是哪个数据库来进行开发，所以需要我们收到导入相对应数据库的jar包） 导入Hibernate开发所必须的core开发包，点击下载 导入Hibernate所依赖的jar包(1个是log4j规范接口包，1个实现包，另一个Hibernate规范接口包) 手动编写一个JavaBean（JavaBean中的所有属性全部使用包装类，而不是基本类型，例如当我们插入一个顾客，如果年龄忘记赋值，则为0，但是包装类型则为null，因此建议使用包装类）：123456789101112131415161718SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for `cst_customer`-- ----------------------------DROP TABLE IF EXISTS `cst_customer`;CREATE TABLE `cst_customer` ( `cust_id` bigint(32) NOT NULL AUTO_INCREMENT, `cust_name` varchar(32) NOT NULL, `cust_user_id` bigint(32) DEFAULT NULL, `cust_create_id` bigint(32) DEFAULT NULL, `cust_source` varchar(32) DEFAULT NULL, `cust_industry` varchar(32) DEFAULT NULL, `cust_level` varchar(32) DEFAULT NULL, `cust_linkman` varchar(64) DEFAULT NULL, `cust_phone` varchar(64) DEFAULT NULL, `cust_mobile` varchar(16) DEFAULT NULL, PRIMARY KEY (`cust_id`)) ENGINE=InnoDB AUTO_INCREMENT=94 DEFAULT CHARSET=utf8; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class Customer &#123; /*使用包装类，因为默认值是null*/ private Long cust_id; private String cust_name; private Long cust_user_id; private Long cust_create_id; private String cust_source; private String cust_industry; private String cust_level; private String cust_linkman; private String cust_phone; private String cust_mobile; public Long getCust_id() &#123; return cust_id; &#125; public void setCust_id(Long cust_id) &#123; this.cust_id = cust_id; &#125; public String getCust_name() &#123; return cust_name; &#125; public void setCust_name(String cust_name) &#123; this.cust_name = cust_name; &#125; public Long getCust_user_id() &#123; return cust_user_id; &#125; public void setCust_user_id(Long cust_user_id) &#123; this.cust_user_id = cust_user_id; &#125; public Long getCust_create_id() &#123; return cust_create_id; &#125; public void setCust_create_id(Long cust_create_id) &#123; this.cust_create_id = cust_create_id; &#125; public String getCust_source() &#123; return cust_source; &#125; public void setCust_source(String cust_source) &#123; this.cust_source = cust_source; &#125; public String getCust_industry() &#123; return cust_industry; &#125; public void setCust_industry(String cust_industry) &#123; this.cust_industry = cust_industry; &#125; public String getCust_level() &#123; return cust_level; &#125; public void setCust_level(String cust_level) &#123; this.cust_level = cust_level; &#125; public String getCust_linkman() &#123; return cust_linkman; &#125; public void setCust_linkman(String cust_linkman) &#123; this.cust_linkman = cust_linkman; &#125; public String getCust_phone() &#123; return cust_phone; &#125; public void setCust_phone(String cust_phone) &#123; this.cust_phone = cust_phone; &#125; public String getCust_mobile() &#123; return cust_mobile; &#125; public void setCust_mobile(String cust_mobile) &#123; this.cust_mobile = cust_mobile; &#125;&#125; 编写JavaBean所对应的XML映射文件（新建一个XML文件，也就是将Java中的类与数据库中的表进行关联），默认文件名字为 类名.hbm.xml，并且文件默认与JavaBean在同一个包下 为新生成的XML映射文件导入约束(hibernate是dtd约束)，打开\\lib\\hibernate-core-5.0.7.Final.jar/org/hibernate/hibernate-mapping-3.0.dtd，选择第10-13行代码，也就是我们要找的约束，代码如下 123&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt; 编写XML配置文件，如果没有出现提示（可能是网络不通），可以配置本地的dtd约束，步骤如下 下载dtd约束文件 打开Eclipse，点击Window-&gt;Preferences-&gt;XML-&gt;XML Catalog-&gt;选中User Specified Entries-&gt;add Location 位置处点击File System(浏览本地下载好的dtd文件，上面有下载链接),key type中选择URI,Key填写 http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd\"&gt;&lt;!-- 编写类与表的对应关系 --&gt; &lt;hibernate-mapping&gt; &lt;class name=\"com.itheima.domain.Customer\" table=\"cst_customer\"&gt;&lt;!-- catalog属性用来配置数据库，但是我们在核心配置文件中已经指定了数据库，所以这里不需要写 --&gt; &lt;id name=\"cust_id\" column=\"cust_id\"&gt; &lt;!-- 配置主键生成的策略，native意思就是使用数据库的生成策略 --&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;!-- 对于name与column相同的属性，可以省略column，此时默认为name --&gt; &lt;property name=\"cust_name\" /&gt; &lt;property name=\"cust_user_id\" /&gt; &lt;property name=\"cust_create_id\" /&gt; &lt;property name=\"cust_source\" /&gt; &lt;property name=\"cust_industry\" /&gt; &lt;property name=\"cust_level\" /&gt; &lt;property name=\"cust_linkman\" /&gt; &lt;property name=\"cust_phone\" /&gt; &lt;property name=\"cust_mobile\" /&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 编写hibernate核心配置文件(不会配置的可以参考)，默认文件名为hibernate.cfg.xml（存放到src目录下）按照如同上面的方法新建XML文件，并且引入约束 配置内容有 5个必须参数 + 可选参数 + 映射配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;!-- 编写hibernate核心配置文件 --&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!-- 5个必须的基本参数 --&gt; &lt;property name=\"hibernate.connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt; &lt;property name=\"hibernate.connection.url\"&gt;jdbc:mysql:///hibernate_day01&lt;/property&gt; &lt;property name=\"hibernate.connection.username\"&gt;root&lt;/property&gt; &lt;property name=\"hibernate.connection.password\"&gt;1018222wxw&lt;/property&gt; &lt;!-- 配置数据库的方言 --&gt; &lt;property name=\"hibernate.dialect\"&gt;org.hibernate.dialect.MySQLDialect&lt;/property&gt; &lt;!-- 可选配置 --&gt; &lt;!-- 控制台打印SQL语句 --&gt; &lt;property name=\"hibernate.show_sql\"&gt;true&lt;/property&gt; &lt;!-- 控制台格式化打印的SQL语句 --&gt; &lt;property name=\"hibernate.format_sql\"&gt;true&lt;/property&gt; &lt;!-- 定义表的自动生成策略 --&gt; &lt;!-- 先删除原来的表(如果存在)，再创建新表 --&gt; &lt;!-- &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;create&lt;/property&gt;--&gt; &lt;!-- 先删除原来的表(如果存在)，再创建新表，插入数据(如果有),用完之后,最后进行删除 --&gt; &lt;!-- &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;create-drop&lt;/property&gt; --&gt; &lt;!-- 1.如果原来的表不存在，可以帮我们创建新表，并且插入数据 2.如果数据库中新增了一列，可以使用update帮助我们在表结构中增加一列（前提是JavaBean已经配置好了新的属性以及set和get方法，并且映射文件也进行了配置） 3.如果原来的数据库已经存在，则直接添加数据 --&gt; &lt;!-- &lt;property name=\"hibernate.hbm2ddl.auto\"&gt;update&lt;/property&gt; --&gt;&lt;!-- 开发阶段使用 --&gt; &lt;!-- validate:用来对表结构以及对应的映射文件进行验证是否一致，如果不一致，则报错 --&gt; &lt;property name=\"hibernate.hbm2dd.auto\"&gt;validate&lt;/property&gt;&lt;!-- 项目上线之后进行使用 --&gt; &lt;!-- 编写映射文件 --&gt; &lt;mapping resource=\"com/itheima/domain/Customer.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 编写最基本的测试代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.Transaction;import org.hibernate.cfg.Configuration;import org.junit.Test;import com.itheima.domain.Customer;/** * 测试保存一个客户 * @author SiVan * */public class Demo1 &#123; @Test public void testSave() &#123; /*1.加载总配置文件:默认加载src目录下的hibernate.cfg.xml文件*/ Configuration configuration = new Configuration().configure(); /* 如果我们在核心文件中没有配置映射文件，那么我们需要手动加载映射文件 configuration.addResource(\"com/itheima/domain/Customer.cfg.xml\"); */ configuration.add(\"\") /*2.创建SessionFactory对象，用来生产Session对象*/ SessionFactory sessionFactory = configuration.buildSessionFactory(); /*3.创建Session对象(持久化对象)*/ Session session = sessionFactory.openSession(); /*4.开启事务*/ Transaction transaction = session.beginTransaction(); /*5.编写保存代码*/ Customer customer = new Customer(); customer.setCust_name(\"测试\"); customer.setCust_level(\"2\"); customer.setCust_phone(\"110\"); /*保存客户*/ session.save(customer); /*6.提交事务*/ transaction.commit(); /*7.释放资源*/ session.close(); sessionFactory.close();/*这里只是测试，因此释放sessionFactory*/ &#125;&#125; 注意事项： hibernate核心配置文件不仅仅可以使用XML文件，也可以使用property文件，但是使用property文件的时候，我们需要注意，映射配置文件需要我们自己手动加载，并且property文件没有约束，即使写错也没有提示 总结：Hibernate虽然核心机制是orm，但是却实现了用面向对象的关系来操作数据库，通过orm技术来实现这一个目的，简化了我们持久化对象的流程，甚至对于那些不会编写SQL语句的Java程序员也是一个巨大的福音！","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"Hibernate","slug":"框架/Hibernate","permalink":"http://sivan0222.cn/categories/框架/Hibernate/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Hibernate","slug":"Hibernate","permalink":"http://sivan0222.cn/tags/Hibernate/"}]},{"title":"一个简单的Spring核心机制和其他方面的认知","slug":"入门Spring","date":"2017-11-06T09:41:03.000Z","updated":"2017-11-06T10:35:49.307Z","comments":true,"path":"2017/11/06/入门Spring/","link":"","permalink":"http://sivan0222.cn/2017/11/06/入门Spring/","excerpt":"前言 最近开始了解Spring，很多人都在告诉我需要使用Spring的时候，我们需要配置很多东西，很大一部分是在XML里面完成，而且还发现Spring可以通过我们配置的XML文件来创建对象，事实上就是这么做的，就好比如我们需要一把刀的时候，只需要去市场就可以买到，而不需要我们自己造了！感觉瞬间现代化了！ 一个简单的Spring核心机制 Spring里面融合的思想有很多，最核心的便是IOC, 也就是 Inverse of control，通过Spring自己带的一个容器，将我们所需要的对象创造出来，而不需要我们手工创造，极大的减少了代码的耦合！ 手工实现一个简单的Spring核心机制 Spring 如何帮助我们创建对象呢？答案便是我们通过配置XML文件，Spring会帮助我们通过配置好的XML文件，进行对象的创建！ 手动配置XML文件 通过我们自己写的一个SpringUtils来对XML文件进行解析，创建对象 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans&gt; &lt;bean id=\"student\" name=\"com.pojo.Student\"&gt;&lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617181920212223import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class SpringUtils &#123; public static Object getElement(String id) throws DocumentException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123; SAXReader reader = new SAXReader(); Document document = reader.read(\"src/beans.xml\"); Element element = (Element) document.selectSingleNode(\"beans/bean[@id='\" + id + \"']\"); String name = element.attributeValue(\"name\"); Class c = Class.forName(name); return c.newInstance(); /*上面的代码等效为如下代码 return Class.forName(((Element)new SAXReader().read(\"src/beans.xml\").selectSingleNode(\"beans/bean[@id='\"+ id + \"']\")).attributeValue(\"name\")).newInstance(); */ &#125;&#125;","text":"前言 最近开始了解Spring，很多人都在告诉我需要使用Spring的时候，我们需要配置很多东西，很大一部分是在XML里面完成，而且还发现Spring可以通过我们配置的XML文件来创建对象，事实上就是这么做的，就好比如我们需要一把刀的时候，只需要去市场就可以买到，而不需要我们自己造了！感觉瞬间现代化了！ 一个简单的Spring核心机制 Spring里面融合的思想有很多，最核心的便是IOC, 也就是 Inverse of control，通过Spring自己带的一个容器，将我们所需要的对象创造出来，而不需要我们手工创造，极大的减少了代码的耦合！ 手工实现一个简单的Spring核心机制 Spring 如何帮助我们创建对象呢？答案便是我们通过配置XML文件，Spring会帮助我们通过配置好的XML文件，进行对象的创建！ 手动配置XML文件 通过我们自己写的一个SpringUtils来对XML文件进行解析，创建对象 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans&gt; &lt;bean id=\"student\" name=\"com.pojo.Student\"&gt;&lt;/bean&gt;&lt;/beans&gt; 1234567891011121314151617181920212223import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;public class SpringUtils &#123; public static Object getElement(String id) throws DocumentException, ClassNotFoundException, InstantiationException, IllegalAccessException &#123; SAXReader reader = new SAXReader(); Document document = reader.read(\"src/beans.xml\"); Element element = (Element) document.selectSingleNode(\"beans/bean[@id='\" + id + \"']\"); String name = element.attributeValue(\"name\"); Class c = Class.forName(name); return c.newInstance(); /*上面的代码等效为如下代码 return Class.forName(((Element)new SAXReader().read(\"src/beans.xml\").selectSingleNode(\"beans/bean[@id='\"+ id + \"']\")).attributeValue(\"name\")).newInstance(); */ &#125;&#125; Spring的配置 当我们通过Spring进行配置文件的时候，有时候需要给具体的某个POJO类配置相应的属性为 数组或者Map集合，可以采用如下配置 属性的配置方式 构造注入 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;bean id=\"student\" class=\"com.pojo.Student\"&gt; &lt;!-- 这里将会自动匹配两个参数的构造方法，如果构造方法不存在将会报错 --&gt; &lt;constructor-arg value=\"小王小马\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"1\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;/beans&gt; set注入 我们不仅仅可以通过构造方法进行注入，而且还可以通过set注入，例子如下 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;bean id=\"Student\" class=\"com.pojo.Student\"&gt; &lt;property name=\"stuid\" value=\"3\"&gt;&lt;/property&gt; &lt;property name=\"stuname\" value=\"李四\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 通过这种XML配置方式，当创建好对象之后，给对象进行赋值的时候将会使用属性对应的set方法，如果没有属性对应的set方法，将会报错 配置数组属性以及Map集合123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;bean id=\"Student\" class=\"com.pojo.Student\"&gt; &lt;property name=\"stuid\" value=\"3\"&gt;&lt;/property&gt; &lt;property name=\"stuname\" value=\"李四\"&gt;&lt;/property&gt; &lt;!-- 这里我们给数组属性进行配置 --&gt; &lt;property name=\"loves\"&gt; &lt;list&gt; &lt;value&gt;看书&lt;/value&gt; &lt;value&gt;写博客&lt;/value&gt; &lt;value&gt;玩游戏&lt;/value&gt; &lt;value&gt;听歌&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 这里我们配置Map集合 --&gt; &lt;property name=\"others\"&gt; &lt;map&gt; &lt;entry key=\"age\" value=\"18\"&gt;&lt;/entry&gt; &lt;entry key=\"height\" value=\"180\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 属性也是一个对象 有的时候我们给属性赋值的时候，属性也是一个对象，这个时候我们就必须配置ref, 通过配置ref指向的类，我们便可以使用该属性，如果属性不是一个对象而是一个固定值，我们需要使用value进行配置1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-2.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\"&gt; &lt;bean id=\"StudentDAO\" class=\"com.dao.StudentDAO\"&gt;&lt;/bean&gt; &lt;bean id=\"StudentService\" class=\"com.service.StudentService\"&gt; &lt;!-- 当我们所配置的对象依赖于另一个对象的时候，可以配置ref属性，给定我们所以依赖对象的链接 如果是一个固定的值，我们可以配置 value 属性 --&gt; &lt;property name=\"studentDAO\" ref=\"StudentDAO\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 总结： Spring配置文件很强大，如果能够熟练应用Spring的配置文件，Spring的运用就会更加娴熟！","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"Spring","slug":"框架/Spring","permalink":"http://sivan0222.cn/categories/框架/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://sivan0222.cn/tags/Spring/"},{"name":"XML","slug":"XML","permalink":"http://sivan0222.cn/tags/XML/"}]},{"title":"部门员工简单级联","slug":"部门员工简单级联","date":"2017-11-06T09:16:03.000Z","updated":"2017-11-06T09:28:31.584Z","comments":true,"path":"2017/11/06/部门员工简单级联/","link":"","permalink":"http://sivan0222.cn/2017/11/06/部门员工简单级联/","excerpt":"部门员工级联也就是，通过选择部门，员工也将会随着部门的改变而改变 通常我们查到有哪些部门，然后在Java中用集合来表示，但是如何用JavaScript来获取这些值变成了我们的一个短板，解决方法就是采用中间格式，例如json，XML文件等 显示部门 这里我们采用了Hibernate来获取部门， 12345678910111213141516171819202122232425262728293031@WebServlet(\"/dep.do\")public class DepServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private DepDAO depDao = new DepDAO(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String method = request.getParameter(\"method\"); if(\"findAll\".equals(method)) &#123; doFindAll(request, response); &#125; &#125; private void doFindAll(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; List&lt;Dep&gt; deps = depDao.findAll(); StringBuffer sb = new StringBuffer(); sb.append(\"[\"); for (Dep dep : deps) &#123; sb.append(\"&#123; 'depId': '\" + dep.getDepId() + \"', 'depName': '\" + dep.getDepName() + \"'&#125;,\"); &#125; sb.deleteCharAt(sb.length() - 1); sb.append(\"]\"); System.out.println(sb); response.getWriter().print(sb.toString()); &#125;&#125; 对应 index.jsp 代码如下12345678910111213141516171819202122var dep = document.getElementById(\"dep\");var emp = document.getElementById(\"emp\");/*---------------- 部门 -----------*/var request = new XMLHttpRequest();request.open(\"get\", \"dep.do?method=findAll\");request.send();request.onreadystatechange = function() &#123; if( request.readyState == 4 &amp;&amp; request.status == 200) &#123; var json = eval(request.responseText); for ( var i = 0; i &lt; json.length; i++ ) &#123; var option = new Option(json[i].depName, json[i].depId); dep.add(option); &#125; doEmp(); &#125;&#125;dep.onchange = function() &#123; doEmp();&#125;","text":"部门员工级联也就是，通过选择部门，员工也将会随着部门的改变而改变 通常我们查到有哪些部门，然后在Java中用集合来表示，但是如何用JavaScript来获取这些值变成了我们的一个短板，解决方法就是采用中间格式，例如json，XML文件等 显示部门 这里我们采用了Hibernate来获取部门， 12345678910111213141516171819202122232425262728293031@WebServlet(\"/dep.do\")public class DepServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private DepDAO depDao = new DepDAO(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String method = request.getParameter(\"method\"); if(\"findAll\".equals(method)) &#123; doFindAll(request, response); &#125; &#125; private void doFindAll(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; List&lt;Dep&gt; deps = depDao.findAll(); StringBuffer sb = new StringBuffer(); sb.append(\"[\"); for (Dep dep : deps) &#123; sb.append(\"&#123; 'depId': '\" + dep.getDepId() + \"', 'depName': '\" + dep.getDepName() + \"'&#125;,\"); &#125; sb.deleteCharAt(sb.length() - 1); sb.append(\"]\"); System.out.println(sb); response.getWriter().print(sb.toString()); &#125;&#125; 对应 index.jsp 代码如下12345678910111213141516171819202122var dep = document.getElementById(\"dep\");var emp = document.getElementById(\"emp\");/*---------------- 部门 -----------*/var request = new XMLHttpRequest();request.open(\"get\", \"dep.do?method=findAll\");request.send();request.onreadystatechange = function() &#123; if( request.readyState == 4 &amp;&amp; request.status == 200) &#123; var json = eval(request.responseText); for ( var i = 0; i &lt; json.length; i++ ) &#123; var option = new Option(json[i].depName, json[i].depId); dep.add(option); &#125; doEmp(); &#125;&#125;dep.onchange = function() &#123; doEmp();&#125; 根据选择的部门得到该部门的员工123456789101112131415161718192021222324252627282930313233@WebServlet(\"/emp.do\")public class EmpServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private EmpDAO empDao = new EmpDAO(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String method = request.getParameter(\"method\"); if(\"findByDepId\".equals(method)) &#123; doFindByDepId(request, response); &#125; &#125; private void doFindByDepId(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String depId = request.getParameter(\"depId\"); System.out.println(depId); List&lt;Emp&gt; emps = empDao.findByProperty(\"dep.depId\", Integer.parseInt(depId)); StringBuffer sb = new StringBuffer(\"[\"); for (Emp emp : emps) &#123; sb.append(\"&#123; 'empId': '\" + emp.getEmpId() + \"', 'empName': '\" + emp.getEmpName() + \"'&#125;,\" ); &#125; sb.deleteCharAt(sb.length() - 1); sb.append(\"]\"); response.getWriter().print(sb.toString()); &#125;&#125; 对应index.jsp代码如下12345678910111213141516171819202122function doEmp() &#123; /*首先移除原来有的子节点*/ while(emp.hasChildNodes()) &#123; emp.removeChild(emp.firstChild); &#125; /*添加原来的子节点*/ var request2 = new XMLHttpRequest(); request2.open(\"get\", \"emp.do?method=findByDepId&amp;depId=\" + dep.value); request2.send(); request2.onreadystatechange = function() &#123; if( request2.readyState == 4 &amp;&amp; request2.status == 200 ) &#123; /*这里将获得的文本按照严格意义转换为js中的数组*/ var empJson = eval(request2.responseText); for ( var i = 0; i &lt; empJson.length; i++ )&#123; var option = new Option(empJson[i].empName, empJson[i].empId); emp.add(option); &#125; &#125; &#125; &#125; 注意事项 对于每次选择，都需要员工清空，否则，将会累加，员工只会越来越多 每次必须将获得的请求的响应文本格式化(eval)为js对象，否则将不可以调用js对象的属性 var empJson = eval(request2.responseText); 总代码如下： index.jsp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;/head&gt; &lt;body&gt; 部门：&lt;select id=\"dep\"&gt;&lt;/select&gt; 员工：&lt;select id=\"emp\"&gt;&lt;/select&gt; &lt;/body&gt; &lt;script&gt; var dep = document.getElementById(\"dep\"); var emp = document.getElementById(\"emp\"); /*---------------- 部门 -----------*/ var request = new XMLHttpRequest(); request.open(\"get\", \"dep.do?method=findAll\"); request.send(); request.onreadystatechange = function() &#123; if( request.readyState == 4 &amp;&amp; request.status == 200) &#123; var json = eval(request.responseText); for ( var i = 0; i &lt; json.length; i++ ) &#123; var option = new Option(json[i].depName, json[i].depId); dep.add(option); &#125; doEmp(); &#125; &#125; dep.onchange = function() &#123; doEmp(); &#125; /*----------------- 员工 -----------*/ function doEmp() &#123; /*首先移除原来有的子节点*/ while(emp.hasChildNodes()) &#123; emp.removeChild(emp.firstChild); &#125; /*添加原来的子节点*/ var request2 = new XMLHttpRequest(); request2.open(\"get\", \"emp.do?method=findByDepId&amp;depId=\" + dep.value); request2.send(); request2.onreadystatechange = function() &#123; if( request2.readyState == 4 &amp;&amp; request2.status == 200 ) &#123; var empJson = eval(request2.responseText); for ( var i = 0; i &lt; empJson.length; i++ )&#123; var option = new Option(empJson[i].empName, empJson[i].empId); emp.add(option); &#125; &#125; &#125; &#125; &lt;/script&gt;&lt;/html&gt; 总结： 对于部门与员工级联，我们首先需要获得部门，然后根据我们当前所选择的部门获得员工，这里需要注意的是，我们采用了ajax进行通信，所以当我们获得员工的时候，需要将获得的员工转换为一个中间格式的文本进行传输，这里我们使用了json!","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"jsp","slug":"Java/jsp","permalink":"http://sivan0222.cn/categories/Java/jsp/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"json","slug":"json","permalink":"http://sivan0222.cn/tags/json/"},{"name":"Ajax","slug":"Ajax","permalink":"http://sivan0222.cn/tags/Ajax/"}]},{"title":"XML创建与解析","slug":"XML创建与解析","date":"2017-11-06T00:49:50.000Z","updated":"2017-11-06T09:28:19.883Z","comments":true,"path":"2017/11/06/XML创建与解析/","link":"","permalink":"http://sivan0222.cn/2017/11/06/XML创建与解析/","excerpt":"前言： 这里记录自己之前使用dom进行写XML，使用SAX 进行读取XML 两者异同点 dom解析是基于文档的，如果解析一个XML文件，将会把文件的所有内容加载到内存中，方便反复查询，虽然效率高，但是占内存，尤其是XML文件很大的时候 sax(simple API for xml)解析xml的另一种方法，是一个基于事件流的解析，当我们使用XML进行解析的时候，用到哪里，就读到哪里，如果没有保存，数据将会丢失 创建一个简单的XML文档 生成一个空白的XML文档 添加根节点和属性 根节点下面添加子节点和属性 对在JVM中生成的XML文档保存到本机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import org.dom4j.io.XMLWriter;/** * 创建XML文档，并且保存到d:/classes.xml * @author SiVan * */public class CreateDocument &#123; public static void main(String[] args) throws IOException &#123; /*创建一个XML文档*/ Document document = DocumentHelper.createDocument(); /*创建根节点*/ Element element = document.addElement(\"classes\"); element.addAttribute(\"id\", \"1\"); element.addAttribute(\"name\", \"root\"); element.setText(\"总班级\"); /*创建子节点*/ Element element2 = element.addElement(\"class\"); element2.addAttribute(\"name\", \"班级1\"); element2.addAttribute(\"id\", \"01\"); element2.setText(\"第1个班级\"); Element element3 = element.addElement(\"class\"); element3.addAttribute(\"name\", \"班级2\"); element3.addAttribute(\"id\", \"02\"); element3.setText(\"第2个班级\"); /*将创建的XML文档保存到本机*/ XMLWriter writer = new XMLWriter(new FileOutputStream(new File(\"d:/classes.xml\"))); writer.write(document); &#125;&#125;","text":"前言： 这里记录自己之前使用dom进行写XML，使用SAX 进行读取XML 两者异同点 dom解析是基于文档的，如果解析一个XML文件，将会把文件的所有内容加载到内存中，方便反复查询，虽然效率高，但是占内存，尤其是XML文件很大的时候 sax(simple API for xml)解析xml的另一种方法，是一个基于事件流的解析，当我们使用XML进行解析的时候，用到哪里，就读到哪里，如果没有保存，数据将会丢失 创建一个简单的XML文档 生成一个空白的XML文档 添加根节点和属性 根节点下面添加子节点和属性 对在JVM中生成的XML文档保存到本机 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import org.dom4j.Document;import org.dom4j.DocumentHelper;import org.dom4j.Element;import org.dom4j.io.XMLWriter;/** * 创建XML文档，并且保存到d:/classes.xml * @author SiVan * */public class CreateDocument &#123; public static void main(String[] args) throws IOException &#123; /*创建一个XML文档*/ Document document = DocumentHelper.createDocument(); /*创建根节点*/ Element element = document.addElement(\"classes\"); element.addAttribute(\"id\", \"1\"); element.addAttribute(\"name\", \"root\"); element.setText(\"总班级\"); /*创建子节点*/ Element element2 = element.addElement(\"class\"); element2.addAttribute(\"name\", \"班级1\"); element2.addAttribute(\"id\", \"01\"); element2.setText(\"第1个班级\"); Element element3 = element.addElement(\"class\"); element3.addAttribute(\"name\", \"班级2\"); element3.addAttribute(\"id\", \"02\"); element3.setText(\"第2个班级\"); /*将创建的XML文档保存到本机*/ XMLWriter writer = new XMLWriter(new FileOutputStream(new File(\"d:/classes.xml\"))); writer.write(document); &#125;&#125; 读取XML文档中的单个节点 通常我们需要对XML文档中的某个节点进行读取，可以采用如下方法 找到XML文档，读取到JVM中 找到我们要找的那个节点 12345&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;books&gt; &lt;book id=\"11\" price=\"456789\"&gt;天龙八部&lt;/book&gt; &lt;book id=\"2\" price=\"666\"&gt;武林秘籍&lt;/book&gt;&lt;/books&gt; 1234567891011121314151617181920212223242526272829package com.prac;import java.io.File;import java.net.MalformedURLException;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;/** * 读取Document文档，并且获取单个节点的值 * @author SiVan * */public class Test2 &#123; public static void main(String[] args) throws MalformedURLException, DocumentException &#123; SAXReader reader = new SAXReader(); Document document = reader.read(new File(\"d:/books.xml\")); Element element = (Element) document.selectSingleNode(\"books/book[@id=1]\"); System.out.println(element.getName() + \"\\t\" + element.getText() + \"\\t\" + element.attributeValue(\"id\") + \"\\t\" + element.attributeValue(\"price\")); &#125;&#125; 获取XML的所有节点 有些时候，我们需要获取XML的所有节点，从而形成一个DOM树 XML文档如下 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;contactList&gt; &lt;contact id=\"001\" class=\"style\"&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;phone&gt;134222223333&lt;/phone&gt; &lt;email&gt;zhangsan@qq.com&lt;/email&gt; &lt;qq&gt;432221111&lt;/qq&gt; &lt;/contact&gt; &lt;contact id=\"002\"&gt; &lt;name&gt;李四&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;phone&gt;134222225555&lt;/phone&gt; &lt;email&gt;lisi@qq.com&lt;/email&gt; &lt;qq&gt;432222222&lt;/qq&gt; &lt;/contact&gt; &lt;contactTwo&gt; &lt;name&gt;王五&lt;/name&gt; &lt;age&gt;32&lt;/age&gt; &lt;phone&gt;465431341&lt;/phone&gt; &lt;emali&gt;af@qq.com&lt;/emali&gt; &lt;qq&gt;46164694&lt;/qq&gt; &lt;/contactTwo&gt; &lt;test&gt;测试&lt;/test&gt; &lt;test&gt;其他用途&lt;/test&gt;&lt;/contactList&gt; 1234567891011121314151617181920public class QuerySingleNode &#123; public static void main(String[] args) throws MalformedURLException, DocumentException &#123; /*采用sax解析*/ SAXReader reader = new SAXReader(); Document document = reader.read(new File(\"src/contact.xml\")); List list = document.selectNodes(\"contactList/contact\"); for (Object object : list) &#123; Element element = (Element) object; System.out.println(element.attributeValue(\"id\") + \"\\t\" + element.attributeValue(\"class\") + \"\\t\" + element.elementText(\"name\") + \"\\t\" + element.elementText(\"age\") + \"\\t\" + element.elementText(\"email\") + \"\\t\" + element.elementText(\"phone\") + \"\\t\" + element.elementText(\"qq\")); &#125; &#125;&#125; 修改XML文档中某个节点的属性 如果要修改XML文档中某个节点的属性，我们需要通过解析XML文档找到这个节点，然后进行修改！ 1234567891011121314151617181920212223242526272829303132333435363738394041package com.prac;import java.io.File;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.MalformedURLException;import org.dom4j.Document;import org.dom4j.DocumentException;import org.dom4j.Element;import org.dom4j.io.SAXReader;import org.dom4j.io.XMLWriter;/** * 首先读取Document内容，然后修改Document内容中的某一处值 * @author SiVan * */public class Test4 &#123; public static void main(String[] args) throws DocumentException, IOException &#123; SAXReader reader = new SAXReader(); Document document = reader.read(new File(\"d:/books.xml\")); Element element = (Element) document.selectSingleNode(\"books/book[@id=1]\"); if( element != null ) &#123; element.attribute(\"id\").setValue(\"11\"); element.attribute(\"price\").setValue(\"456789\"); &#125; XMLWriter writer = new XMLWriter(new FileOutputStream(new File(\"d:/books.xml\"))); writer.write(document); writer.close(); &#125;&#125; 总结： XML文档解析方法很多，但是常用的便是dom解析和sax解析，dom解析是读取一次，全部载入内存中，虽然效率高，但是很占内存；sax解析则是基于事件流的(用到哪里，读取哪里)，因此我们修改了节点的内容或者属性的时候，如果我们没有再次写到本机中，并不会真正修改本机上的xml文件！","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"XML","slug":"Java/XML","permalink":"http://sivan0222.cn/categories/Java/XML/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"XML","slug":"XML","permalink":"http://sivan0222.cn/tags/XML/"}]},{"title":"几种MD5使用的方法","slug":"几种MD5使用的方法","date":"2017-10-30T03:38:51.000Z","updated":"2017-10-30T03:46:40.894Z","comments":true,"path":"2017/10/30/几种MD5使用的方法/","link":"","permalink":"http://sivan0222.cn/2017/10/30/几种MD5使用的方法/","excerpt":"前言：由于MD5加密技术是一项单向的加密技术，不可以进行逆转，所以即使当我们知道加密后的数据也无法还原。安全性较高。 几种MD5的使用方法方法一：（按照书上实例的方法） MD5 加密以后生成byte数组，但是由于我们通常在数据库中保存以字符串的形式保存数据，所以我们经常会将转换以后的byte数组转换为字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @date 2017年10月30日 上午11:13:12 * @author SiVan */package com.md5;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * @author SiVan * @time 2017年10月30日 上午11:13:12 * @TODO TODO md5加密 */public class Test &#123; public static byte[] encryptMD5(byte[] data) throws NoSuchAlgorithmException &#123; /*指定加密算法*/ MessageDigest digest = MessageDigest.getInstance(\"MD5\"); /*进行加密*/ digest.update(data); /*返回加密后的byte数组*/ return digest.digest(); &#125; /** * * @param data * @return 将加密后的byte 转换为 字符串 * @throws NoSuchAlgorithmException */ public static String encryptMD5toString(byte[] data) throws NoSuchAlgorithmException &#123; String str = \"\"; String str16; for ( int i = 0; i &lt; data.length; i++ )&#123; str16 = Integer.toHexString(0xFF &amp; data[i]); /*如果长度为1，前位补0*/ if (str16.length() == 1) &#123; str = str + \"0\" + str16; &#125; else &#123; str = str + str16; &#125; &#125; return str; &#125; public static void main(String[] args) throws NoSuchAlgorithmException &#123; String st = \"admin\"; System.out.println(encryptMD5toString(encryptMD5(st.getBytes()))); System.out.println(encryptMD5(st.getBytes())); &#125;&#125;","text":"前言：由于MD5加密技术是一项单向的加密技术，不可以进行逆转，所以即使当我们知道加密后的数据也无法还原。安全性较高。 几种MD5的使用方法方法一：（按照书上实例的方法） MD5 加密以后生成byte数组，但是由于我们通常在数据库中保存以字符串的形式保存数据，所以我们经常会将转换以后的byte数组转换为字符串 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * @date 2017年10月30日 上午11:13:12 * @author SiVan */package com.md5;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * @author SiVan * @time 2017年10月30日 上午11:13:12 * @TODO TODO md5加密 */public class Test &#123; public static byte[] encryptMD5(byte[] data) throws NoSuchAlgorithmException &#123; /*指定加密算法*/ MessageDigest digest = MessageDigest.getInstance(\"MD5\"); /*进行加密*/ digest.update(data); /*返回加密后的byte数组*/ return digest.digest(); &#125; /** * * @param data * @return 将加密后的byte 转换为 字符串 * @throws NoSuchAlgorithmException */ public static String encryptMD5toString(byte[] data) throws NoSuchAlgorithmException &#123; String str = \"\"; String str16; for ( int i = 0; i &lt; data.length; i++ )&#123; str16 = Integer.toHexString(0xFF &amp; data[i]); /*如果长度为1，前位补0*/ if (str16.length() == 1) &#123; str = str + \"0\" + str16; &#125; else &#123; str = str + str16; &#125; &#125; return str; &#125; public static void main(String[] args) throws NoSuchAlgorithmException &#123; String st = \"admin\"; System.out.println(encryptMD5toString(encryptMD5(st.getBytes()))); System.out.println(encryptMD5(st.getBytes())); &#125;&#125; 方法二：（之前拷贝的一个MD5工具类）1234567891011121314151617181920212223242526272829303132333435363738394041package com.md5;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;/** * MD5工具类，需要直接使用即可 * @author SiVan * @time 2017年10月30日 上午11:37:32 * @TODO TODO */public class MD5Util &#123; private static String byteHEX(byte ib) &#123; char[] Digit = &#123; '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' &#125;; char[] ob = new char[2]; ob[0] = Digit[(ib &gt;&gt;&gt; 4) &amp; 0X0F]; ob[1] = Digit[ib &amp; 0X0F]; String s = new String(ob); return s; &#125; public static String getMD5(String source) &#123; MessageDigest messageDigest = null; try &#123; messageDigest = MessageDigest.getInstance(\"MD5\"); &#125; catch (NoSuchAlgorithmException e) &#123; e.printStackTrace(); &#125; messageDigest.update(source.getBytes()); byte[] b = messageDigest.digest(); StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; b.length; i++) &#123; sb.append(byteHEX(b[i])); &#125; /* sb.setCharAt(sb.length()-1, (char)(sb.charAt(sb.length()-1)+1));*/ return sb.toString(); &#125;&#125; 方法三：（摘自百度百科上面的算法）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170/** * @date 2017年10月30日 上午11:33:38 * @author SiVan */package com.md5;/** * @author SiVan * @time 2017年10月30日 上午11:33:38 * @TODO TODO */public class MD5&#123; /* *四个链接变量 */ private final int A=0x67452301; private final int B=0xefcdab89; private final int C=0x98badcfe; private final int D=0x10325476; /* *ABCD的临时变量 */ private int Atemp,Btemp,Ctemp,Dtemp; /* *常量ti *公式:floor(abs(sin(i+1))×(2pow32) */ private final int K[]=&#123; 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee, 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,0x698098d8, 0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193, 0xa679438e,0x49b40821,0xf61e2562,0xc040b340,0x265e5a51, 0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8, 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905, 0xfcefa3f8,0x676f02d9,0x8d2a4c8a,0xfffa3942,0x8771f681, 0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60, 0xbebfbc70,0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05, 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,0xf4292244, 0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92, 0xffeff47d,0x85845dd1,0x6fa87e4f,0xfe2ce6e0,0xa3014314, 0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391&#125;; /* *向左位移数,计算方法未知 */ private final int s[]=&#123;7,12,17,22,7,12,17,22,7,12,17,22,7, 12,17,22,5,9,14,20,5,9,14,20,5,9,14,20,5,9,14,20, 4,11,16,23,4,11,16,23,4,11,16,23,4,11,16,23,6,10, 15,21,6,10,15,21,6,10,15,21,6,10,15,21&#125;; /* *初始化函数 */ private void init()&#123; Atemp=A; Btemp=B; Ctemp=C; Dtemp=D; &#125; /* *移动一定位数 */ private int shift(int a,int s)&#123; return(a&lt;&lt;s)|(a&gt;&gt;&gt;(32-s)); /*右移的时候，高位一定要补零，而不是补充符号位*/ &#125; /* *主循环 */ private void MainLoop(int M[])&#123; int F,g; int a=Atemp; int b=Btemp; int c=Ctemp; int d=Dtemp; for(int i = 0; i &lt; 64; i ++)&#123; if(i&lt;16)&#123; F=(b&amp;c)|((~b)&amp;d); g=i; &#125;else if(i&lt;32)&#123; F=(d&amp;b)|((~d)&amp;c); g=(5*i+1)%16; &#125;else if(i&lt;48)&#123; F=b^c^d; g=(3*i+5)%16; &#125;else&#123; F=c^(b|(~d)); g=(7*i)%16; &#125; int tmp=d; d=c; c=b; b=b+shift(a+F+K[i]+M[g],s[i]); a=tmp; &#125; Atemp=a+Atemp; Btemp=b+Btemp; Ctemp=c+Ctemp; Dtemp=d+Dtemp; &#125; /* *填充函数 *处理后应满足bits≡448(mod512),字节就是bytes≡56（mode64) *填充方式为先加一个0,其它位补零 *最后加上64位的原来长度 */ private int[] add(String str)&#123; int num=((str.length()+8)/64)+1;/*以512位，64个字节为一组*/ int strByte[]=new int[num*16];/*64/4=16，所以有16个整数*/ for(int i=0;i&lt;num*16;i++)&#123;/*全部初始化0*/ strByte[i]=0; &#125; int i; for(i=0;i&lt;str.length();i++)&#123; strByte[i&gt;&gt;2]|=str.charAt(i)&lt;&lt;((i%4)*8);/*一个整数存储四个字节，小端序*/ &#125; strByte[i&gt;&gt;2]|=0x80&lt;&lt;((i%4)*8);/*尾部添加1*/ /* *添加原长度，长度指位的长度，所以要乘8，然后是小端序，所以放在倒数第二个,这里长度只用了32位 */ strByte[num*16-2]=str.length()*8; return strByte; &#125; /* *调用函数 */ public String getMD5(String source)&#123; init(); int strByte[]=add(source); for(int i=0;i&lt;strByte.length/16;i++)&#123; int num[]=new int[16]; for(int j=0;j&lt;16;j++)&#123; num[j]=strByte[i*16+j]; &#125; MainLoop(num); &#125; return changeHex(Atemp)+changeHex(Btemp)+changeHex(Ctemp)+changeHex(Dtemp); &#125; /* *整数变成16进制字符串 */ private String changeHex(int a)&#123; String str=\"\"; for(int i=0;i&lt;4;i++)&#123; str+=String.format(\"%2s\", Integer.toHexString(((a&gt;&gt;i*8)%(1&lt;&lt;8))&amp;0xff)).replace(' ', '0'); &#125; return str; &#125; /* *单例 */ private static MD5 instance; public static MD5 getInstance()&#123; if(instance==null)&#123; instance=new MD5(); &#125; return instance; &#125; private MD5()&#123;&#125;; public static void main(String[] args)&#123; String str=MD5.getInstance().getMD5(\"admin\"); System.out.println(str); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"Security","slug":"Java/Security","permalink":"http://sivan0222.cn/categories/Java/Security/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"MD5","slug":"MD5","permalink":"http://sivan0222.cn/tags/MD5/"}]},{"title":"使用json级联改变部门员工","slug":"使用json级联改变部门员工","date":"2017-10-30T01:55:07.000Z","updated":"2017-10-30T02:06:36.960Z","comments":true,"path":"2017/10/30/使用json级联改变部门员工/","link":"","permalink":"http://sivan0222.cn/2017/10/30/使用json级联改变部门员工/","excerpt":"这里使用Hibernate + json + Ajax + 级联改变部门员工 基本的页面编写：1234567891011121314151617&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; 部门：&lt;select id=\"dep\"&gt;&lt;/select&gt; 员工：&lt;select id=\"emp\"&gt;&lt;/select&gt; &lt;/body&gt;&lt;/html&gt; servlet的生成 DepServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.IOException;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.dao.DepDAO;import com.pojo.Dep;@WebServlet(\"/dep.do\")public class DepServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private DepDAO depDao = new DepDAO(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String method = request.getParameter(\"method\"); if ( \"dep\".equals(method) ) &#123; doDep(request, response); &#125; &#125; /** * @throws IOException * */ private void doDep(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; List&lt;Dep&gt; list = depDao.findAll(); /*将list转换为json格式的数据*/ StringBuffer sb = new StringBuffer(); sb.append(\"[\"); for (Dep dep : list) &#123; sb.append(\"&#123; 'depId': '\" + dep.getDepId() + \"', 'depName': '\" + dep.getDepName() + \"' &#125;,\" ); &#125; sb.deleteCharAt(sb.length() - 1); sb.append(\"]\"); response.getWriter().print(sb.toString()); &#125;&#125;","text":"这里使用Hibernate + json + Ajax + 级联改变部门员工 基本的页面编写：1234567891011121314151617&lt;%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%&gt;&lt;%String path = request.getContextPath();String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";%&gt;&lt;!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;body&gt; 部门：&lt;select id=\"dep\"&gt;&lt;/select&gt; 员工：&lt;select id=\"emp\"&gt;&lt;/select&gt; &lt;/body&gt;&lt;/html&gt; servlet的生成 DepServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.IOException;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.dao.DepDAO;import com.pojo.Dep;@WebServlet(\"/dep.do\")public class DepServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private DepDAO depDao = new DepDAO(); protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String method = request.getParameter(\"method\"); if ( \"dep\".equals(method) ) &#123; doDep(request, response); &#125; &#125; /** * @throws IOException * */ private void doDep(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; List&lt;Dep&gt; list = depDao.findAll(); /*将list转换为json格式的数据*/ StringBuffer sb = new StringBuffer(); sb.append(\"[\"); for (Dep dep : list) &#123; sb.append(\"&#123; 'depId': '\" + dep.getDepId() + \"', 'depName': '\" + dep.getDepName() + \"' &#125;,\" ); &#125; sb.deleteCharAt(sb.length() - 1); sb.append(\"]\"); response.getWriter().print(sb.toString()); &#125;&#125; EmpServlet1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.IOException;import java.util.List;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import com.dao.EmpDAO;import com.pojo.Emp;/** * Servlet implementation class EmpServlet */@WebServlet(\"/emp.do\")public class EmpServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; private EmpDAO empDao = new EmpDAO(); /* (non-Javadoc) * @see javax.servlet.http.HttpServlet#service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) */ @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.setContentType(\"text/html;charset=utf-8\"); String method = request.getParameter(\"method\"); if(\"findAll\".equals(method)) &#123; doFind(request, response); &#125; &#125; /** * @throws IOException * */ private void doFind(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String depId = request.getParameter(\"depId\"); List&lt;Emp&gt; list = empDao.findByProperty(\"dep.depId\", Integer.parseInt(depId)); System.out.println(list.isEmpty()); StringBuffer sb = new StringBuffer(); sb.append(\"[\"); for (Emp emp : list) &#123; sb.append(\"&#123; 'empId': '\" + emp.getEmpId() + \"', 'empName': '\" + emp.getEmpName() + \"'&#125;,\"); &#125; sb.deleteCharAt(sb.length()-1); sb.append(\"]\"); response.getWriter().print(sb.toString()); &#125;&#125; json的使用 当我们使用java的时候，经常要给页面返回东西，但是我们又不可以直接返回Java中的数据类型，所以只能通过中间格式进行转换，中间格式在这里也就是Java和JavaScript都可以解析的格式 格式 使用json简单的保存一个数据 一个简单的json { ‘姓名’: ‘李四’, ‘年龄’: ‘25’}; 使用json保存数据组 [ { ‘姓名’: ‘王五’, ‘年龄’: ‘18’ }, { ‘姓名’: ‘李四’, ‘年龄’: ‘19’ }, { ‘姓名’: ‘赵六’, ‘年龄’: ‘58’ }] Ajax的编写12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;script&gt; var request = new XMLHttpRequest(); request.open(\"GET\", \"dep.do?method=dep\"); request.send(); /*首先操作部门*/ var dep = document.getElementById(\"dep\"); request.onreadystatechange = function () &#123; if ( request.readyState == 4 &amp;&amp; request.status == 200) &#123; var list = request.responseText; var s = eval(list); for ( var i = 0; i &lt; s.length; i++ ) &#123; var option = new Option(s[i].depName, s[i].depId); dep.add(option); &#125; emp(); &#125; &#125; /*操作员工，第一次默认是哪个，然后改变事件员工也要随着改变*/ function emp() &#123; var emp = document.getElementById(\"emp\"); /*实现每次改变父节点的时候删除原有的子节点*/ /*方法一：*/ while(emp.hasChildNodes()) &#123; emp.removeChild(emp.firstChild); &#125; /*方法二：*/ /*emp.innerHTML = \"\";*/ var request2 = new XMLHttpRequest(); request2.open(\"get\", \"emp.do?method=findAll&amp;depId=\" + dep.value); request2.send(); request2.onreadystatechange = function() &#123; if( request2.readyState == 4 &amp;&amp; request2.status == 200 ) &#123; var str = eval(request2.responseText); for ( var i = 0; i &lt; str.length; i++ ) &#123; var option = new Option(str[i].empName, str[i].empId); emp.add(option); &#125; &#125; &#125; &#125; dep.onchange = function() &#123; emp(); &#125; &lt;/script&gt;","categories":[{"name":"json","slug":"json","permalink":"http://sivan0222.cn/categories/json/"},{"name":"级联","slug":"json/级联","permalink":"http://sivan0222.cn/categories/json/级联/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://sivan0222.cn/tags/Hibernate/"},{"name":"json","slug":"json","permalink":"http://sivan0222.cn/tags/json/"}]},{"title":"解决MySql 8小时自动关闭的问题","slug":"解决MySql-8小时自动关闭的问题","date":"2017-10-28T02:08:04.000Z","updated":"2017-10-30T02:43:34.288Z","comments":true,"path":"2017/10/28/解决MySql-8小时自动关闭的问题/","link":"","permalink":"http://sivan0222.cn/2017/10/28/解决MySql-8小时自动关闭的问题/","excerpt":"前言： 记得自己之前在服务器上部署了一个很low的假期签到系统，每次叫大家签到都是晚上，很大程度上讲，时间已经过了将近16个小时，每次第二天叫大家签到的时候，很多人，都发了同一个问题给我，服务器报了连接异常，后来听到身边的大牛才知道，原来MySql如果配置不当，连接空闲超过8小时，MySql将会关闭该连接，但是我们服务器认为连接还是存在的，因此还会访问，所以就会出现异常情况 也有一部分原因自己是知道的，因为自己采用了c3p0数据源，所以才会出现这个情况，而dbcp则不会出现如此情况！ 查询当前数据库连接超时时间 mysql 命令行中 键入如下命令 SHOW GLOBAL VARIABLES LIKE ‘wait_timeout’; 结果如下 超时时间为28800秒，换算下来也就是8小时 解决方法方法一： 这个也是自己之前的方法：也就是采用一个简单的定时器，每隔7小时定时查一下数据库，不让连接自动关闭， 方法二： 每次当我们连接到数据库中的时候，url可改为：jdbc:mysql://localhost:3306/test?user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false","text":"前言： 记得自己之前在服务器上部署了一个很low的假期签到系统，每次叫大家签到都是晚上，很大程度上讲，时间已经过了将近16个小时，每次第二天叫大家签到的时候，很多人，都发了同一个问题给我，服务器报了连接异常，后来听到身边的大牛才知道，原来MySql如果配置不当，连接空闲超过8小时，MySql将会关闭该连接，但是我们服务器认为连接还是存在的，因此还会访问，所以就会出现异常情况 也有一部分原因自己是知道的，因为自己采用了c3p0数据源，所以才会出现这个情况，而dbcp则不会出现如此情况！ 查询当前数据库连接超时时间 mysql 命令行中 键入如下命令 SHOW GLOBAL VARIABLES LIKE ‘wait_timeout’; 结果如下 超时时间为28800秒，换算下来也就是8小时 解决方法方法一： 这个也是自己之前的方法：也就是采用一个简单的定时器，每隔7小时定时查一下数据库，不让连接自动关闭， 方法二： 每次当我们连接到数据库中的时候，url可改为：jdbc:mysql://localhost:3306/test?user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=true&amp;failOverReadOnly=false 通过设置autoReconnect 和 failOverReadOnly 来进行连接异常时的重新设置 具体参数如下图 参数名称参数说明缺省值最低版本要求user数据库用户名（用于连接数据库）&nbsp;所有版本password用户密码（用于连接数据库）&nbsp;所有版本useUnicode是否使用Unicode字符集，如果参数characterEncoding设置为gb2312或gbk，本参数值必须设置为truefalse1.1gcharacterEncoding当useUnicode设置为true时，指定字符编码。比如可设置为gb2312或gbkfalse1.1gautoReconnect当数据库连接异常中断时，是否自动重新连接？false1.1autoReconnectForPools是否使用针对数据库连接池的重连策略false3.1.3failOverReadOnly自动重连成功后，连接是否设置为只读？true3.0.12maxReconnectsautoReconnect设置为true时，重试连接的次数31.1initialTimeoutautoReconnect设置为true时，两次重连之间的时间间隔，单位：秒21.1connectTimeout和数据库服务器建立socket连接时的超时，单位：毫秒。 0表示永不超时，适用于JDK 1.4及更高版本03.0.1socketTimeoutsocket操作（读写）超时，单位：毫秒。 0表示永不超时03.0.1 方法三：连接池文件配置 由于自己没有使用c3p0配置文件，如果有c3p0配置文件，建议在cep0配置文件中进行如下配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;c3p0-config&gt;&lt;default-config&gt;&lt;!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。Default: 3 --&gt;&lt;property name=&quot;acquireIncrement&quot;&gt;3&lt;/property&gt;&lt;!--定义在从数据库获取新连接失败后重复尝试的次数。Default: 30 --&gt;&lt;property name=&quot;acquireRetryAttempts&quot;&gt;30&lt;/property&gt;&lt;!--两次连接中间隔时间，单位毫秒。Default: 1000 --&gt;&lt;property name=&quot;acquireRetryDelay&quot;&gt;1000&lt;/property&gt;&lt;!--连接关闭时默认将所有未提交的操作回滚。Default: false --&gt;&lt;property name=&quot;autoCommitOnClose&quot;&gt;false&lt;/property&gt;&lt;!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数 那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。Default: null--&gt;&lt;property name=&quot;automaticTestTable&quot;&gt;Test&lt;/property&gt;&lt;!--获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常。但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。Default: false--&gt;&lt;property name=&quot;breakAfterAcquireFailure&quot;&gt;false&lt;/property&gt;&lt;!--当连接池用完时客户端调用getConnection()后等待获取新连接的时间，超时后将 抛出SQLException,如设为0则无限期等待。单位毫秒。Default: 0 --&gt;&lt;property name=&quot;checkoutTimeout&quot;&gt;100&lt;/property&gt;&lt;!--通过实现ConnectionTester或QueryConnectionTester的 类来 测试连接。类名需制定全路径。Default: com.mchange.v2.c3p0.impl.DefaultConnectionTester--&gt;&lt;property name=&quot;connectionTesterClassName&quot;&gt;&lt;/property&gt;&lt;!--指定c3p0 libraries的路径，如果（通常都是这样）在本地即可获得那么无需设置，默认null即可Default: null--&gt;&lt;property name=&quot;factoryClassLocation&quot;&gt;null&lt;/property&gt;&lt;!--Strongly disrecommended. Setting this to true may lead to subtle and bizarre bugs.（文档原文）作者强烈建议不使用的一个属性--&gt;&lt;property name=&quot;forceIgnoreUnresolvedTransactions&quot;&gt;false&lt;/property&gt;&lt;!--每60秒检查所有连接池中的空闲连接。Default: 0 --&gt;&lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;60&lt;/property&gt;&lt;!--初始化时获取三个连接，取值应在minPoolSize与maxPoolSize之间。 Default: 3 --&gt;&lt;property name=&quot;initialPoolSize&quot;&gt;3&lt;/property&gt;&lt;!--最大空闲时间,60秒内未使用则连接被丢弃。若为0则永不丢弃。Default: 0 --&gt;&lt;property name=&quot;maxIdleTime&quot;&gt;60&lt;/property&gt;&lt;!--连接池中保留的最大连接数。Default: 15 --&gt;&lt;property name=&quot;maxPoolSize&quot;&gt;15&lt;/property&gt;&lt;!--JDBC的标准参数，用以控制数据源内加载的PreparedStatements数量。但 由于预缓存的statements属于单个connection而不是整个连接池。所以设置这个参数需要考虑到多方面的因素。如果maxStatements与maxStatementsPerConnection均为0，则缓存被关闭。Default: 0--&gt;&lt;property name=&quot;maxStatements&quot;&gt;100&lt;/property&gt;&lt;!--maxStatementsPerConnection定义了连接池内单个连接所 拥有的最大缓存statements数。Default: 0 --&gt;&lt;property name=&quot;maxStatementsPerConnection&quot;&gt;&lt;/property&gt;&lt;!--c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性 能通过多线程实现多个操作同时被执行。Default: 3--&gt;&lt;property name=&quot;numHelperThreads&quot;&gt;3&lt;/property&gt;&lt;!--当用户调用getConnection()时使root用户成为去获取连接的用户。主要用于 连接池连接非c3p0的数据源时。Default: null--&gt;&lt;property name=&quot;overrideDefaultUser&quot;&gt;root&lt;/property&gt;&lt;!--与overrideDefaultUser参数对应使用的一个参数。Default: null--&gt;&lt;property name=&quot;overrideDefaultPassword&quot;&gt;password&lt;/property&gt;&lt;!--密码。Default: null--&gt;&lt;property name=&quot;password&quot;&gt;&lt;/property&gt;&lt;!--定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个一显著提高测试速度。注意：测试的表必须在初始数据源的时候就存在。Default: null--&gt;&lt;property name=&quot;preferredTestQuery&quot;&gt;select id from test where id=1&lt;/property&gt;&lt;!--用户修改系统配置参数执行前最多等待300秒。Default: 300 --&gt;&lt;property name=&quot;propertyCycle&quot;&gt;300&lt;/property&gt;&lt;!--因性能消耗大请只在需要的时候使用它。如果设为true那么在每个connection提交 的时候都将校验其有效性。建议使用idleConnectionTestPeriod或automaticTestTable等方法来提升连接测试的性能。Default: false --&gt;&lt;property name=&quot;testConnectionOnCheckout&quot;&gt;false&lt;/property&gt;&lt;!--如果设为true那么在取得连接的同时将校验连接的有效性。Default: false --&gt;&lt;property name=&quot;testConnectionOnCheckin&quot;&gt;true&lt;/property&gt;&lt;!--用户名。Default: null--&gt;&lt;property name=&quot;user&quot;&gt;root&lt;/property&gt;&lt;!--早期的c3p0版本对JDBC接口采用动态反射代理。在早期版本用途广泛的情况下这个参数允许用户恢复到动态反射代理以解决不稳定的故障。最新的非反射代理更快并且已经开始广泛的被使用，所以这个参数未必有用。现在原先的动态反射与新的非反射代理同时受到支持，但今后可能的版本可能不支持动态反射代理。Default: false--&gt;&lt;property name=&quot;usesTraditionalReflectiveProxies&quot;&gt;false&lt;/property&gt;&lt;property name=&quot;automaticTestTable&quot;&gt;con_test&lt;/property&gt;&lt;property name=&quot;checkoutTimeout&quot;&gt;30000&lt;/property&gt;&lt;property name=&quot;idleConnectionTestPeriod&quot;&gt;30&lt;/property&gt;&lt;property name=&quot;initialPoolSize&quot;&gt;10&lt;/property&gt;&lt;property name=&quot;maxIdleTime&quot;&gt;30&lt;/property&gt;&lt;property name=&quot;maxPoolSize&quot;&gt;25&lt;/property&gt;&lt;property name=&quot;minPoolSize&quot;&gt;10&lt;/property&gt;&lt;property name=&quot;maxStatements&quot;&gt;0&lt;/property&gt;&lt;user-overrides user=&quot;swaldman&quot;&gt;&lt;/user-overrides&gt;&lt;/default-config&gt;&lt;named-config name=&quot;dumbTestConfig&quot;&gt;&lt;property name=&quot;maxStatements&quot;&gt;200&lt;/property&gt;&lt;user-overrides user=&quot;poop&quot;&gt;&lt;property name=&quot;maxStatements&quot;&gt;300&lt;/property&gt;&lt;/user-overrides&gt;&lt;/named-config&gt;&lt;/c3p0-config&gt;","categories":[{"name":"MySql","slug":"MySql","permalink":"http://sivan0222.cn/categories/MySql/"},{"name":"8小时","slug":"MySql/8小时","permalink":"http://sivan0222.cn/categories/MySql/8小时/"}],"tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"http://sivan0222.cn/tags/Hibernate/"},{"name":"MySql","slug":"MySql","permalink":"http://sivan0222.cn/tags/MySql/"}]},{"title":"Spring中使用注解","slug":"Spring中使用注解","date":"2017-10-26T02:51:29.000Z","updated":"2017-10-27T00:22:31.720Z","comments":true,"path":"2017/10/26/Spring中使用注解/","link":"","permalink":"http://sivan0222.cn/2017/10/26/Spring中使用注解/","excerpt":"使用注解进行实例Bean1234567891011import org.springframework.stereotype.Component;@Component(value=\"user1\")/*类似于&lt;bean id=\"user1\" class=\"com.pojo.User\"&gt;&lt;/bean&gt;*/public class User &#123; public void add() &#123; System.out.println(\"user----------add--------\"); &#125;&#125; 测试1234567891011121314151617import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 使用注解进行装载Bean * @author SiVan * */public class Test &#123; @org.junit.Test public void add() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); User user = (User)context.getBean(\"user1\"); System.out.println(user); user.add(); &#125;&#125; 使用注解创建单实例/多实例12345678910111213import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component(value=\"user1\")@Scope(value=\"prototype\") /*指令多实例*//*指定单实例 @Scope(value=\"singleton\")*/public class User &#123; public void add() &#123; System.out.println(\"user----------add--------\"); &#125;&#125; 注意事项NoSuchBeanDefinitionException 由于配置文件的包名路径没有写对，所以没有搜索到，确保配置文件类的路径正确","text":"使用注解进行实例Bean1234567891011import org.springframework.stereotype.Component;@Component(value=\"user1\")/*类似于&lt;bean id=\"user1\" class=\"com.pojo.User\"&gt;&lt;/bean&gt;*/public class User &#123; public void add() &#123; System.out.println(\"user----------add--------\"); &#125;&#125; 测试1234567891011121314151617import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 使用注解进行装载Bean * @author SiVan * */public class Test &#123; @org.junit.Test public void add() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); User user = (User)context.getBean(\"user1\"); System.out.println(user); user.add(); &#125;&#125; 使用注解创建单实例/多实例12345678910111213import org.springframework.context.annotation.Scope;import org.springframework.stereotype.Component;@Component(value=\"user1\")@Scope(value=\"prototype\") /*指令多实例*//*指定单实例 @Scope(value=\"singleton\")*/public class User &#123; public void add() &#123; System.out.println(\"user----------add--------\"); &#125;&#125; 注意事项NoSuchBeanDefinitionException 由于配置文件的包名路径没有写对，所以没有搜索到，确保配置文件类的路径正确 使用注解的时候出现如下错误： The prefix “context” for element “context:component-scan” is not bound. 解决办法更换Spring总配置文件的头约束，更改为12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解说明，会自动扫描该包，扫描包下面的类，方法是否有注解 --&gt; &lt;context:component-scan base-package=\"com.pojo\"&gt;&lt;/context:component-scan&gt; &lt;!-- 多个注解可以更改为如下 --&gt; &lt;context:component-scan base-package=\"com.pojo,com.annotation\"&gt;&lt;/context:component-scan&gt; &lt;!-- 也可以直接更改为如下配置 --&gt; &lt;context:component-scan base-package=\"com\"&gt;&lt;/context:component-scan&gt; &lt;!-- 只会扫描属性上的注解 --&gt; &lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;&lt;/beans&gt;","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"Spring","slug":"框架/Spring","permalink":"http://sivan0222.cn/categories/框架/Spring/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://sivan0222.cn/tags/Spring/"}]},{"title":"一种优雅的策略---递归","slug":"一种优雅的策略-递归","date":"2017-10-22T04:11:50.000Z","updated":"2017-10-22T04:57:07.586Z","comments":true,"path":"2017/10/22/一种优雅的策略-递归/","link":"","permalink":"http://sivan0222.cn/2017/10/22/一种优雅的策略-递归/","excerpt":"前言 现在写这篇文章主要记录自己使用递归的经过 说到递归，不得不说起自己大一刚刚开学接触c语言，第1个问题便是一个求阶乘的题目，最终采用了递归策略，记得自己当时测试的时候，足足用了1分钟，最后才发现是一个死循环，从那时开始便开始躲避递归，就怕来个死循环~唧唧！ 说实话，在我今天写这个技术博客记录自己递归的使用历程的时候，不得不说自己 真的是 从 厌恶递归 –&gt; 接受递归 –&gt; 欣赏递归 递归的使用 说到递归的使用，二话不说先来一个例子，自己之前看到一本书上，例子如下 当我们打开祖母留给我们的箱子的时候，发现里面依然有一个箱子，然而我们要找的仅仅是一把钥匙，所以每次都会打开一个箱子，直到打开箱子发现钥匙为止！(流程描述如下) 123456789101112131415161718public class FindKey &#123; public static final int BOX_KEY = 1; /** * * @param box 一个宝箱 */ public static void find(Box box) &#123; for (int i = 0; i &lt; box.listBoxes; i++) &#123; if(box[i] == BOX_KEY) &#123; System.out.println(\"The key is found\"); return; &#125;else &#123; find(box[i]); /* 递归 */ &#125; &#125; &#125;&#125; 记得之前看过Stack Overflow上的一句话：使用循环 程序性能可能更高，使用递归，程序可能更容易理解 递归中的条件正如大家都知道，递归都是自己调用自己，如果我们在编写程序的时候，没有进行判断，程序将会出现死循环，这个错误对我们来说是非常严重的，因此我们对递归是否继续进行判断。","text":"前言 现在写这篇文章主要记录自己使用递归的经过 说到递归，不得不说起自己大一刚刚开学接触c语言，第1个问题便是一个求阶乘的题目，最终采用了递归策略，记得自己当时测试的时候，足足用了1分钟，最后才发现是一个死循环，从那时开始便开始躲避递归，就怕来个死循环~唧唧！ 说实话，在我今天写这个技术博客记录自己递归的使用历程的时候，不得不说自己 真的是 从 厌恶递归 –&gt; 接受递归 –&gt; 欣赏递归 递归的使用 说到递归的使用，二话不说先来一个例子，自己之前看到一本书上，例子如下 当我们打开祖母留给我们的箱子的时候，发现里面依然有一个箱子，然而我们要找的仅仅是一把钥匙，所以每次都会打开一个箱子，直到打开箱子发现钥匙为止！(流程描述如下) 123456789101112131415161718public class FindKey &#123; public static final int BOX_KEY = 1; /** * * @param box 一个宝箱 */ public static void find(Box box) &#123; for (int i = 0; i &lt; box.listBoxes; i++) &#123; if(box[i] == BOX_KEY) &#123; System.out.println(\"The key is found\"); return; &#125;else &#123; find(box[i]); /* 递归 */ &#125; &#125; &#125;&#125; 记得之前看过Stack Overflow上的一句话：使用循环 程序性能可能更高，使用递归，程序可能更容易理解 递归中的条件正如大家都知道，递归都是自己调用自己，如果我们在编写程序的时候，没有进行判断，程序将会出现死循环，这个错误对我们来说是非常严重的，因此我们对递归是否继续进行判断。 递归条件 使得递归程序继续运行的条件 基线条件 使得递归函数不再继续的条件，也就是不满足递归的条件，从而避免死循环 递归中的数据结构 很多题目中都会问到 递归算法执行的过程中，计算机系统一定用到的数据结构是什么？ 答案顾名思义肯定是栈，这里我们一般将其称为 调用栈的栈（计算机内部使用） 调用栈的栈 这里举个例子，比如求 3的阶乘 第一步：计算结果为 3 * fact(2)，开始调用fact(2) 第二步：计算结果为 2 * fact(1); 当我们调用fact(2)的时候，fact(3)暂停，处于未完成状态 第三步：计算结果为 1; 并返回1 当我们调用fact(1)的时候，fact(2)暂停，处于未完成状态 注意事项 栈虽然很方便，但是当我们存储大量信息的时候会占用大量的内存，每个函数调用都会占用一定内存，就意味着计算机存储了大量函数调用的过程信息。 遇到上述情况的时候，我们可以尝试使用循环，或者尾递归！ 所有函数调用都会进入调用栈 调用栈很长的时候，将会占用大量的内存 总结：虽然递归可以极大程度的简化代码，但是我们使用的时候还是需要注意，递归中的函数调用会占用很大的内存，当我们递归次数多的时候可以考虑使用循环或者尾递归","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sivan0222.cn/categories/Algorithm/"},{"name":"策略","slug":"Algorithm/策略","permalink":"http://sivan0222.cn/categories/Algorithm/策略/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://sivan0222.cn/tags/Algorithm/"}]},{"title":"记录一次SSH整合的过程","slug":"记录一次SSH整合的过程","date":"2017-10-21T11:11:32.000Z","updated":"2017-10-21T12:12:05.816Z","comments":true,"path":"2017/10/21/记录一次SSH整合的过程/","link":"","permalink":"http://sivan0222.cn/2017/10/21/记录一次SSH整合的过程/","excerpt":"最近做的这个项目采用了SSH框架，由于时间隔了很久，框架搭建忘记了很多，所以以此记录自己现在搭建整个框架的流程，留作参考！ 本次搭建采用了 MyEclipse 2017 IDE + Hibernate 3.3 + Spring 3.0 作为案例 搭建Hibernate框架 这次搭建框架的首要步骤便是搭建Hibernate框架 步骤 新建一个Web Project,并点击生成web.xml，点击Finish 对要搭建框架的项目进行右击，选中Configure Facets… –&gt; 点击Install Hibernate Facet 选择版本号(3.3) –&gt; 进行hibernate.cfg.xml的创建 –&gt; 进行 Hibernate 数据库连接配置 –&gt; 选择Hibernate导入jar包 修改hibernate.cfg.xml配置文件：创建一个 show_sql ，值为 true","text":"最近做的这个项目采用了SSH框架，由于时间隔了很久，框架搭建忘记了很多，所以以此记录自己现在搭建整个框架的流程，留作参考！ 本次搭建采用了 MyEclipse 2017 IDE + Hibernate 3.3 + Spring 3.0 作为案例 搭建Hibernate框架 这次搭建框架的首要步骤便是搭建Hibernate框架 步骤 新建一个Web Project,并点击生成web.xml，点击Finish 对要搭建框架的项目进行右击，选中Configure Facets… –&gt; 点击Install Hibernate Facet 选择版本号(3.3) –&gt; 进行hibernate.cfg.xml的创建 –&gt; 进行 Hibernate 数据库连接配置 –&gt; 选择Hibernate导入jar包 修改hibernate.cfg.xml配置文件：创建一个 show_sql ，值为 true 搭建Spring框架步骤 对要搭建框架的项目进行右击，选中Configure Facets… –&gt; 点击Install Hibernate Facet 选择Spring版本号 –&gt; 添加Spring配置文件 –&gt; 添加Spring 开发jar包 进行逆向工程，生成对应的 POJO 以及 映射文件 和 DAO src目录下 新建 com.dao 文件夹，将生成的DAO文件全部移动到com.dao中 配置 web.xml 在Context Parameters 栏目中，添加如下值： 1234&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:app*.xml&lt;/param-value&gt;&lt;/context-param&gt; 在Listeners栏目下新建一个ListenerClass 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 配置springMVC中的 servlet，配置如下，(于旁边 JSP File 栏目报错，可以随便填入几个字符，再删除并保存就可以避免错误！) 12345678&lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 配置applicationContext的XML配置文件 更换xml文件头，改为如下： 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt; 配置 scan 扫描 1&lt;context:component-scan base-package=\"com.service\"&gt;&lt;/context:component-scan&gt; 在com.dao下面新建HqlDAO类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class HqlDAO extends HibernateDaoSupport&#123; public List query(String hql,Object ...p) &#123; return super.getHibernateTemplate().find(hql,p); &#125; public List findByHQL(final String hql,final Object ...p) &#123; List list=getHibernateTemplate().executeFind(new HibernateCallback() &#123; public Object doInHibernate(Session session) throws HibernateException, SQLException &#123; /* TODO Auto-generated method stub */ Query query=session.createQuery(hql); for (int i = 0; i &lt; p.length; i++) &#123; query.setParameter(i, p[i]); &#125; return query.list(); &#125; &#125;); return list; &#125; public int zsg(String hql, Object ...p) &#123; return super.getHibernateTemplate().bulkUpdate(hql,p); &#125; public Session getHibernateSession() &#123; Session session=super.getHibernateTemplate().execute(new HibernateCallback&lt;Session&gt;() &#123; public Session doInHibernate(Session s) throws HibernateException, SQLException &#123; /* TODO Auto-generated method stub */ return s; &#125; &#125;); return session; &#125; public List pageQuery(String hql, int size,int page , Object ...p) &#123; try &#123; Session session=getHibernateSession(); Query query=session.createQuery(hql); if(p!=null) &#123; for (int i = 0; i &lt; p.length; i++) &#123; query.setParameter(i, p[i]); &#125; &#125; query.setFirstResult((page-1)*size).setMaxResults(size); List list=query.list(); return list; &#125; catch (HibernateException e) &#123; /* TODO Auto-generated catch block */ e.printStackTrace(); &#125; return new ArrayList(); &#125; public void bulkUpdate(String hql, Object... p) &#123; getHibernateTemplate().bulkUpdate(hql, p); &#125; public float unique(final String hql ,final Object...p) &#123; List list = query(hql, p); if (list.size()&gt;0) &#123; Object obj = list.get(0); if (obj!=null)&#123; return Float.parseFloat(obj.toString()); &#125; &#125; return 0; &#125; public List sqlPageCreateQuery(String sql, int page, int size, Object... p) &#123; Session session = getHibernateSession(); Query query = session.createSQLQuery(sql); if (p != null) &#123; for (int i = 0; i &lt; p.length; i++) &#123; query.setParameter(i, p[i]); &#125; &#125; query.setFirstResult((page - 1) * size).setMaxResults(size); List list = query.list(); return list; &#125; public List sqlCreateQuery(String sql, Object... p) &#123; Session session = getHibernateSession(); Query query = session.createSQLQuery(sql); if (p != null) &#123; for (int i = 0; i &lt; p.length; i++) &#123; query.setParameter(i, p[i]); &#125; &#125; List list = query.list(); return list; &#125;&#125; 配置hqlDAO 1234567891011121314151617181920&lt;bean id=\"hqlDAO\" class=\"com.dao.HqlDAO\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt;``` 5. 配置事务```XML&lt;bean id=\"transactionManager\" class=\"org.springframework.orm.hibernate3.HibernateTransactionManager\"&gt; &lt;property name=\"sessionFactory\" ref=\"sessionFactory\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;tx:advice id=\"mytx\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:advisor advice-ref=\"mytx\" pointcut=\"execution(* com.service.*.*(..))\"/&gt;&lt;/aop:config&gt; WEB-INF文件夹下 新建 springMVC-servlet.xml ：用来处理中文 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd\"&gt;&lt;context:component-scan base-package=\"com.action\"&gt;&lt;/context:component-scan&gt;&lt;!-- 中文处理 要在context下面--&gt; &lt;bean class=\"org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter\"&gt; &lt;property name=\"messageConverters\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"supportedMediaTypes\"&gt; &lt;list&gt; &lt;bean class=\"org.springframework.http.MediaType\"&gt; &lt;constructor-arg index=\"0\" value=\"text\" /&gt; &lt;constructor-arg index=\"1\" value=\"plain\" /&gt; &lt;constructor-arg index=\"2\" value=\"UTF-8\" /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; src下创建文件：log4j.properties（内容如下）： 123456789101112#to console#log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.outlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%n#to file#log4j.appender.file=org.apache.log4j.FileAppenderlog4j.appender.file.File=sunjob.loglog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %l %m%n#error/warn/info/debug#log4j.rootLogger=info, stdout, file 测试： 将搭建好的项目部署到tomcat服务器，并启动，如果服务器没有报错，并且页面可以访问，说明搭建成功 总结：这次搭建SSH框架非常流畅，虽然之前搭建过，但是忘记了很多，因此这次的搭建确实刻骨铭心！","categories":[{"name":"框架","slug":"框架","permalink":"http://sivan0222.cn/categories/框架/"},{"name":"整合","slug":"框架/整合","permalink":"http://sivan0222.cn/categories/框架/整合/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"SSH","slug":"SSH","permalink":"http://sivan0222.cn/tags/SSH/"}]},{"title":"$(document).ready() 与 window.onload() 方法区别","slug":"ready-与-window-onload-方法区别","date":"2017-10-18T11:14:09.000Z","updated":"2017-10-18T11:45:20.977Z","comments":true,"path":"2017/10/18/ready-与-window-onload-方法区别/","link":"","permalink":"http://sivan0222.cn/2017/10/18/ready-与-window-onload-方法区别/","excerpt":"浏览器装载完文档之后,浏览器会通过JS为document元素添加事件，JS中通常使用window.onload 方法，而在jQuery中，通常会使用$(document).ready()方法 区别执行时机的区别 window.onload 方法在等待网页中的所有元素全部加载(和元素有关联的文件)之后才会执行。JS此时才会访问网页中的元素。 jQuery 中的 $(document).ready()方法注册的事件处理程序，在Dom完全就绪的时候就可以调用，此时网页的所有元素都可以进行访问，但并不是这些元素关联的文件都已经下载完毕。 注意： 当DOM数解析完成之后，图片还没有加载完毕，图片高度和宽度这样的属性此时不一定有效 多次使用 网页中的代码如下，但是多次使用 window.onload 之后，只会弹出一次 1234567window.onload = function()&#123; alert(\"1\");&#125;window.onload = function()&#123; alert(\"2\");&#125; 而jQuery中的 $(document).ready() 则可以写多次，且都会执行 123456$(document).ready(function()&#123; alert(&quot;1&quot;); &#125;);$(document).ready(function()&#123; alert(&quot;2&quot;); &#125;); 总结： onload 事件一次只可以保存一个函数的引用，会自动用后面的函数覆盖前面的函数，因此不可以在现有的行为上继续添加行为 $(document).ready()方法能够将会很好的处理这些情况，每次调用都会在现有的行为上追加新的行为，并按照注册的顺序依次执行","text":"浏览器装载完文档之后,浏览器会通过JS为document元素添加事件，JS中通常使用window.onload 方法，而在jQuery中，通常会使用$(document).ready()方法 区别执行时机的区别 window.onload 方法在等待网页中的所有元素全部加载(和元素有关联的文件)之后才会执行。JS此时才会访问网页中的元素。 jQuery 中的 $(document).ready()方法注册的事件处理程序，在Dom完全就绪的时候就可以调用，此时网页的所有元素都可以进行访问，但并不是这些元素关联的文件都已经下载完毕。 注意： 当DOM数解析完成之后，图片还没有加载完毕，图片高度和宽度这样的属性此时不一定有效 多次使用 网页中的代码如下，但是多次使用 window.onload 之后，只会弹出一次 1234567window.onload = function()&#123; alert(\"1\");&#125;window.onload = function()&#123; alert(\"2\");&#125; 而jQuery中的 $(document).ready() 则可以写多次，且都会执行 123456$(document).ready(function()&#123; alert(&quot;1&quot;); &#125;);$(document).ready(function()&#123; alert(&quot;2&quot;); &#125;); 总结： onload 事件一次只可以保存一个函数的引用，会自动用后面的函数覆盖前面的函数，因此不可以在现有的行为上继续添加行为 $(document).ready()方法能够将会很好的处理这些情况，每次调用都会在现有的行为上追加新的行为，并按照注册的顺序依次执行","categories":[{"name":"jQuery","slug":"jQuery","permalink":"http://sivan0222.cn/categories/jQuery/"},{"name":"事件","slug":"jQuery/事件","permalink":"http://sivan0222.cn/categories/jQuery/事件/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://sivan0222.cn/tags/JavaScript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://sivan0222.cn/tags/jQuery/"}]},{"title":"了解类的加载，连接和初始化","slug":"了解类的加载，连接和初始化","date":"2017-10-13T15:00:19.000Z","updated":"2017-10-14T14:00:59.062Z","comments":true,"path":"2017/10/13/了解类的加载，连接和初始化/","link":"","permalink":"http://sivan0222.cn/2017/10/13/了解类的加载，连接和初始化/","excerpt":"引言：首先附上三段代码： 123public class A &#123; public static int a = 6;&#125; 1234567public class ATest1 &#123; public static void main(String[] args) &#123; A a = new A(); a.a++; System.out.println(a.a); &#125;&#125; 123456public class ATest2 &#123; public static void main(String[] args) &#123; A b = new A(); System.out.println(b.a); &#125;&#125; 当我们运行完 ATest1 之后 再次运行 ATest2 将会发现 静态变量a的值仍是6，因为在 JVM 中，第一次运行JVM会自动结束，因此对静态变量A保存的数据将会全部丢失，第二次运行JVM将会重新初始化变量，所以值仍为6 结论： 每次运行某个Java程序，命令将会启动一个JVM进程，并且该程序中的线程将处于同一个进程中，都使用该JVM内存区 倘若系统出现一些情况，JVM进程将会被终止 程序运行到最后结束 程序运行中遇到错误或者未捕获的异常 程序中使用System.exit() 或 Runtime.getRuntime().exit() 将会结束程序 JVM被平台终止","text":"引言：首先附上三段代码： 123public class A &#123; public static int a = 6;&#125; 1234567public class ATest1 &#123; public static void main(String[] args) &#123; A a = new A(); a.a++; System.out.println(a.a); &#125;&#125; 123456public class ATest2 &#123; public static void main(String[] args) &#123; A b = new A(); System.out.println(b.a); &#125;&#125; 当我们运行完 ATest1 之后 再次运行 ATest2 将会发现 静态变量a的值仍是6，因为在 JVM 中，第一次运行JVM会自动结束，因此对静态变量A保存的数据将会全部丢失，第二次运行JVM将会重新初始化变量，所以值仍为6 结论： 每次运行某个Java程序，命令将会启动一个JVM进程，并且该程序中的线程将处于同一个进程中，都使用该JVM内存区 倘若系统出现一些情况，JVM进程将会被终止 程序运行到最后结束 程序运行中遇到错误或者未捕获的异常 程序中使用System.exit() 或 Runtime.getRuntime().exit() 将会结束程序 JVM被平台终止 类加载(类初始化)的三个步骤加载 当我们启动一个 JVM ，系统将会通过 加载 连接 初始化 三个步骤 对该类进行初始化！ 加载：将类的Class文件读入内存，并为之创建一个java.lang.Class对象~~~~也就是说，当我们使用任何类的时候，系统都会为之建立java.lang.Class对象！加载是由类加载器完成的，当然也可以通过继承来创建类加载器！ 当类被成功加载到 JVM 中，系统将会生成一个 java.lang.Class对象， 从而进入连接阶段 连接连接：负责把加载到的二进制数据合并到JRE中，分为如下3个阶段 连接的三个阶段 验证：用于检验被加载的类是否有正确的内部结构 准备：负责为类变量分配内存，并设置默认初始值 解析：将类的二进制数据中的符合引用替换成直接引用 初始化初始化：对类变量进行初始化 初始化两种方式： 静态代码块给类变量指定初始值 声明类变量的时候指定初始值 注意事项： 如果类还没有被加载和连接，则程序先加载并连接该类 如果该类的直接父类没有初始化，则先初始化直接父类 如果类中有初始化语句，则依次执行初始化语句 类初始化的时机 创建类的实例 调用某个类的类方法 调用某个类或接口的类变量 使用反射方式强制创建某个类或接口对应的java.lang.Class对象 初始化某个类的子类 直接使用java命令运行某个主类的时候 对于一个 final 型 变量，编译时就可以确定 123456789101112131415161718class MyTest&#123; static &#123; System.out.println(\"静态初始化快。。。\"); &#125; static final String compileConstant = \"final变量\";&#125;public class Test2 &#123; public static void main(String[] args) &#123; System.out.println(MyTest.compileConstant); &#125;&#125; 结果如下final变量","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"Class","slug":"Java/Class","permalink":"http://sivan0222.cn/categories/Java/Class/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Class","slug":"Class","permalink":"http://sivan0222.cn/tags/Class/"}]},{"title":"无框架使用alibaba开源代码连接池Druid","slug":"无框架使用ali开源连接池Druid","date":"2017-10-11T13:50:52.000Z","updated":"2017-10-11T15:32:32.640Z","comments":true,"path":"2017/10/11/无框架使用ali开源连接池Druid/","link":"","permalink":"http://sivan0222.cn/2017/10/11/无框架使用ali开源连接池Druid/","excerpt":"Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。–温少(alibaba开源Druid负责人) 准备工作 下载核心jar包 下载log4j的jar包以及配置文件 拷贝对应的数据库驱动jar包到工作空间中(由于所druid可以跨数据库进行开发，因此我们需要将我们自己使用的数据库驱动拷贝到工作空间中) 使用druid实现连接到数据库 WEB-INF下新建一个文件,命名为 db_server.properties ,配置如下12345678910111213141516driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/masterusername=rootpassword=rootfilters=statinitialSize=2maxActive=300maxWait=60000timeBetweenEvictionRunsMillis=60000minEvictableIdleTimeMillis=300000validationQuery=SELECT 1testWhileIdle=truetestOnBorrow=falsetestOnReturn=falsepoolPreparedStatements=falsemaxPoolPreparedStatementPerConnectionSize=200 注意修改自己的数据库用户名，密码以及url和driverClassName 创建一个连接池工具管理类，命名为DBPoolConnection.java","text":"Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。–温少(alibaba开源Druid负责人) 准备工作 下载核心jar包 下载log4j的jar包以及配置文件 拷贝对应的数据库驱动jar包到工作空间中(由于所druid可以跨数据库进行开发，因此我们需要将我们自己使用的数据库驱动拷贝到工作空间中) 使用druid实现连接到数据库 WEB-INF下新建一个文件,命名为 db_server.properties ,配置如下12345678910111213141516driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql://127.0.0.1:3306/masterusername=rootpassword=rootfilters=statinitialSize=2maxActive=300maxWait=60000timeBetweenEvictionRunsMillis=60000minEvictableIdleTimeMillis=300000validationQuery=SELECT 1testWhileIdle=truetestOnBorrow=falsetestOnReturn=falsepoolPreparedStatements=falsemaxPoolPreparedStatementPerConnectionSize=200 注意修改自己的数据库用户名，密码以及url和driverClassName 创建一个连接池工具管理类，命名为DBPoolConnection.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.sql.SQLException;import java.util.Properties;import org.apache.log4j.Logger;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidDataSourceFactory;import com.alibaba.druid.pool.DruidPooledConnection;/** * 要实现单例模式，保证全局只有一个数据库连接池 */public class DBPoolConnection &#123; static Logger log = Logger.getLogger(DBPoolConnection.class); private static DBPoolConnection dbPoolConnection = null; private static DruidDataSource druidDataSource = null; static &#123; Properties properties = loadPropertiesFile(\"db_server.properties\"); try &#123; druidDataSource = (DruidDataSource) DruidDataSourceFactory.createDataSource(properties); /* DruidDataSrouce工厂模式*/ &#125; catch (Exception e) &#123; log.error(\"获取配置失败\"); &#125; &#125; /** * 数据库连接池单例 * * @return */ public static synchronized DBPoolConnection getInstance() &#123; if (null == dbPoolConnection) &#123; dbPoolConnection = new DBPoolConnection(); &#125; return dbPoolConnection; &#125; /** * 返回druid数据库连接 * * @return * @throws SQLException */ public DruidPooledConnection getConnection() throws SQLException &#123; return druidDataSource.getConnection(); &#125; /** * @param string * 配置文件名 * @return Properties对象 */ private static Properties loadPropertiesFile(String fullFile) &#123; String webRootPath = null; if (null == fullFile || fullFile.equals(\"\")) &#123; throw new IllegalArgumentException(\"Properties file path can not be null\" + fullFile); &#125; webRootPath = DBPoolConnection.class.getClassLoader().getResource(\"\").getPath(); webRootPath = new File(webRootPath).getParent(); InputStream inputStream = null; Properties p = null; try &#123; inputStream = new FileInputStream(new File(webRootPath + File.separator + fullFile)); p = new Properties(); p.load(inputStream); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (null != inputStream) &#123; inputStream.close(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return p; &#125;&#125; 将下载好的log4j的配置文件拷贝到src目录下，jar包拷贝到WEB-INF目录下的lib目录中 编写测试代码 123456789101112131415161718192021222324252627package com.test;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import com.alibaba.druid.pool.DruidDataSource;import com.alibaba.druid.pool.DruidPooledConnection;import com.util.DBPoolConnection;public class Test1 &#123; public static void main(String[] args) &#123; DBPoolConnection connection = DBPoolConnection.getInstance(); DruidPooledConnection conn = null; try &#123; conn = connection.getConnection(); &#125; catch (SQLException e1) &#123; /* TODO Auto-generated catch block*/ e1.printStackTrace(); &#125; System.out.println(conn); &#125; &#125; 使用druid实现监控功能 druid不仅仅拥有美好的连接池功能，甚至提供了后台的监视功能 web.xml中配置filter: 123456789101112&lt;filter&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.alibaba.druid.support.http.WebStatFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;exclusions&lt;/param-name&gt; &lt;param-value&gt;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;DruidWebStatFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; web.xml中配置Servlet: 12345678&lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 开启服务器，url地址为 http://localhost:8080/项目名/druid/，就可以看到关于druid的监控状况 总结：之前Hibernate默认采用的c3p0数据源，由于8个小时不执行SQL操作，将会默认关闭所有连接，很不和谐，所以建议采用druid，同时可以进行监控后台SQL运行情况，甚至可以进行安全监视","categories":[{"name":"开源软件","slug":"开源软件","permalink":"http://sivan0222.cn/categories/开源软件/"},{"name":"Druid","slug":"开源软件/Druid","permalink":"http://sivan0222.cn/categories/开源软件/Druid/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Web","slug":"Web","permalink":"http://sivan0222.cn/tags/Web/"}]},{"title":"彻底理解int类型的取值范围","slug":"彻底理解int类型的取值范围","date":"2017-10-01T08:01:07.000Z","updated":"2017-10-01T09:16:07.803Z","comments":true,"path":"2017/10/01/彻底理解int类型的取值范围/","link":"","permalink":"http://sivan0222.cn/2017/10/01/彻底理解int类型的取值范围/","excerpt":"今天在看一道题目的时候，遇到了一个问题，就是关于数据类型最值的问题，这里介绍下int类型的取值范围，并且如何理解int取值范围 基本计算机知识 在我们了解今天的话题之前，我们需要了解如下的知识： 原码，补码，反码 ~~~~这都是什么鬼？举个最简单例子:例如 : 数字5的二进制 可以表示为（默认是32位机器） ,这里就是原码（第一位是符号位，0为正数，1为负数）0000 0000 0000 0000 0000 0000 0000 0101 对应反码为 0111 1111 1111 1111 1111 1111 1111 1010 ，反码计算规则：对于符号位其他的位取反就可以（也就是把0替换成1，把1替换成0）对应补码的计算规则为 （反码 + 1 )， 也就是 0111 1111 1111 1111 1111 1111 1111 1011 正数在计算机中如何表示？负数呢？计算机中，正数用原码表示，负数用补码(原码取反(符号位不变),然后加上1)表示 c语言中的位数如何知道？最直接体现是由编译器自己决定的，但其实并没有这么简单，还收到OS影响，只有在OS支持下我们才可以由编译器决定！","text":"今天在看一道题目的时候，遇到了一个问题，就是关于数据类型最值的问题，这里介绍下int类型的取值范围，并且如何理解int取值范围 基本计算机知识 在我们了解今天的话题之前，我们需要了解如下的知识： 原码，补码，反码 ~~~~这都是什么鬼？举个最简单例子:例如 : 数字5的二进制 可以表示为（默认是32位机器） ,这里就是原码（第一位是符号位，0为正数，1为负数）0000 0000 0000 0000 0000 0000 0000 0101 对应反码为 0111 1111 1111 1111 1111 1111 1111 1010 ，反码计算规则：对于符号位其他的位取反就可以（也就是把0替换成1，把1替换成0）对应补码的计算规则为 （反码 + 1 )， 也就是 0111 1111 1111 1111 1111 1111 1111 1011 正数在计算机中如何表示？负数呢？计算机中，正数用原码表示，负数用补码(原码取反(符号位不变),然后加上1)表示 c语言中的位数如何知道？最直接体现是由编译器自己决定的，但其实并没有这么简单，还收到OS影响，只有在OS支持下我们才可以由编译器决定！ 计算int取值范围 这里博主OS系统位数为64，编译器如下图 1.确定int位数(1 字节（Byte） = 32 位(bit))1234567#include&lt;stdio.h&gt;int main () &#123; int a = 2147483647; /*通过sizeof 来计算int字节数，这里返回4,也就是4个字节 */ printf(\"%d\\t\", sizeof(int)); return 0;&#125; 2.确定int最大值 32位对应的int最大值 也就是 0111 1111 1111 1111 1111 1111 1111 1111换算成10进制为 21 4748 3647（21亿多） 3.有一个小纰漏 既然0000 0000 0000 0000 0000 0000 0000 0000 和 1000 0000 0000 0000 0000 0000 0000 0000 都可以表示0，并且第一个最正确的说法是 正0，同理，第二个是 负0 不要忘记一件事：负数 永远用补码表示对 1000 0000 0000 0000 0000 0000 0000 0000 求补码得到的正是 0000 0000 0000 0000 0000 0000 0000 0000 既然两个表示的是同一个，都表示0，那岂不是多了1个二进制数么，从而人为规定 原码中的1000 0000 0000 0000 0000 0000 0000 0000 表示 -32768，也就成了负数中的最小值 结论： int 在 32位 的环境中 范围是 -21 4748 3648 ~ +21 4748 3647","categories":[{"name":"计算机基本知识","slug":"计算机基本知识","permalink":"http://sivan0222.cn/categories/计算机基本知识/"}],"tags":[{"name":"C","slug":"C","permalink":"http://sivan0222.cn/tags/C/"},{"name":"OS","slug":"OS","permalink":"http://sivan0222.cn/tags/OS/"}]},{"title":"MySQL存储引擎的选择","slug":"MySQL存储引擎的选择","date":"2017-09-20T14:55:35.000Z","updated":"2017-09-21T01:10:11.927Z","comments":true,"path":"2017/09/20/MySQL存储引擎的选择/","link":"","permalink":"http://sivan0222.cn/2017/09/20/MySQL存储引擎的选择/","excerpt":"了解存储引擎 存储引擎其实就是数据在数据库中的存放方式，通过什么样的方式存储数据效率更高，对于应用的优化有着举足轻重的作用，尤其是对于我们这样海量数据的时代，能够高效的处理海量数据就已经很不易了！ MySQL5.0 支持如下存储引擎： MyISAM InnoDB BDB MEMORY MERGE EXAMPLE NDB Cluster ARCHIVE CSV BLACKHOLE FEDERATED 如此多的存储引擎，却只有InnoDB和BDB提供事务安全表，其他存储引擎都是非事务安全表 选择存储引擎 当我们在创建表的时候没有指定存储引擎，系统将会使用默认存储引擎，MySQL5.5(包含5.5)之前默认存储引擎为MyISAM,之后便改为了InnoDB,如果要修改存储引擎，可以在创建表的SQL语句中进行设置。 查看当前数据库支持的存储引擎，可以使用如下命令1SHOW ENGINES \\G 或者1SHOW VARIABLES LIKE 'have%'; 图片中显示 value 显示为 “DISABLED” 的记录表示支持该存储引擎，但是数据库启动的时候被禁用 创建表的时候指定存储引擎 创建表可以指定存储引擎，例如下面的SQL语句 1234CREATE TABLE ai ( i BIGINT(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY(i)) ENGINE = MyISAM DEFAULT CHARSET = UTF8; 修改存储引擎 也可以使用ALTER TABLE 语句进行存储引擎的修改，将一个已经存在的表修改成其他存储引擎1ALTER TABLE ai ENGINE = InnoDB;","text":"了解存储引擎 存储引擎其实就是数据在数据库中的存放方式，通过什么样的方式存储数据效率更高，对于应用的优化有着举足轻重的作用，尤其是对于我们这样海量数据的时代，能够高效的处理海量数据就已经很不易了！ MySQL5.0 支持如下存储引擎： MyISAM InnoDB BDB MEMORY MERGE EXAMPLE NDB Cluster ARCHIVE CSV BLACKHOLE FEDERATED 如此多的存储引擎，却只有InnoDB和BDB提供事务安全表，其他存储引擎都是非事务安全表 选择存储引擎 当我们在创建表的时候没有指定存储引擎，系统将会使用默认存储引擎，MySQL5.5(包含5.5)之前默认存储引擎为MyISAM,之后便改为了InnoDB,如果要修改存储引擎，可以在创建表的SQL语句中进行设置。 查看当前数据库支持的存储引擎，可以使用如下命令1SHOW ENGINES \\G 或者1SHOW VARIABLES LIKE 'have%'; 图片中显示 value 显示为 “DISABLED” 的记录表示支持该存储引擎，但是数据库启动的时候被禁用 创建表的时候指定存储引擎 创建表可以指定存储引擎，例如下面的SQL语句 1234CREATE TABLE ai ( i BIGINT(20) NOT NULL AUTO_INCREMENT, PRIMARY KEY(i)) ENGINE = MyISAM DEFAULT CHARSET = UTF8; 修改存储引擎 也可以使用ALTER TABLE 语句进行存储引擎的修改，将一个已经存在的表修改成其他存储引擎1ALTER TABLE ai ENGINE = InnoDB; 结果可以使用1SHOW CREATE TABLE ai \\G 进行查看 各种存储引擎的特性 MyISAM MyISAM作为MySQL 5.5 之前默认的存储引擎。不支持事务也不支持外键 优势： 访问速度快，对事务完整性没有要求或者以SELECT, INSERT 为主的应用基本上可以使用该引擎来创建表 每个MyISAM 在磁盘上存储成3个文件，其文件名和表名相同，但扩展名分别是： .frm(存储表定义) .MYD(MYData,存储数据) .MYI(MYIndex,存储索引) 数据文件和索引文件可以放置在不同目录，平均分布IO，获得更快的速度 如果需要指定索引文件和数据文件路径，需要在创建表的时候通过DATA DIRECTORY 和 INDEX DIRECTORY 语句指定，也就是说不同MyISAM 表的索引文件和数据文件可以放置到不同路径下。文件路径需要绝对路径，并且需要访问权限 InnoDB InooDB 存储引擎提供了具有提交，回滚和崩溃恢复能力的事务安全，但是对比MyISAM的存储引擎，InnoDB写的处理效率差一些，并且会占用更多的磁盘空间已保留数据和索引 特点 自动增长列 InnoDB表的增长列可以手工插入，但是插入的值如果是空或者0，则实际插入的值将是自动增长后的值 外键约束 存储方式 使用共享空间存储，这种方式创建的表结构保存在.frm文件中，数据和索引保存在innodb_data_home_dir和innodb_data_file_path定义的表空间，可以是多个文件 使用多表空间存储，这种方式创建的表结构依然保存在.frm文件中，但是每个表的数据和索引单独保存在.ibd中。如果是个分区表，则每个分区对应单独的.ibd文件，文件名是“表名 + 分区名”,可以在创建分区的时候指定每个分区数据文件的位置，以此来将表的IO均匀分布在多个磁盘上。 MEMORY MEMPRY存储引擎使用存在于内存中的内容来创建表，每个MEMORY表只实际对应一个磁盘文件，格式是.frm。MEMORY类型的表访问也非常快，因为它的数据位于内存中，并且默认使用HASH索引，但是一旦服务关闭，表中的数据将会丢失。 创建索引的时候可以指定是HASH索引还是BTREE索引1CREATE INDEX index_name USING HASH ON table_name(column_name); 在启动MySQL服务的时候，使用–inint-file选项，把INSERT INTO … SELECT 或 LOAD DATA INFILE 这样的语句放入到该文件中，就可以在服务启动的时候从持久稳固的数据源装载表 当我们对MEMORY存储引擎的表操纵完成后，应该释放内存，执行DELETE FROM 或 TRUNCATE TABLE 或者 DROP TABLE; 每个MEMORY 表中可以放置的数据量大小，受到max_head_table_size系统变量的约束，这个系统变量初始值为16MB，可以根据需要加大。此外，在定义MEMORY表的时候，可以通过MAX_ROWS子句指定表的最大行数。 MEMORY 类型的存储引擎主要用于内容变化不太频繁，或者作为统计操作的中间结果表，便于高效的对中间结果进行分析并得到最终的统计结果。对存储引擎为MEMORY的表进行更新操作要谨慎，因为数据并没有实际写入到磁盘中，所以如果由于异常或者重启等引起的将会导致数据丢失。 MERGE MERGE 存储引擎是一组MyISAM表的组合，这些MyISAM表必须结构完全相同，MERGE表本身并没有数据，对MERGE类型的表进行查询，更新和删除操作，实际上是对内部MyISAM表进行的。对于MERGE类型表的插入操作，是通过INSERT_METHOD子句定义插入的表，可以有3个不同的值，使用FIRST或LAST值使得插入操作被相应地作用在第一或者最后一个表上，不定义这个子句或者定义为NO，表示不能对这个MERGE表执行插入操作。可以对MERGE表进行DROP操作，仅仅只是删除MERGE，并不会对表的结构有太大影响MERGE表在磁盘上保留两个文件，文件名以表的名字开始，一个.frm文件存储表定义，另一个.MYG文件包含组合表信息，包含MERGE表由哪些表组成，插入新的数据时的依据。可以通过修改.MRG文件来修改MERGE表，但是修改后要通过FLUSH TABLES刷新。 MERGE表和分区表的区别：MERGE表并不能智能地将记录写到对应的表中，而分区表则可以。 ToKuDB ToKuDB是第三方存储引擎，并不是MySQL自带的存储引擎，除此之外，还有列式存储引擎Infobright,高写性能高压缩ToKuDB(也就是这里所讲到的) 一个高性能，支持事务处理的MySQL 和 MariaDB 存储引擎，具有高扩展性，高压缩率，高效的写入性能，支持大多数在线DDL操作 特性 使用Fractal 树保证高效的插入性能 优秀的压缩性，比InnoDB 高近10倍 Hot Schema Changes 特性支持在线创建索引和添加，删除属性列等DDL操作 使用Bulk Loader达到快速加载大量数据 提供了主从延迟消除技术 支持ACID 和 MVCC 使用场景 日志数据，因为日志插入频繁，且存量大 历史数据，通常不会有写操作，可以利用ToKuDB的高压缩特性进行存储 在线DDL较频繁的场景，可以使用ToKuDB可以大大增加系统可用性 选择合适的存储引擎MyISAM MySQL 5.5 之前的默认存储引擎，如果应用以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性，并发性要求不是很高，选择MyISAM引擎将会非常合适，MyISAM是在web,数据仓储，和其他应用环境下最常使用的存储引擎之一 InnoDB用于事务处理应用程序，支持外键，如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、删除操作，那么InnoDB存储引擎应该是比较合适的选择。InnoDB存储引擎除了有效地降低由于删除和更新导致的锁定，还可以确保事务的完整提交和回滚，对于类似计费系统或者财务系统等对数据准确性要求较高的系统，InnoD都是较好的选择 MEMORY将所有数据保存在RAM中，在需要快速定位记录和其他类似数据的环境下，可以提供极快的访问，MEMORY的缺陷是对表的大小有限制，太大的表无法缓存在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中数据可以恢复。MEMORY表通常用于更新不太频繁的小表，用于快速访问得到结果 MERGE用于将一系列等同的MyISAM表以逻辑方式组合在一起，并作为一个对象引用它们，MERGE表的优点在于可以突破对单个MyISAM表大小的限制,并且通过将不同的表分布在多个磁盘上，可以有效的改善MERGE表的访问效率，这对于数据仓储等VLDB环境非常适合！","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://sivan0222.cn/categories/MySQL/"},{"name":"SQL","slug":"MySQL/SQL","permalink":"http://sivan0222.cn/categories/MySQL/SQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://sivan0222.cn/tags/数据库/"},{"name":"MySQL","slug":"MySQL","permalink":"http://sivan0222.cn/tags/MySQL/"}]},{"title":"Java全球化与格式化","slug":"Java全球化与格式化","date":"2017-07-19T14:38:55.000Z","updated":"2017-10-19T15:17:52.139Z","comments":true,"path":"2017/07/19/Java全球化与格式化/","link":"","permalink":"http://sivan0222.cn/2017/07/19/Java全球化与格式化/","excerpt":"最近几年，随着软件蔓延全球的趋势，全球化的脚步不断前进，全球化就意味着我们必须根据不同用户所在的不同地域使用不同的语言，其中最简单的就是根据用户所在地区进行相应语言的设置，也就是本地化，因此全球化离不开本地化！ Java中的全球化 最近几年，随着JDK版本的的深入，Java也不断升级，提供了对不同国家和不同地区的支持！ 思路将程序中的标签，提示等信息放在资源文件中，根据用户所在的地区进行相应的选择，其中每个资源文件采用key—-value形式进行配对，每个资源文件中的key不变，随着地区进行value的改变 用到的类 java.util.Locale 加载国家、资源语言包 java.util.ResourceBundle 封装特定国家、地区环境 java.text.MessageFormat 对带占位符的字符串进行格式化 资源文件命名规范 对于不同语言资源文件的配置，我们也有一套规范 值通常采用 Key —– value 形式进行使用 资源文件通常采用 propertyname_language.properties 的文件名形式进行命名 获取Java支持的国家和语言1234567891011121314/** * 事实上JAVA不可能支持所有国家和地区，如果需要获取JAVA支持的国家和地区， * 则可以调用Locale类的getAvailableLocales()方法，返回一个Locale数组 * 包含了支持的国家和地区， */public class GetSupportClassAndArea &#123; public static void main(String[] args) &#123; Locale[] locales = Locale.getAvailableLocales(); for (Locale locale : locales) &#123; System.out.println(locale.getDisplayCountry() + \"=\" + locale.getCountry() + \"\\t\" + locale.getLanguage() + \"=\" + locale.getDisplayLanguage()); &#125; &#125;&#125;","text":"最近几年，随着软件蔓延全球的趋势，全球化的脚步不断前进，全球化就意味着我们必须根据不同用户所在的不同地域使用不同的语言，其中最简单的就是根据用户所在地区进行相应语言的设置，也就是本地化，因此全球化离不开本地化！ Java中的全球化 最近几年，随着JDK版本的的深入，Java也不断升级，提供了对不同国家和不同地区的支持！ 思路将程序中的标签，提示等信息放在资源文件中，根据用户所在的地区进行相应的选择，其中每个资源文件采用key—-value形式进行配对，每个资源文件中的key不变，随着地区进行value的改变 用到的类 java.util.Locale 加载国家、资源语言包 java.util.ResourceBundle 封装特定国家、地区环境 java.text.MessageFormat 对带占位符的字符串进行格式化 资源文件命名规范 对于不同语言资源文件的配置，我们也有一套规范 值通常采用 Key —– value 形式进行使用 资源文件通常采用 propertyname_language.properties 的文件名形式进行命名 获取Java支持的国家和语言1234567891011121314/** * 事实上JAVA不可能支持所有国家和地区，如果需要获取JAVA支持的国家和地区， * 则可以调用Locale类的getAvailableLocales()方法，返回一个Locale数组 * 包含了支持的国家和地区， */public class GetSupportClassAndArea &#123; public static void main(String[] args) &#123; Locale[] locales = Locale.getAvailableLocales(); for (Locale locale : locales) &#123; System.out.println(locale.getDisplayCountry() + \"=\" + locale.getCountry() + \"\\t\" + locale.getLanguage() + \"=\" + locale.getDisplayLanguage()); &#125; &#125;&#125; 编写一个简单的国际化程序 这里进行一个简单的国际化程序的演示 编写简单的源代码程序 12345public class Hello &#123; public static void main(String[] args) &#123; System.out.println(\"Hello World!\"); &#125;&#125; 编写配置文件1 mess.properties 12hello = 你好!World = 世界! 将配置文件编译成配置中文properties文件采用如下命令进行配置 native2ascii 源配置文件 目的配置文件 编写如下Java程序进行测试 12345678910111213141516public class Hello &#123; public static void main(String[] args) &#123; /*取得系统默认的国家/语言环境*/ Locale myLocale = Locale.getDefault(Locale.Category.FORMAT); /*根据指定国家/语言环境加载资源配置文件*/ ResourceBundle bundle = ResourceBundle.getBundle(\"mess\", myLocale); /*打印从资源文件中获得的信息*/ System.out.println(bundle.getString(\"hello\")); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"Internationalization","slug":"Java/Internationalization","permalink":"http://sivan0222.cn/categories/Java/Internationalization/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Internationalization","slug":"Internationalization","permalink":"http://sivan0222.cn/tags/Internationalization/"}]},{"title":"C3P0连接池的使用","slug":"C3P0连接池的使用","date":"2017-07-07T04:42:40.000Z","updated":"2017-07-07T04:50:58.205Z","comments":true,"path":"2017/07/07/C3P0连接池的使用/","link":"","permalink":"http://sivan0222.cn/2017/07/07/C3P0连接池的使用/","excerpt":"C3P0作为JDBC一个开源的连接池之一，有自己的很大优点，与DBCP相比，C3P0可以自动回收空闲连接，它实现了数据源和JNDI绑定，并且支持JDBC3规范和JDBC2的标准扩展，甚至Hibernate 和 Spring 都采用它作为JDBC的连接池 前提： 导入两个Jar包 使用方法一： 不采用封装，直接进行使用，对于一些连接数据库所需要的参数写在了mysql.ini配置文件中，包括driver,url,user,pass 四个配置选项，采用 windows配置文件的格式（键值对）进行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.beans.PropertyVetoException;import java.io.FileInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;import com.mchange.v2.c3p0.ComboPooledDataSource;public class ToUseC3p0 &#123; public static void main(String[] args)&#123; /*初始化数据库连接参数*/ Properties props = new Properties(); try &#123; props.load(new FileInputStream(\"mysql.ini\")); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; String driver = props.getProperty(\"driver\"); String user = props.getProperty(\"user\"); String pass = props.getProperty(\"pass\"); String url = props.getProperty(\"url\"); ComboPooledDataSource cpds = new ComboPooledDataSource(); try &#123; cpds.setDriverClass(driver); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; cpds.setJdbcUrl(url); cpds.setUser(user); cpds.setPassword(pass); /*获得连接，使用连接，然后释放连接*/ Connection conn = null; try &#123; conn = cpds.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); /*这里并没有真正释放连接，而是将连接归还到连接池中*/ &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","text":"C3P0作为JDBC一个开源的连接池之一，有自己的很大优点，与DBCP相比，C3P0可以自动回收空闲连接，它实现了数据源和JNDI绑定，并且支持JDBC3规范和JDBC2的标准扩展，甚至Hibernate 和 Spring 都采用它作为JDBC的连接池 前提： 导入两个Jar包 使用方法一： 不采用封装，直接进行使用，对于一些连接数据库所需要的参数写在了mysql.ini配置文件中，包括driver,url,user,pass 四个配置选项，采用 windows配置文件的格式（键值对）进行配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.beans.PropertyVetoException;import java.io.FileInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.SQLException;import java.util.Properties;import com.mchange.v2.c3p0.ComboPooledDataSource;public class ToUseC3p0 &#123; public static void main(String[] args)&#123; /*初始化数据库连接参数*/ Properties props = new Properties(); try &#123; props.load(new FileInputStream(\"mysql.ini\")); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; String driver = props.getProperty(\"driver\"); String user = props.getProperty(\"user\"); String pass = props.getProperty(\"pass\"); String url = props.getProperty(\"url\"); ComboPooledDataSource cpds = new ComboPooledDataSource(); try &#123; cpds.setDriverClass(driver); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; cpds.setJdbcUrl(url); cpds.setUser(user); cpds.setPassword(pass); /*获得连接，使用连接，然后释放连接*/ Connection conn = null; try &#123; conn = cpds.getConnection(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; conn.close(); /*这里并没有真正释放连接，而是将连接归还到连接池中*/ &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 使用方法二： 对于方法一的使用，其实有很多弊端，包括每次使用，都需要写一段很长很冗余的代码，不仅仅程序效率低下，后期的维护更是难上加难！方法二，我们初步进行封装，每次都会获得一个连接池 1234567891011121314151617181920212223242526272829public class JdbcUtils &#123; private static DataSource getDataSource()&#123; /*初始化数据库连接参数*/ Properties props = new Properties(); try &#123; props.load(new FileInputStream(\"mysql.ini\")); &#125; catch (IOException e1) &#123; e1.printStackTrace(); &#125; String driver = props.getProperty(\"driver\"); String user = props.getProperty(\"user\"); String pass = props.getProperty(\"pass\"); String url = props.getProperty(\"url\"); ComboPooledDataSource cpds = new ComboPooledDataSource(); try &#123; cpds.setDriverClass(driver); &#125; catch (PropertyVetoException e) &#123; e.printStackTrace(); &#125; cpds.setJdbcUrl(url); cpds.setUser(user); cpds.setPassword(pass); return cpds; &#125; &#125; 弊端： 每次调用这个JdbcUtils类中的方法都会返回一个不同的连接池 每次调用方法都需要进行初始化连接池的参数，负载大 使用方法三： 对于这个使用C3P0的方法，我们每次都会返回同一个已经配置好的DataSource对象，只需要我们获得连接，使用连接，然后释放连接就可以了！ 123456789101112131415161718192021222324252627282930313233343536373839404142 public class JdbcUtils &#123; /*在类加载的时候便会执行，因此cpds只有一份，不会重复*/ private static ComboPooledDataSource cpds = new ComboPooledDataSource(); private static Properties props = new Properties(); private static String driver; private static String url; private static String user; private static String pass; static &#123; /*为了负责，将编译异常转换为运行时异常抛出*/ try &#123; props.load(new FileInputStream(\"mysql.ini\")); &#125; catch(Exception e) &#123; throw new RuntimeException(e); &#125; driver = props.getProperty(\"driver\"); url = props.getProperty(\"url\"); user = props.getProperty(\"user\"); pass = props.getProperty(\"pass\"); try &#123; cpds.setDriverClass(driver); cpds.setUser(user); cpds.setJdbcUrl(url); cpds.setPassword(pass); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; /*为了避免每次调用该方法获得连接池的时候重复设置参数，我们在上面的静态代码块中设置参数*/ public static DataSource getDataSource()&#123; return cpds; &#125; &#125; 注意事项： 静态代码块中产生的异常我们需要进行转换成运行时异常，并且手动进行抛出 对于C3P0的使用，我们只需要配置一次，不仅省时，还可以节省空间，不过后期我们会采用XML文件进行配置，这里采用了ini配置文件 采用JdbcUtils的getDataSource()方法，我们每次都会获得同一个DataSource对象，正符合我们每个项目只需要一个连接池就可以的要求，并且便于管理！","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"C3P0","slug":"C3P0","permalink":"http://sivan0222.cn/tags/C3P0/"}]},{"title":"git基本指令","slug":"git基本指令","date":"2017-07-01T11:23:14.000Z","updated":"2017-07-07T04:46:04.801Z","comments":true,"path":"2017/07/01/git基本指令/","link":"","permalink":"http://sivan0222.cn/2017/07/01/git基本指令/","excerpt":"git基本指令使用git配置用户信息 对于git所用到的用户信息，对于我们每次提交更新来说都很重要，用来区分谁提交了更新，将会随着更新的内容纳入仓库记录中 配置用户名称和邮箱 当我们要配置用户名称的时候，都想要知道，之前是否已经配置过用户名称，如果没有配置过或者配置的不正确，将要采用如下方法进行配置 git config user.name //打印当前用户名称 git config user.email //打印当前用户邮箱 针对全局进行配置 针对全局进行配置，我们的Git主配置文件将会被修改，采用 –global 选项，更改的配置文件就是位于用户主目录下的那个，以后所有的项目都会默认使用这里配置的用户信息 git config --global user.name &quot;这里写上你的用户名称&quot; git config --global user.email &quot;这里写上你的邮箱&quot; 针对某个项目进行配置 不采用 –global 选项，就是针对某个特定的项目进行配置，而不是全局配置 git config user.name &quot;这里写上你的用户名&quot; git config user.email &quot;这里写上你的邮箱&quot;","text":"git基本指令使用git配置用户信息 对于git所用到的用户信息，对于我们每次提交更新来说都很重要，用来区分谁提交了更新，将会随着更新的内容纳入仓库记录中 配置用户名称和邮箱 当我们要配置用户名称的时候，都想要知道，之前是否已经配置过用户名称，如果没有配置过或者配置的不正确，将要采用如下方法进行配置 git config user.name //打印当前用户名称 git config user.email //打印当前用户邮箱 针对全局进行配置 针对全局进行配置，我们的Git主配置文件将会被修改，采用 –global 选项，更改的配置文件就是位于用户主目录下的那个，以后所有的项目都会默认使用这里配置的用户信息 git config --global user.name &quot;这里写上你的用户名称&quot; git config --global user.email &quot;这里写上你的邮箱&quot; 针对某个项目进行配置 不采用 –global 选项，就是针对某个特定的项目进行配置，而不是全局配置 git config user.name &quot;这里写上你的用户名&quot; git config user.email &quot;这里写上你的邮箱&quot; 修改默认的文本编辑器 如果我们在输入一些额外信息的时候，将会调用操作系统指定的编辑器，如果我们想要修改编辑器（这里假设修改为 emacs），可以采用如下指令 git config --global core.editor emacs 查看用户配置信息 对于一些忘记自己目前Git配置信息的用户，可以使用如下指令进行查看 git config --list 差异分析工具 在产生代码冲突的时候，我们将会决定需要使用哪种差异分析工具来解决代码冲突，可以采用如下指令修改默认的差异分析工具 git config --global merge.tool vimdiff 采用git获取帮助 在采用git指令时，难免会产生很多疑问，可以采用如下的几个指令进行查看 git help &lt;verb&gt; git &lt;verb&gt; --help 从远程仓库克隆项目到本地 对于git，如何将代码从GitHub克隆到本地，非常简单，只要在联网的情况下，使用下面几个指令便可以将仓库克隆到本地 初始化仓库所在的目录git init 使用git init 指令，将会在当前目录生成一个.git目录 没有生成 .git 目录时 关于很多人使用git init指令，但是没有产生.git文件，将会给我们造成很大的干扰，采用如下方法进行查看 使用 ls -la 指令进行查看，如果显示出的文件有 .git 文件，则正常 使用git clone指令对远程仓库克隆到本地git clone &lt;url&gt;(项目地址) git clone &lt;url&gt;(项目地址) 文件名称 //创建一个指定的文件夹（名称为文件名称），并将远程仓库所有代码存放到改文件夹下","categories":[{"name":"常用命令","slug":"常用命令","permalink":"http://sivan0222.cn/categories/常用命令/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://sivan0222.cn/tags/GitHub/"},{"name":"git","slug":"git","permalink":"http://sivan0222.cn/tags/git/"}]},{"title":"Algorithm-冒泡排序","slug":"Algorithm-冒泡排序","date":"2017-05-22T12:36:47.000Z","updated":"2017-05-22T15:17:17.315Z","comments":true,"path":"2017/05/22/Algorithm-冒泡排序/","link":"","permalink":"http://sivan0222.cn/2017/05/22/Algorithm-冒泡排序/","excerpt":"冒泡排序 这里假定冒泡排序是整形数组，并且以升序排列 冒牌排序需要我们遍历几次数组，每次遍历中，需要比较相邻的两个元素，如果按降序排列，则互换，否则保持不变！由于较小的值像“气泡”一样逐渐浮向顶部，而较大的值沉向底部，所以称为冒泡排序或者下沉排序。 特征：假设一共有n个元素，第m次遍历之后，最后的m个元素顺序已经确定 时间复杂度：最大为o(n*n)，最小为o(1) 初始的冒泡排序：1234567891011121314151617181920212223/** * 初级别的冒泡排序 * @param nums * @return 排序后的数组 */ public static int[] toBubbleSort0(int[] nums)&#123; int count = 0; int sum = 0; for (int i = 1; i &lt; nums.length - 1; i++)&#123; for (int j = 0; j &lt; nums.length - i; j++)&#123; sum++; if(nums[j] &gt; nums[j+1])&#123; count++; int temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125; System.out.println(count); System.out.println(sum); return nums; &#125;","text":"冒泡排序 这里假定冒泡排序是整形数组，并且以升序排列 冒牌排序需要我们遍历几次数组，每次遍历中，需要比较相邻的两个元素，如果按降序排列，则互换，否则保持不变！由于较小的值像“气泡”一样逐渐浮向顶部，而较大的值沉向底部，所以称为冒泡排序或者下沉排序。 特征：假设一共有n个元素，第m次遍历之后，最后的m个元素顺序已经确定 时间复杂度：最大为o(n*n)，最小为o(1) 初始的冒泡排序：1234567891011121314151617181920212223/** * 初级别的冒泡排序 * @param nums * @return 排序后的数组 */ public static int[] toBubbleSort0(int[] nums)&#123; int count = 0; int sum = 0; for (int i = 1; i &lt; nums.length - 1; i++)&#123; for (int j = 0; j &lt; nums.length - i; j++)&#123; sum++; if(nums[j] &gt; nums[j+1])&#123; count++; int temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125; System.out.println(count); System.out.println(sum); return nums; &#125; 简单的冒泡排序：1234567891011121314151617181920212223/** * 一个简单的冒泡排序 * @param nums * @return 排序后的数组 */public static int[] toBubbleSort(int[] nums)&#123; int count = 0; int sum = 0; for (int i = 0; i &lt; nums.length - 1; i++)&#123; for (int j = 0; j &lt; nums.length - 1 - i; j++)&#123; sum++; if(nums[j] &gt; nums[j+1])&#123; count++; int temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125; System.out.println(count); System.out.println(sum); return nums; &#125; 复杂的冒泡排序这里我们采用了一个标记符来决定是否继续下次排序，标记符的作用是如果上次遍历没有发生排序，说明我们排序已经确定，所以我们不再继续排序，因为每次排序的数字，都是上次排序的一个子集，如果我们上次没有改变，那么之后也不需要进行排序，从而减少我们耗费的时间 123456789101112131415161718192021222324252627/** * 一个复杂的冒泡排序 * @param nums * @return 排序后的数组 */public static int[] toBubbleSort1(int[] nums)&#123; boolean next = true; int count = 0; int sum = 0; for (int i = 0; i &lt; nums.length - 1 &amp;&amp; next; i++)&#123; next = false; for (int j = 0; j &lt; nums.length - 1 - i; j++)&#123; sum++; if(nums[j] &gt; nums[j+1])&#123; count++; int temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; next = true; &#125; &#125; &#125; System.out.println(count); System.out.println(sum); return nums; &#125; 测试数据集：1int[] b = &#123;4,1,2,3&#125;; 结果记录：061 2 3 4351 2 3 435 1 2 3 4 通过结果发现，我们可以知道复杂的冒泡排序时间复杂度比简单的冒泡排序多加了个判断，极大程度的减少了我们排序的重复次数，对于算法的性能有很大的改进 在最佳的情况下，冒泡排序只需要一次就可以确定数组已排好序，不需要进行下一次便利，由于第一次遍历的次数为n-1，因此在最佳情况下，冒泡排序的时间为O(n)","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sivan0222.cn/categories/Algorithm/"},{"name":"BubbleSort","slug":"Algorithm/BubbleSort","permalink":"http://sivan0222.cn/categories/Algorithm/BubbleSort/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://sivan0222.cn/tags/Algorithm/"}]},{"title":"减少HTML网页图片资源请求次数","slug":"减少HTML网页图片资源请求次数","date":"2017-05-22T11:25:04.000Z","updated":"2017-05-22T15:16:53.082Z","comments":true,"path":"2017/05/22/减少HTML网页图片资源请求次数/","link":"","permalink":"http://sivan0222.cn/2017/05/22/减少HTML网页图片资源请求次数/","excerpt":"最近学习前端，老师讲过一个问题，虽然QQ网页很好看，但是加载时间过长，因为将每一张图片都分离开来，一张图片对应用户的一次请求，所以我们一般讲网站用的图标都集中到一张图上，然后通过移动图片位置和确定图片大小来锁定我们要的图片，会让我们网页的次数减少一个很大的层次，算是一个经验！！！ 优点： 这里放了两张图，其中第一张是网页所用到的图片，都集中到一张图片上了，第二张我们要实现的效果图片，不用专门对图片进行裁剪 这里我们只对图片请求了一次，不需要对图标分别请求，优化了网页 缺点： 需要手动定位到我们需要的图标，可能遇到图标对的不齐的问题","text":"最近学习前端，老师讲过一个问题，虽然QQ网页很好看，但是加载时间过长，因为将每一张图片都分离开来，一张图片对应用户的一次请求，所以我们一般讲网站用的图标都集中到一张图上，然后通过移动图片位置和确定图片大小来锁定我们要的图片，会让我们网页的次数减少一个很大的层次，算是一个经验！！！ 优点： 这里放了两张图，其中第一张是网页所用到的图片，都集中到一张图片上了，第二张我们要实现的效果图片，不用专门对图片进行裁剪 这里我们只对图片请求了一次，不需要对图标分别请求，优化了网页 缺点： 需要手动定位到我们需要的图标，可能遇到图标对的不齐的问题 源代码（图片路径请注意修改）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;header&lt;/title&gt; &lt;style media=\"screen\"&gt; * &#123; margin: 0px; padding: 0px; &#125; #box1 &#123; background-image: url(images\\\\h_bg.jpg); background-repeat: no-repeat; width: 1920px; height: 150px; &#125; #data-nav &#123; padding: 0px; /*background-color: red;*/ width:735px; height:30px; position: absolute; margin-top: 100px; margin-left: 25px; &#125; li&#123; float: left; list-style: none; padding: 0px; line-height: 30px; text-align: center; &#125; a &#123; text-decoration: none; &#125; #data-nav li &#123; width: 83px; &#125; #data-nav li:hover&#123; background-image: url(images\\\\nav_bg.gif); &#125; #data-welcome&#123; color:grey; letter-spacing: 3px; margin-left: 510px; position: absolute; margin-top: 70px; font-size: 14px; &#125; #data-menu &#123; /*background-color: red;*/ position: absolute; margin-top: 10px; width: 460px; height: 40px; margin-left: 540px; font-size: 15px; &#125; .bg&#123; background-image: url(images\\\\icon.gif); width: 30px; height: 28px; &#125; .bg1 &#123; background-position: -40px 0px; &#125; .bg2 &#123; background-position: -82px 0px; &#125; .bg3 &#123; background-position: -122px 0px; &#125; #data-menu .icon &#123; width: 32px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"box1\"&gt; &lt;div id=\"data-nav\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;家用电器&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;手机数码&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;日用百货&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;书籍&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;帮助中心&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;免费开店&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;全球咨询&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"data-menu\"&gt; &lt;ul&gt; &lt;li class=\"bg icon\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;购物车&lt;/a&gt;&lt;/li&gt; &lt;li class=\"bg bg1 icon\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;帮助中心&lt;/a&gt;&lt;/li&gt; &lt;li class=\"bg bg2 icon\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;加入收藏&lt;/a&gt;&lt;/li&gt; &lt;li class=\"bg bg3 icon\"&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;设为首页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div id=\"data-welcome\"&gt; 你好，欢迎访问贵美商城！117年5月21日16点18分 &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"HTML/CSS","slug":"HTML-CSS","permalink":"http://sivan0222.cn/categories/HTML-CSS/"},{"name":"优化","slug":"HTML-CSS/优化","permalink":"http://sivan0222.cn/categories/HTML-CSS/优化/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://sivan0222.cn/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://sivan0222.cn/tags/CSS/"}]},{"title":"Socket通信遇到的问题","slug":"Socket通信遇到的问题","date":"2017-05-19T02:31:36.000Z","updated":"2017-11-09T07:13:49.041Z","comments":true,"path":"2017/05/19/Socket通信遇到的问题/","link":"","permalink":"http://sivan0222.cn/2017/05/19/Socket通信遇到的问题/","excerpt":"最近在进行socket编程的时候，遇到一个问题，将代码粘在了下边，由于之前遇到过该问题，所以就记录下来，顺便总结一下解决思路 产生的异常如下Software caused connection abort: recv failed java.net.SocketException: Software caused connection abort: recv failed at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.read(SocketInputStream.java:129) ....... 代码如下Client类：1234567891011121314151617181920212223242526import java.net.*;import java.io.*;import java.util.*;public class MyTalkClient &#123; public static void main(String[] args)&#123; try&#123; Socket socket = new Socket(\"127.0.0.1\", 8080); while(true)&#123; OutputStream out = socket.getOutputStream(); DataOutputStream dos = new DataOutputStream(out); Scanner input = new Scanner(System.in); dos.writeUTF(input.next()); InputStream in = socket.getInputStream(); DataInputStream dis = new DataInputStream(in); System.out.print(\"Server:\"); /*关于这里为什么会抛出一个异常*/ System.out.println(dis.readUTF()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); System.out.println(\"Error\"); System.exit(0); &#125; &#125;&#125;","text":"最近在进行socket编程的时候，遇到一个问题，将代码粘在了下边，由于之前遇到过该问题，所以就记录下来，顺便总结一下解决思路 产生的异常如下Software caused connection abort: recv failed java.net.SocketException: Software caused connection abort: recv failed at java.net.SocketInputStream.socketRead0(Native Method) at java.net.SocketInputStream.read(SocketInputStream.java:129) ....... 代码如下Client类：1234567891011121314151617181920212223242526import java.net.*;import java.io.*;import java.util.*;public class MyTalkClient &#123; public static void main(String[] args)&#123; try&#123; Socket socket = new Socket(\"127.0.0.1\", 8080); while(true)&#123; OutputStream out = socket.getOutputStream(); DataOutputStream dos = new DataOutputStream(out); Scanner input = new Scanner(System.in); dos.writeUTF(input.next()); InputStream in = socket.getInputStream(); DataInputStream dis = new DataInputStream(in); System.out.print(\"Server:\"); /*关于这里为什么会抛出一个异常*/ System.out.println(dis.readUTF()); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); System.out.println(\"Error\"); System.exit(0); &#125; &#125;&#125; Server类1234567891011121314151617181920212223242526272829303132import java.net.*;import java.io.*;import java.util.*;public class MyTalkServer&#123; /*自己写一个类似于talkserver talkclient的程序*/ public static void main(String[] args)&#123; try&#123; ServerSocket socket = new ServerSocket(8080); while (true)&#123; Socket s = socket.accept(); InputStream in = s.getInputStream(); DataInputStream dis = new DataInputStream(in); System.out.println(\"From:\" + s.getInetAddress() + \"\\\\\" + s.getPort()); System.out.println(dis.readUTF()); OutputStream out = s.getOutputStream(); DataOutputStream dos = new DataOutputStream(out); Scanner input = new Scanner(System.in); dos.writeUTF(input.next()); dos.flush(); dos.close(); dis.close(); out.close(); in.close(); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); System.out.println(\"Error\"); System.exit(0); &#125; &#125;&#125; 解决思路： 客户端和服务端建立tcp的短连接,每次客户端发送一次请求, 服务端响应后关闭与客户端的连接. 如果客户端在服务端关闭连接后,没有释放连接,继续试图发送请求和接收响应. 这个时候就会出错. 这个时候客户端Socket的getOutputStream返回来的OutPutStream维护 的是本地的连接状态, 无法知道远程的服务端已经关闭了对应的InputStream和socket因此 虽然调用了 out.write(sendbuf, 0, sendbuf.length); 方法,但是实际上服务端并没有接收到客户端的请求信息. 因为没有抛出异常,因此造成了误以为客户端请求发送成功的假象. 接下来调用etInputStream的in.read(header, 0, 14);方法. 因为这次要读取服务端的信息,因此产生了 Software caused connection abort: recv failed的异常 在服务端/客户端单方面关闭连接的情况下,另一方依然以为 tcp连接仍然建立,试图读取对方的响应数据,导致出现 Software caused connection abort: recv failed的异常.因此在receive数据之前,要先判断连接状态. 通过inputstream的available()方法来判断,是否有响应结果. 如果available()的返回值为0,说明没有响应数据,可能是对方已经断开连接, 如果available()的返回值大于0,说明有响应数据. 另外值得注意的是available()返回的值是非堵塞的,可以被多个线程访问.在对方释放连接后,也要释放本地的连接.","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"socket","slug":"Java/socket","permalink":"http://sivan0222.cn/categories/Java/socket/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"net","slug":"net","permalink":"http://sivan0222.cn/tags/net/"}]},{"title":"浅谈MySQL中的正则表达式","slug":"浅谈MySQL中的正则表达式","date":"2017-05-14T13:26:19.000Z","updated":"2017-05-14T14:35:10.670Z","comments":true,"path":"2017/05/14/浅谈MySQL中的正则表达式/","link":"","permalink":"http://sivan0222.cn/2017/05/14/浅谈MySQL中的正则表达式/","excerpt":"记得之前自己不熟悉正则表达式的时候，别人问到这个问题，自己一脸懵逼，现在尽管自己对正则表达式有所了解，但还是不够游刃有余，其实自己最感慨正则表达式的强大之处，可能一个正则表达式可以解决我们一个很复杂的问题，例如如何匹配一个身份证号码，如果没有正则表达式，我们可能很难对数据进行有效的过滤。 MySQL中的正则表达式 MySQL中的正则表达式仅支持多数正则表达式实现的一个很小的子集 LIKE 与 REGEXP 的区别下面这段SQL代码将匹配 prod_name 为 1000 的记录1234SELECT prod_nameFROM productsWHERE prod_name LIKE '1000'ORDER BY prod_name; 下面这段SQL代码将匹配 prod_name 中 含有 1000 的记录1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; LIKE 匹配整个列，如果被匹配的文本在列值中出现(而不是列值)，LIKE子句将不会找到 REGEXP 则在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到","text":"记得之前自己不熟悉正则表达式的时候，别人问到这个问题，自己一脸懵逼，现在尽管自己对正则表达式有所了解，但还是不够游刃有余，其实自己最感慨正则表达式的强大之处，可能一个正则表达式可以解决我们一个很复杂的问题，例如如何匹配一个身份证号码，如果没有正则表达式，我们可能很难对数据进行有效的过滤。 MySQL中的正则表达式 MySQL中的正则表达式仅支持多数正则表达式实现的一个很小的子集 LIKE 与 REGEXP 的区别下面这段SQL代码将匹配 prod_name 为 1000 的记录1234SELECT prod_nameFROM productsWHERE prod_name LIKE '1000'ORDER BY prod_name; 下面这段SQL代码将匹配 prod_name 中 含有 1000 的记录1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000'ORDER BY prod_name; LIKE 匹配整个列，如果被匹配的文本在列值中出现(而不是列值)，LIKE子句将不会找到 REGEXP 则在列值内进行匹配，如果被匹配的文本在列值中出现，REGEXP将会找到 MySQL中的正则表达式自版本（3.23.4后）不区分大小写，如果要去区分大小写，可以使用 BINARY 关键字 1234SELECT userinfo.U, userinfo.PFROM userinfoWHERE userinfo.U REGEXP BINARY 'a1'; -- 正则表达式 会超照 字段U 中包含 a1 的值，这里加了个BINARY 只会找到包含 a1的，不会找到包含A1的 匹配给定字符的一个1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1000|2000'ORDER BY prod_name; 上面这段代码将会匹配 prod_name 中 包含1000 或 2000 的记录 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '1|2|3 Ton' ORDER BY prod_name; 上面一段SQL代码意思是找到1 或 2 或 3 Ton的，而不是 1 TON 或 2 Ton 或 3 Ton的 注意 ： 除非把 | 括在一个集合中，否则它将应用于整个串 匹配MySQL中的特殊字符 如果我们需要对MySQL中的特殊字符使用正则表达式，我们需要格外注意 例如：采用如下代码匹配 prod_name 中包含 . 号的1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '.' ORDER BY prod_name; 其实是错误的，上面这段代码其实是列出表中的所有记录，而并不是我们想要的 包含 . 号的记录，因为 . 号在正则表达式中代表任意字符，所以会列出表中所有记录 对于MySQL中的特殊符号，如果我们要采用正则表达式去匹配，需要在特殊符号前面加上 \\ 下面的代码就是匹配 prod_name 中包含 . 号的1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\.' ORDER BY prod_name; 注意 ： 为了匹配特殊字符，必须用 \\ 为前导， \\- 表示查找 - 为了匹配 \\ 本身，需要使用 \\\\ 对于其他语言的正则表达式，如果需要转义特殊字符，我们可能会使用 单个 \\ ，但是MySQL要求我们使用两个 \\ （MySQL自己解释一个，正则表达式库解释另一个） 匹配MySQL中的字符类 类 说明 [:alnum:] 任意字母和数字（同[a-zA-Z0-9]） [:alpha:] 任意字符(同[a-zA-Z]) [:blank:] 空格和制表(同[\\t]) [:cntrl:] ASCII控制字符(ASCII 0到31和127) [:digit:] 任意数字(同[0-9]) [:graph:] 与[:print:]相同，但不包含空格 [:lower:] 任意小写字母(同[a-z]) [:print:] 任意可打印字符 [:punct:] 既不在[:alnum:]又不在[:cntrl:]中的任意字符 [:space:] 包含空格在内的任意空白字符(同[\\f\\n\\r\\t\\v]) [:upper:] 任意大写字母(同[A-Z]) [:xdigit:] 任意十六进制数字(同[a-fA-F0-9]) 1234SELECT prod_nameFROM productsWHERE prod_name REGEXP '[[:digit:]\\\\.]' -- 或者写成 ^[0-9\\\\.]ORDER BY prod_name; 找出prod_name 中 数字（包括小数点） 开始的所有产品 匹配多个实例 元字符 说明 * 0个或多个匹配 + 1个或多个匹配 ? 0个或1个匹配 {n} 指定数目的匹配 {n,} 不少于指定数目的匹配 {n,m} 匹配数目的范围 12345SELECT prod_nameFROM productsWHERE prod_name REGEXP '\\\\([0-9] sticks?\\\\)' ORDER BY prod_name;-- 用来匹配文本 ([0-9] stick(这里sticks也可以，因为是s?,表示s出现0次或1次)) 定位符 元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 文本的结尾 ^ 有双重用途：可以用来匹配文本开始，也可以放在集合中，例如[^123]，表示不匹配含有 1或2或3的 对于MySQL 我们可以在不使用数据库表的情况下用SELECT 来测试正则表达式，REGEXP 检查总是返回 0(没找到匹配)或1(找到匹配) 1SELECT 'hello' REGEXP '[0-9]';","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://sivan0222.cn/categories/MySQL/"},{"name":"正则表达式","slug":"MySQL/正则表达式","permalink":"http://sivan0222.cn/categories/MySQL/正则表达式/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://sivan0222.cn/tags/MySQL/"},{"name":"SQL","slug":"SQL","permalink":"http://sivan0222.cn/tags/SQL/"}]},{"title":"浅谈SQL中的数据过滤","slug":"浅谈SQL中的Where语句","date":"2017-05-12T02:19:32.000Z","updated":"2017-10-22T04:13:03.253Z","comments":true,"path":"2017/05/12/浅谈SQL中的Where语句/","link":"","permalink":"http://sivan0222.cn/2017/05/12/浅谈SQL中的Where语句/","excerpt":"SQL中的WHERE子句 对于数据库中的表，我们经常使用SQL语句进行操作，对于数据量爆炸的今天，倘若需要对用户数据进行验证，如果不加过滤，去索引表中的所有行，无疑拉低了用户的体验！如今，我们经常使用WHERE子句对数据进行过滤，以便得到我们所需要的数据 不采用过滤的缺点 倘若我们不使用WHERE子句对数据进行过滤，将会检索大量无用的数据，并且增加服务器的负载 我们通常可以从服务器端获得我们所需要的数据，如果将全部数据(未过滤)传给用户，并让用户进行过滤，不仅仅大大的增加了网络的带宽，还给用户的体验带来了极大的不方便之处 值得自己思考的问题： 如果数据在用户层过滤，增加了用户的不方便和网络带宽 如果数据在服务器上进行过滤，面对的用户很多，数据量又很大，服务器如果全部处理数据，难免会崩掉！！！综上所述，在用户层和服务器层过滤数据各有好坏，那么现在的数据过滤如何解决，值得自己探索和深思！！！","text":"SQL中的WHERE子句 对于数据库中的表，我们经常使用SQL语句进行操作，对于数据量爆炸的今天，倘若需要对用户数据进行验证，如果不加过滤，去索引表中的所有行，无疑拉低了用户的体验！如今，我们经常使用WHERE子句对数据进行过滤，以便得到我们所需要的数据 不采用过滤的缺点 倘若我们不使用WHERE子句对数据进行过滤，将会检索大量无用的数据，并且增加服务器的负载 我们通常可以从服务器端获得我们所需要的数据，如果将全部数据(未过滤)传给用户，并让用户进行过滤，不仅仅大大的增加了网络的带宽，还给用户的体验带来了极大的不方便之处 值得自己思考的问题： 如果数据在用户层过滤，增加了用户的不方便和网络带宽 如果数据在服务器上进行过滤，面对的用户很多，数据量又很大，服务器如果全部处理数据，难免会崩掉！！！综上所述，在用户层和服务器层过滤数据各有好坏，那么现在的数据过滤如何解决，值得自己探索和深思！！！ 数据过滤BETWEEN AND 子句 开始学习使用 BETWEEN AND 关键字：如果在BETWEEN AND 关键字中使用字符串，我们需要注意，BETWEEN “A1” AND “b1” 意思是，从 A1(对于那些前面为A1(报错A1本身)后面有其他的将会被选择到，例如A11) 开始匹配到 b1(对于那些前面为b1的不会被选择到(不包括b1)) 123SELECT USER.id, USER.U, USER.PFROM USERWHERE USER.U BETWEEN \"A1\" AND \"b1\"; IN操作符 其实SQL语句中对数据进行过滤除了可以使用已有的AND,OR运算符，其实IN操作符可以替换OR操作符 IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配，IN取合法值由逗号分隔的清单，全都括在圆括号中 123SELECT USER.id, USER.U, USER.PFROM USERWHERE USER.id IN (5, 6, 7) 上面这句SQL语句等同于下面这句123SELECT USER.id, USER.U, USER.PFROM USERWHERE USER.id = 5 or USER.id = 6 or USER.id = 7; 使用IN操作符的好处 在使用长的合法选项清单时， IN操作符的语法更清楚且更直观 在使用IN时，计算的次序更容易管理（因为使用的操作符更少） IN操作符一般比OR操作符执行更快 IN的最大有点是可以包含SELECT语句，使得能够更动态的创立WHERE子句！ 采用 NOT 操作符 WHERE子句中的NOT操作符有且只有一个功能，那就是否定它之后所有跟的任何条件 MySQL中的NOT：MySQL支持使用NOT对IN,BETWEEN 和 EXISTS子句取反 在与IN操作符联合使用的时候，NOT使找出与条件列表不匹配的行非常简单 采用 LIKE 操作符 % 操作符（任何字符出现任意次数），如果写成 ‘%HET’, 是会区分大小写的，要注意的是 % 也可以匹配0个字符 123SELECT userinfo.U, userinfo.PFROM userinfoWHERE userinfo.U LIKE '%A1%'; -- 也会找到字段U值为A1的 123SELECT userinfo.U, userinfo.PFROM userinfoWHERE userinfo.P LIKE '%' -- 这里将不会匹配 USERINFO.P 值为null的，尽管使用了通配符 _ 操作符 只能匹配一个字符 通配符的使用技巧： 不要过度使用通配符，如果其他操作符能达到相同的目的，应该使用其他操作符 在确实需要使用通配符时，除非绝对有必要，否则不要把他们用在搜索模式的开始处，把通配符至于搜索模式的开始处，搜索起来是最慢的 注意通配符的位置，如果放错地方，可能不会返回想要的数据 采用 DISTINCT 子句 对于重复的数据，如果我们想返回唯一不同的值，可以使用DISTINCT关键字来进行检索 注意事项(不能部分使用 DISTINCT 关键字)：使用DISTINCT关键字必须放在列名开头，请注意DISTINCT关键字应用于所有列，而不仅是前置它的列，下面这句代码的意思是:对于要检索的字段，除非每行所对应记录的字段都相同，否则都会被检索出来，也就是如果要检索的字段（两行完全相同，将只有一行输出，如果部分相同将全部输出）– 不能部分使用DISTINCT关键字 12SELECT DISTINCT U, PFROM USER 空值检查 创建表的时候，我们将会指定其中的列是否可以包含值，如果一个列不包含值，称其为包含空值NULL NULL : 无值，它与字段包含0，空字符串或仅仅包含空格不同 检索USER 表的 P字段是否为空123SELECT USER.id, USER.U, USER.PFROM USERWHERE USER.P IS NULL; NULL与不匹配 在我们通过过滤选择出不具有特定值的行的时候，我们可能希望返回具有NULL值的行，但是，不行，因为未知具有特殊的含义，数据库不知道他们是否匹配，所以在匹配过滤或不不匹配过滤的时候将不会返回 123SELECT USER.ID, USER.U, USER.PFROM USERWHERE USER.P != '5' # 这里将不会返回P字段为NULL值的行 过滤数据的时候，我们一定要验证返回数据中确实给出了被过滤列具有NULL的行，将SQL语句改为如下123SELECT USER.ID, USER.U, USER.PFROM USERWHERE USER.P != '5' OR USER.P IS NULL # 这里将会返回P字段为NULL值的行","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sivan0222.cn/categories/Algorithm/"},{"name":"策略","slug":"Algorithm/策略","permalink":"http://sivan0222.cn/categories/Algorithm/策略/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://sivan0222.cn/tags/Algorithm/"}]},{"title":"与pydoc的初次邂逅","slug":"与pydoc的初次邂逅","date":"2017-05-11T06:02:58.000Z","updated":"2017-05-13T14:53:31.036Z","comments":true,"path":"2017/05/11/与pydoc的初次邂逅/","link":"","permalink":"http://sivan0222.cn/2017/05/11/与pydoc的初次邂逅/","excerpt":"对于初学者而言，学习一门新的编程语言，最渴求的便是遇到问题时，希望能有个帮助文档来指点迷津，pydoc就是这样一个例子，不仅仅可以帮助我们获得所需的信息，还进一步根据用户体验来在浏览器呈现帮助文档 pydoc是Python自带的模块，主要用于从python模块中自动生成文档，这些文档可以基于文本呈现的、也可以生成WEB 页面的，还可以在服务器上以浏览器的方式呈现！ 学习查看python中的帮助信息 对于Python而言，倘若我们学会查看帮助信息，便是学会了如何运用Python，接下来我们只需将Python运用自如即可 使用Python自带的Idle来查看帮助信息 使用Idle查看帮助信息，我们将会采用help()函数来查看， 1234567891011121314151617181920#查看python所有的moduleshelp(\"modules\") #单看python所有的modules中包含指定字符串的moduleshelp(\"modules yourstr\")#查看python中常见的topicshelp(\"topics\") #查看python标准库中的moduleimport os.path + help(\"os.path\")#查看python内置的类型help(\"list\") #查看python类型的成员方法help(\"str.find\") #查看python内置函数help(\"open\")","text":"对于初学者而言，学习一门新的编程语言，最渴求的便是遇到问题时，希望能有个帮助文档来指点迷津，pydoc就是这样一个例子，不仅仅可以帮助我们获得所需的信息，还进一步根据用户体验来在浏览器呈现帮助文档 pydoc是Python自带的模块，主要用于从python模块中自动生成文档，这些文档可以基于文本呈现的、也可以生成WEB 页面的，还可以在服务器上以浏览器的方式呈现！ 学习查看python中的帮助信息 对于Python而言，倘若我们学会查看帮助信息，便是学会了如何运用Python，接下来我们只需将Python运用自如即可 使用Python自带的Idle来查看帮助信息 使用Idle查看帮助信息，我们将会采用help()函数来查看， 1234567891011121314151617181920#查看python所有的moduleshelp(\"modules\") #单看python所有的modules中包含指定字符串的moduleshelp(\"modules yourstr\")#查看python中常见的topicshelp(\"topics\") #查看python标准库中的moduleimport os.path + help(\"os.path\")#查看python内置的类型help(\"list\") #查看python类型的成员方法help(\"str.find\") #查看python内置函数help(\"open\") 使用Windows命令行界面来查看帮助信息打开cmd，键入 python -m pydoc ,请将命令中的 替换成你需要查找的信息，例如， 将 替换成 print ，将会显示出print函数的详细信息 使用浏览器来查看Python帮助信息 Python 可以通过浏览器来查看 Python的帮助信息，不需要连网，这是我最喜爱的一种方式，不仅提升了用户体验，还更方便 打开cmd，键入 python -m pydoc -b 命令完成后，回车，等待浏览器自动打开 在输入框中键入所要查询的内容即可查询 如果想要关闭服务器，请输入 q 即可","categories":[{"name":"Python","slug":"Python","permalink":"http://sivan0222.cn/categories/Python/"},{"name":"pydoc","slug":"Python/pydoc","permalink":"http://sivan0222.cn/categories/Python/pydoc/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://sivan0222.cn/tags/Python/"},{"name":"pydoc","slug":"pydoc","permalink":"http://sivan0222.cn/tags/pydoc/"}]},{"title":"认识Python中的转义字符","slug":"认识Python中的转义字符","date":"2017-05-10T12:26:50.000Z","updated":"2017-05-10T12:47:00.171Z","comments":true,"path":"2017/05/10/认识Python中的转义字符/","link":"","permalink":"http://sivan0222.cn/2017/05/10/认识Python中的转义字符/","excerpt":"Python中的常用转义符转义符作用含义\\Backslash()反斜杠\\’Single quote(‘)单引号\\”Double-quote(“)双引号\\aASCII bell(BEL)响铃符\\bASCII backspace (BS)退格符\\fASCII formfeed(FF)进纸符\\nASCII linefeed (LF)换行符\\N{name}Character named name in the Unicode database (Unicode only)Unicode数据库中的字符名；name就是它的名字\\r ASCII Carriage Return (CR)回车符\\t ASCIIHorizontal Tab (TAB)水平制表符\\uxxxxCharacter with 16-bit hex value xxxx (Unicode only)值为16位十六进制xxxx的字符\\UxxxxxxxxCharacter with 32-bit hex value xxxxxxxx (Unicode only)值为32位十六进制xxxx的字符\\vASCII vertical tab (VT)垂直制表符\\oooCharacter with octal value ooo值为八进制ooo的字符\\xhhCharacter with hex value hh值为十六进制数hh的字符","text":"Python中的常用转义符转义符作用含义\\Backslash()反斜杠\\’Single quote(‘)单引号\\”Double-quote(“)双引号\\aASCII bell(BEL)响铃符\\bASCII backspace (BS)退格符\\fASCII formfeed(FF)进纸符\\nASCII linefeed (LF)换行符\\N{name}Character named name in the Unicode database (Unicode only)Unicode数据库中的字符名；name就是它的名字\\r ASCII Carriage Return (CR)回车符\\t ASCIIHorizontal Tab (TAB)水平制表符\\uxxxxCharacter with 16-bit hex value xxxx (Unicode only)值为16位十六进制xxxx的字符\\UxxxxxxxxCharacter with 32-bit hex value xxxxxxxx (Unicode only)值为32位十六进制xxxx的字符\\vASCII vertical tab (VT)垂直制表符\\oooCharacter with octal value ooo值为八进制ooo的字符\\xhhCharacter with hex value hh值为十六进制数hh的字符","categories":[{"name":"Python","slug":"Python","permalink":"http://sivan0222.cn/categories/Python/"},{"name":"基础","slug":"Python/基础","permalink":"http://sivan0222.cn/categories/Python/基础/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://sivan0222.cn/tags/Python/"},{"name":"语法","slug":"语法","permalink":"http://sivan0222.cn/tags/语法/"}]},{"title":"浅谈Java中的文件和编码","slug":"浅谈Java中的文件和编码","date":"2017-05-09T10:08:08.000Z","updated":"2017-05-09T14:16:19.968Z","comments":true,"path":"2017/05/09/浅谈Java中的文件和编码/","link":"","permalink":"http://sivan0222.cn/2017/05/09/浅谈Java中的文件和编码/","excerpt":"前言：许多编程语言文件操作都极其类似，Java也不尽相同，文件操作，只能获取文件（目录）的信息（名称，大小等），却不能用于文件的访问 File类讲解如何创建指定文件 我们可以使用提供的createNewFile()方法来创建给定文件名的文件，但是如果我们写文件名的时候没有写上后缀，那么创建的文件也是没有后缀的 假使我们创建一个 我爱学习.txt在E盘符下 123456789101112131415public class CreateFile &#123; public static void main(String[] args) &#123; File file = new File(\"E:\\\\我爱学习.txt\"); /*下面这行代码也可以创建指定文件*/ /* File file = new File(\"E:\",\"我爱学习.txt\"); */ /*首先判断文件是否存在*/ if(!file.exists())&#123; try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","text":"前言：许多编程语言文件操作都极其类似，Java也不尽相同，文件操作，只能获取文件（目录）的信息（名称，大小等），却不能用于文件的访问 File类讲解如何创建指定文件 我们可以使用提供的createNewFile()方法来创建给定文件名的文件，但是如果我们写文件名的时候没有写上后缀，那么创建的文件也是没有后缀的 假使我们创建一个 我爱学习.txt在E盘符下 123456789101112131415public class CreateFile &#123; public static void main(String[] args) &#123; File file = new File(\"E:\\\\我爱学习.txt\"); /*下面这行代码也可以创建指定文件*/ /* File file = new File(\"E:\",\"我爱学习.txt\"); */ /*首先判断文件是否存在*/ if(!file.exists())&#123; try &#123; file.createNewFile(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; File类中的mkdir 与 mkdirs的区别 mkdir 只能创建一个已有目录的直接子目录 mkdirs 可以创建多个目录（也就是说，倘若创建目录的时候，上一级目录不存在，上一级目录也会创建） 使用mkdir()创建一个目录 如果这里《我爱学习》目录不存在，那么就不会创建《学习也爱我》的目录 123456789public class CreateFile &#123; public static void main(String[] args) &#123; File file = new File(\"E:\\\\我爱学习\\\\学习也爱我\"); if(!file.exists())&#123; System.out.println(file.mkdir()); &#125; &#125;&#125; 使用mkdirs()创建一个目录 如果这里《我爱学习》目录不存在，那么先会自动创建《我爱学习》的目录，然后自动创建《学习也爱我》的目录123456789public class CreateFile &#123; public static void main(String[] args) &#123; File file = new File(\"E:\\\\我爱学习\\\\学习也爱我\"); if(!file.exists())&#123; System.out.println(file.mkdir()); &#125; &#125;&#125; 文件目录的遍历 这里采用递归遍历文件和目录 12345678910111213141516171819202122public class FindFile &#123; public static void main(String[] args) &#123; File file = new File(\"E:\\\\navicat\"); printYourFile(file); &#125; public static void printYourFile(File file) &#123; File[] files = file.listFiles(); for (File file2 : files) &#123; if(file2.isFile())&#123; System.out.println(file2.getAbsolutePath()); &#125;else&#123; System.out.println(file2.getAbsolutePath()); printYourFile(file2); &#125; &#125; &#125;&#125; 文件编码的问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.UnsupportedEncodingException;public class EncodeDemo &#123; public static void main(String[] args) throws Exception &#123; String s = \"简书ABC\"; byte[] bt1 = s.getBytes(); //此处将字符串转换成字节序列用的是项目默认编码gbk for(byte b: bt1)&#123; //把字节转换成了int，以16进制显示 System.out.print(Integer.toHexString(b&amp;0xff)+\" \"); //（bc f2）简（ca e9）书（41）A（42）B（43）C &#125; System.out.println(); //gbk编码，中文占用2个字节，英文占用1个字节。 byte[] bt2 = s.getBytes(\"gbk\"); for(byte b: bt2)&#123; System.out.print(Integer.toHexString(b&amp;0xff)+\" \"); //（bc f2）简（ca e9）书（41）A（42）B（43）C &#125; System.out.println(); //utf-8编码，中文占用3个字节，英文占用1个字节。 byte[] bt3 = s.getBytes(\"utf-8\"); for(byte b: bt3)&#123; System.out.print(Integer.toHexString(b&amp;0xff)+\" \"); //（e7 ae 80）简（e4 b9 a6）书（41）A（42）B（43）C &#125; System.out.println(); //java采用双字节编码，即utf-16be编码 byte[] bt4 = s.getBytes(\"utf-16be\"); //utf-16be编码，中文占用2个字节，英文占用2个字节。 for(byte b: bt4)&#123; System.out.print(Integer.toHexString(b&amp;0xff)+\" \"); //（7b 80）简（4e 66）书（0 41）A（0 42）B（0 43）C &#125; System.out.println(); /* 当字节序列使用某种编码时 此时想把字节序列转变为字符串 也需要使用这种编码形式 否则会出现乱码。 */ String str1 = new String(bt4);//此时为项目默认编码gbk System.out.println(str1);//&#123;?Nf A B C String str2 = new String(bt4,\"utf-16be\"); System.out.println(str2);//简书ABC &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"File","slug":"Java/File","permalink":"http://sivan0222.cn/categories/Java/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"File","slug":"File","permalink":"http://sivan0222.cn/tags/File/"}]},{"title":"认识线程","slug":"认识线程","date":"2017-05-08T07:10:31.000Z","updated":"2017-05-09T10:10:28.740Z","comments":true,"path":"2017/05/08/认识线程/","link":"","permalink":"http://sivan0222.cn/2017/05/08/认识线程/","excerpt":"早期的操作系统，建立在了所谓的cpu，存储器，IO设备之上，但是最为宝贵的便是cpu，计算机发展至今，硬盘已经从几M发展到现在的几TB，cpu仍在不紧不慢发展，作为计算机的大脑，cpu可谓肩负重任，早期的操作系统，由于系统的缺陷，cpu只能运行单道作业，如果要等待IO，便会一直等下去，直到我们使用完IO之后，才会响应，这便是所谓的单道作业的缺陷！ 随着操作系统发展，我们将cpu分的越来越详细，从最初的一个程序–&gt;作业–&gt;进程–&gt;线程，个人认为是由于cpu的发展跟不上我们的需求，才会促使我们将cpu更为紧细的利用，直到现在的多核多线程，我们便开始专心研究多线程，以提高任务效率，而不是促使我们的应用程序崩溃！ 线程 线程来源于一个进程，但是由于进程切换开销大，为了提高cpu的利用率，所以我们便将单个进程分为多个线程，多个线程可以并发或者并行运行，各线程在运行过程中会因为访问共享数据及等待数据而发生互斥与同步的关系多线程可以使程序反应更快，交互性更强，执行效率更高 创建一个线程 Java中的程序，我们通常从main方法开始执行，jvm便会给main创建一个线程，从上到下开始执行main方法当Java程序作为applet开始运行的时候，web浏览器便会启动一个线程来运行applet 实现Runnable接口 通常我们采用该方法来实现多线程 实现Runnable接口以及相应的run方法 创建一个Thread，并分配任务给Thread 调用Thread实例的start方法开启线程（不可以调用run方法，如果调用，只是在当前线程执行run方法，并不会产生多线程）","text":"早期的操作系统，建立在了所谓的cpu，存储器，IO设备之上，但是最为宝贵的便是cpu，计算机发展至今，硬盘已经从几M发展到现在的几TB，cpu仍在不紧不慢发展，作为计算机的大脑，cpu可谓肩负重任，早期的操作系统，由于系统的缺陷，cpu只能运行单道作业，如果要等待IO，便会一直等下去，直到我们使用完IO之后，才会响应，这便是所谓的单道作业的缺陷！ 随着操作系统发展，我们将cpu分的越来越详细，从最初的一个程序–&gt;作业–&gt;进程–&gt;线程，个人认为是由于cpu的发展跟不上我们的需求，才会促使我们将cpu更为紧细的利用，直到现在的多核多线程，我们便开始专心研究多线程，以提高任务效率，而不是促使我们的应用程序崩溃！ 线程 线程来源于一个进程，但是由于进程切换开销大，为了提高cpu的利用率，所以我们便将单个进程分为多个线程，多个线程可以并发或者并行运行，各线程在运行过程中会因为访问共享数据及等待数据而发生互斥与同步的关系多线程可以使程序反应更快，交互性更强，执行效率更高 创建一个线程 Java中的程序，我们通常从main方法开始执行，jvm便会给main创建一个线程，从上到下开始执行main方法当Java程序作为applet开始运行的时候，web浏览器便会启动一个线程来运行applet 实现Runnable接口 通常我们采用该方法来实现多线程 实现Runnable接口以及相应的run方法 创建一个Thread，并分配任务给Thread 调用Thread实例的start方法开启线程（不可以调用run方法，如果调用，只是在当前线程执行run方法，并不会产生多线程） 1234567891011121314151617181920212223242526272829public class Test implements Runnable&#123;public static void main(String[] args) &#123; Test test = new Test(); Thread thread = new Thread(test); thread.start();&#125;/*这里的run方法指明如何完成这个任务，如果使用新线程来执行，Java虚拟机会自动调用该方法*/@Overridepublic void run() &#123; while(true)&#123; Date date = new Date(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); String date1 = sdf.format(date); System.out.println(date1); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;&#125; 继承Thread 由于JAVA是单继承，我们经常不使用该方法来实现多线程，并且继承Thread，会让我们将任务和运行任务的机制混在了一起 继承Thread 重写run方法 使用当前类的实例调用start方法 1234567891011121314151617181920212223public class Test extends Thread&#123;public static void main(String[] args) &#123; Test test = new Test(); test.start(); while(true)&#123; System.out.println(new Date()); &#125;&#125;@Overridepublic void run() &#123; while(true)&#123; System.out.println(\"A\"); &#125;&#125;&#125; 错误的使用sleep方法 sleep()方法将会让调用该方法的线程进入休眠状态，因此如果我们错误的使用该方法，将会影响程序的健壮性！！！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Third implements Runnable&#123;@Overridepublic void run() &#123; for(int i = 0; i &lt; 100; i++)&#123; System.out.println(\"A\"); &#125; try &#123; /*当一个休眠线程的interrupte()被调用，就会产生这样一个异常*/ Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; /** * 使用这种方法来抛出异常是错误的 */ try&#123; while(true)&#123; Thread.sleep(1000); &#125; &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; /** * 使用这种方法来抛出异常是正确的 */ while( true )&#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125;&#125; 由于使用stop()，以及suspend()，resume()，存在不安全因素，现在的JDK并不提倡使用这些方法，为了替代stop()方法，我们可以通过给Thread变量赋值null来终止当前线程 使用yield()方法为其他线程让出cpu时间 yield()方法可以为其他线程临时让出cpu时间，对于可能出现死锁的程序，我们可以使用该方法来避免 1234567891011121314151617181920212223242526272829public class Test2 implements Runnable&#123;public static void main(String[] args) &#123; Test2 test = new Test2(); Thread thread = new Thread(test); thread.start(); Test2 test1 = new Test2(); Thread thread1 = new Thread(test1); thread1.start(); /*设置thread1线程的优先级最高，因为JVM总是从优先级最高的线程开始执行 */ thread1.setPriority(Thread.MAX_PRIORITY);&#125;@Overridepublic void run() &#123; while(true)&#123; /*输出当前执行的线程的ID*/ System.out.println(Thread.currentThread().getId()); /*为其他线程临时让出CPU时间*/ Thread.yield(); &#125;&#125;&#125; 线程优先级 众所周知，cpu在线程中采用时间片轮转算法，JVM也是如此，将会执行优先级最高的线程，较低的优先级会使得当前线程再有在没有比它优先级更高的线程的时候才会执行，如果优先级相同，系统会将线程排到一个循环队列中等待，然后进行cpu调度，一个一个开始执行 资源竞争（缺乏状态） 如果总有一个优先级较高的线程在运行，或者有一个相同优先级的程序不愿意退出，那么这个线程可能永远也没有运行的机会，称为资源竞争 避免方法（给低优先级或者相同优先级的线程一个运行程序的机会） 调用线程的yield方法，可以使得线程临时让出cpu资源 调用线程的sleep方法 闪烁文本动画的设置 定时器和一个线程都可以控制动画，但是使用定时器（一个源组件，以“固定的速率触发一个ActionEvent时间，发生动作时间，定时器会调用监听器的actionPersormed方法来处理这个事件，定时器和事件处理都处于同一事件分发线程上”） 如果处理这个事件需要花费很长时间，那么两个事件之间真正的延时时间将比请求延时时间更长，这种情况下，萤爱在一个独立的线程上运行事件处理 通常，线程比定时器更加可靠，响应速度更快，如果需要精确的延迟时间或者快速相应，最好使用线程，否则，使用定时器会比线程更加简单，也更加有效，因为定时器运行在GUI事件分发线程上，所以，定时器比线程占用的系统资源少，故而不需要为定时器创建新线程 123456789101112131415161718192021222324252627public class FlashingText extends JApplet implements Runnable&#123; private JLabel label = new JLabel(\"Welcome\", JLabel.CENTER); public FlashingText() &#123; add(label); new Thread(this).start(); &#125; @Override public void run() &#123; try&#123; while(true)&#123; if(label.getText() == null) label.setText(\"Welcome\"); else label.setText(null); &#125; &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"线程","slug":"Java/线程","permalink":"http://sivan0222.cn/categories/Java/线程/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"线程","slug":"线程","permalink":"http://sivan0222.cn/tags/线程/"}]},{"title":"JTable表头，表数据居中以及关键字查找和分页","slug":"JTable表头，表数据居中以及关键字查找和分页","date":"2017-05-05T01:19:37.000Z","updated":"2017-05-09T10:13:50.252Z","comments":true,"path":"2017/05/05/JTable表头，表数据居中以及关键字查找和分页/","link":"","permalink":"http://sivan0222.cn/2017/05/05/JTable表头，表数据居中以及关键字查找和分页/","excerpt":"JTable 设置表头居中 通过表格默认的渲染器和引用JLabel的center来使得表头居中 1((DefaultTableCellRenderer)table.getTableHeader().getDefaultRenderer()).setHorizontalAlignment(JLabel.CENTER); JTable 设置表数据居中 有时我们需要让表格数据居中显示，而不是默认的左对齐，可以给用户一个更好的体验！ 123DefaultTableCellRenderer renderer=new DefaultTableCellRenderer();renderer.setHorizontalAlignment(DefaultTableCellRenderer.CENTER);table.setDefaultRenderer(Object.class, renderer);","text":"JTable 设置表头居中 通过表格默认的渲染器和引用JLabel的center来使得表头居中 1((DefaultTableCellRenderer)table.getTableHeader().getDefaultRenderer()).setHorizontalAlignment(JLabel.CENTER); JTable 设置表数据居中 有时我们需要让表格数据居中显示，而不是默认的左对齐，可以给用户一个更好的体验！ 123DefaultTableCellRenderer renderer=new DefaultTableCellRenderer();renderer.setHorizontalAlignment(DefaultTableCellRenderer.CENTER);table.setDefaultRenderer(Object.class, renderer); JTable 设置表头不可重排序 当我们使用JTable控件，发现如果移动一个表头到另一个表头处，也是可以的，如果我们不想要这种效果，便可以执行如下代码 1table.getTableHeader().setReorderingAllowed(false); JTable 设置表格内容不可编辑 我们使用JTable,有时只是为了展示一个关系给用户，并不希望用户可以编辑，但是我们使用JTable,只要点击表格一处内容就可以让用户编辑，因此可以执行如下代码 在我们新建表格的时候实现 isCellEditable方法便可以12345private JTable table = new JTable()&#123; public boolean isCellEditable(int row, int column) &#123; return false; &#125;; &#125;; JTable 设置表格行高1table.setRowHeight(30); //设置表格行高为30px JTable 实现表格的排序以及关键字查找 对于表格，经常需要我们去进行排序和关键字的查找 排序 设置表格的表模型，并设置表格的setRowSorter(JDK1.6出现，用于对JTable实现排序和过滤，此方法清除该选择并重置所有可变行高度) 使用setRowSorter实现的是表格粗粒度排序，也就是通过将每行每一列内容转换成字符串进行排序， 1table.setRowSorter(sorter); 过滤（关键字查找） 对于数据量大的表格我们经常通过关键字来进行查找，这里使用了Java中的RowFilter用于从表格模型中过滤条目，对于不满足关键字的将不会显示在表格当中RowFilter 与 JTable 相关联，一个条目对应于JTable的一行记录 首先要产生一个文本框（输入要查询的内容，） 设置表格的模型以及setRowSorter() 设置sorter的setRowFilter,用于实现文本过滤 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123import java.awt.BorderLayout;import java.awt.Dimension;import java.awt.EventQueue;import java.awt.Font;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.WindowAdapter;import java.awt.event.WindowEvent;import javax.swing.JButton;import javax.swing.JFrame;import javax.swing.JLabel;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTable;import javax.swing.JTextField;import javax.swing.RowFilter;import javax.swing.UIManager;import javax.swing.border.EmptyBorder;import javax.swing.table.DefaultTableModel;import javax.swing.table.JTableHeader;import javax.swing.table.TableModel;import javax.swing.table.TableRowSorter;public class SearchTable extends JFrame &#123; /** * */ private static final long serialVersionUID = -3619887890741475524L; private JPanel contentPane; private JTable table; private JTextField textField; private TableRowSorter&lt;TableModel&gt; sorter = new TableRowSorter&lt;TableModel&gt;();; /** * Launch the application. */ public static void main(String[] args) &#123; try &#123; UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel\"); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; try &#123; SearchTable frame = new SearchTable(); frame.setVisible(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; /** * Create the frame. */ public SearchTable() &#123; addWindowListener(new WindowAdapter() &#123; @Override public void windowActivated(WindowEvent e) &#123; do_this_windowActivated(e); &#125; &#125;); setTitle(\"\\u652F\\u6301\\u67E5\\u627E\\u529F\\u80FD\\u7684\\u8868\\u683C\"); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); setBounds(100, 100, 450, 300); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); contentPane.setLayout(new BorderLayout(0, 0)); setContentPane(contentPane); JPanel panel = new JPanel(); contentPane.add(panel, BorderLayout.NORTH); JLabel label = new JLabel(\"\\u5173\\u952E\\u5B57\\uFF1A\"); label.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); panel.add(label); textField = new JTextField(); textField.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); panel.add(textField); textField.setColumns(20); JPanel buttonPanel = new JPanel(); contentPane.add(buttonPanel, BorderLayout.SOUTH); JButton button = new JButton(\"\\u67E5\\u627E\"); button.addActionListener(new ActionListener() &#123; public void actionPerformed(ActionEvent e) &#123; sorter.setRowFilter(RowFilter.regexFilter(textField.getText())); &#125; &#125;); button.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); buttonPanel.add(button); JScrollPane scrollPane = new JScrollPane(); contentPane.add(scrollPane, BorderLayout.CENTER); table = new JTable(); table.setFont(new Font(\"微软雅黑\", Font.PLAIN, 14)); table.setRowHeight(30); JTableHeader header = table.getTableHeader(); header.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); header.setPreferredSize(new Dimension(header.getWidth(), 35)); scrollPane.setViewportView(table); &#125; protected void do_this_windowActivated(WindowEvent e) &#123; DefaultTableModel tableModel = (DefaultTableModel) table.getModel(); tableModel.setRowCount(0); tableModel.setColumnIdentifiers(new Object[] &#123; \"书名\", \"出版社\", \"出版时间\", \"丛书类别\", \"定价\" &#125;); tableModel.addRow(new Object[] &#123; \"Java从入门到精通（第2版）\", \"清华大学出版社\", \"2010-07-01\", \"软件工程师入门丛书\", \"59.8元\" &#125;); tableModel.addRow(new Object[] &#123; \"PHP从入门到精通（第2版）\", \"清华大学出版社\", \"2010-07-01\", \"软件工程师入门丛书\", \"69.8元\" &#125;); tableModel.addRow(new Object[] &#123; \"Visual Basic从入门到精通（第2版）\", \"清华大学出版社\", \"2010-07-01\", \"软件工程师入门丛书\", \"69.8元\" &#125;); tableModel.addRow(new Object[] &#123; \"Visual C++从入门到精通（第2版）\", \"清华大学出版社\", \"2010-07-01\", \"软件工程师入门丛书\", \"69.8元\" &#125;); sorter.setModel(tableModel); table.setRowSorter(sorter); &#125;&#125; 实现表格的分页 对于数据量大的表格，我们不仅仅需要查找和过滤，更需要我们实现表格的分页，对于如何分页，这里实现了表格分页的一个小算法 思路： 得到数据总数 得到所需页数 = Math.ceil（数据总数 / 每页计划存放的数据数） 显示当前页数，编写首页，上一页，当前页数，下一页，最后一页的监听事件如果用户不输入当期页数，则就显示当前页数，如果输入了一个页数则实现跳转（需要进行判断页数是否合法）如果用户点击首页，跳转到首页如果用户点击上一页，则需要判断是否存在上一页，如果存在则跳转如果用户点击下一页，下一页存在，如果是最后一页显示剩余的数据，如果不是，显示该页的15条记录；下一页不存在，告诉用户已经是最后一页如果用户点击最后一页，跳转到最后一页 数据需要用户自己进行添加，每页显示15行数据，如果用户需要，可以进行更改 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337import java.awt.BorderLayout;import java.awt.Dimension;import java.awt.EventQueue;import java.awt.Font;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;import java.awt.event.KeyAdapter;import java.awt.event.KeyEvent;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Vector;import java.util.regex.Matcher;import java.util.regex.Pattern;import javax.swing.JButton;import javax.swing.JComboBox;import javax.swing.JDialog;import javax.swing.JLabel;import javax.swing.JOptionPane;import javax.swing.JPanel;import javax.swing.JScrollPane;import javax.swing.JTable;import javax.swing.JTextField;import javax.swing.RowFilter;import javax.swing.UIManager;import javax.swing.border.EmptyBorder;import javax.swing.table.DefaultTableCellRenderer;import javax.swing.table.DefaultTableModel;import javax.swing.table.JTableHeader;import javax.swing.table.TableModel;import javax.swing.table.TableRowSorter;/** * * @author SiVan * @time 2017年4月23日 下午7:13:18 * TODO 实现表格分页 */public class QueryPurchase extends JDialog &#123;private static final long serialVersionUID = -3619887890741475524L; private JPanel contentPane; /*新建一个表格并设置表格内容不可以编辑*/ private JTable table = new JTable()&#123; public boolean isCellEditable(int row, int column) &#123; return false; &#125;;&#125;; private JTextField textField; private TableRowSorter&lt;TableModel&gt; sorter = new TableRowSorter&lt;TableModel&gt;();; Vector&lt;String&gt; header ;private String url = \"jdbc:mysql://localhost:3306/erp\";private String user = \"root\";private String password = \"1018222wxw\";Vector&lt;Vector&lt;String&gt;&gt; dataVector; /*存放所有数据*/JTextField text; /*显示当前页数*/Vector&lt;Vector&lt;String&gt;&gt; data; /*存放所要显示的每一页的数据*/int n = 0; /*得到数据总数*/ /** * Launch the application. */ public static void main(String[] args) &#123; try &#123; UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.nimbus.NimbusLookAndFeel\"); &#125; catch (Throwable e) &#123; e.printStackTrace(); &#125; EventQueue.invokeLater(new Runnable() &#123; public void run() &#123; try &#123; QueryPurchase frame = new QueryPurchase(); frame.setVisible(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125; /** * Create the frame. */ public QueryPurchase() &#123; header = new Vector&lt;String&gt;(); header.add(\"进货编号\"); header.add(\"供应商名称\"); header.add(\"花盆编号\"); header.add(\"花盆名称\"); header.add(\"联系人\"); header.add(\"数量\"); header.add(\"单价\"); header.add(\"总价\"); header.add(\"进货时间\"); data = new Vector&lt;Vector&lt;String&gt;&gt;(); dataVector = new Vector&lt;Vector&lt;String&gt;&gt;(); text = new JTextField(); /*显示当前页数*/ /* 对于初次添加的数据，需要判断数据是否填充满第一页，如果填充满则第一页显示15条记录， 反之显示用户所添加的记录数目 */ if(n / 15 &gt;= 1)&#123; for (int i = 0; i &lt; 15; i++) &#123; data.add(dataVector.get(i)); &#125; &#125;else&#123; for (int i = 0; i &lt; n % 15; i++) &#123; data.add(dataVector.get(i)); &#125; &#125; final DefaultTableModel model = new DefaultTableModel(data,header); table.setModel(model); sorter.setModel(model); table.setRowSorter(sorter); textField = new JTextField(); textField.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); textField.addKeyListener(new KeyAdapter() &#123; @Override public void keyReleased(KeyEvent e) &#123; sorter.setRowFilter(RowFilter.regexFilter(textField.getText())); &#125; &#125;); this.setSize(1000, 650); this.setLocationRelativeTo(null); contentPane = new JPanel(); contentPane.setBorder(new EmptyBorder(5, 5, 5, 5)); contentPane.setLayout(new BorderLayout(0, 0)); setContentPane(contentPane); JPanel panel = new JPanel(); contentPane.add(panel, BorderLayout.NORTH); JLabel label = new JLabel(\"\\u5173\\u952E\\u5B57\\uFF1A\"); label.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); panel.add(label); panel.add(textField); textField.setColumns(20); JPanel buttonPanel = new JPanel(); contentPane.add(buttonPanel, BorderLayout.SOUTH); JButton first = new JButton(\"首页\"); JButton previous = new JButton(\"上一页\"); JButton next = new JButton(\"下一页\"); JButton last = new JButton(\"尾页\"); JLabel page = new JLabel(\"当前页数:\"); ((DefaultTableCellRenderer)table.getTableHeader().getDefaultRenderer()).setHorizontalAlignment(JLabel.CENTER); first.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; text.setText(\"1\"); data.removeAllElements(); if(n / 15 &gt;= 1)&#123; for (int i = 0; i &lt; 15; i++) &#123; data.add(dataVector.get(i)); &#125; &#125;else&#123; for (int i = 0; i &lt; n%15; i++) &#123; data.add(dataVector.get(i)); &#125; &#125; DefaultTableModel model = new DefaultTableModel(data,header); table.setModel(model); &#125; &#125;); previous.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; String page = text.getText(); if(\"1\".equals(page))&#123; JOptionPane.showMessageDialog(null, \"对不起，现在已经是首页了\"); return; &#125; int k = Integer.parseInt(page); text.setText(k - 1 + \"\"); data.removeAllElements(); for (int i = (k - 2) * 15; i &lt; (k - 2) * 5 + 15; i++) &#123; data.add(dataVector.get(i)); &#125; DefaultTableModel model = new DefaultTableModel(data,header); table.setModel(model); &#125; &#125;); next.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; int page = Integer.parseInt(text.getText()); int k = n % 15; if(k == 0)&#123; if(page == n / 15)&#123; JOptionPane.showMessageDialog(null, \"已经是最后一页了\"); return; &#125; &#125;else&#123; if(page == n / 15 + 1) &#123; JOptionPane.showMessageDialog(null, \"已经是最后一页了\"); return; &#125; if(!(page == n / 15 ))&#123; k = 15; &#125; text.setText(page + 1 + \"\"); &#125; data.removeAllElements(); for (int i = page * 15; i &lt; page * 15 + k; i++) &#123; data.add(dataVector.get(i)); &#125; DefaultTableModel model = new DefaultTableModel(data,header); table.setModel(model); &#125; &#125;); last.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; int k = n % 15; data.removeAllElements(); for(int i = n - k ; i &lt;= n - 1; i++)&#123; data.add(dataVector.get(i)); &#125; DefaultTableModel model = new DefaultTableModel(data,header); table.setModel(model); &#125; &#125;); text.addKeyListener(new KeyAdapter() &#123; @Override public void keyReleased(KeyEvent e) &#123; int k = n % 15; int page = 0; try&#123; page = Integer.parseInt(text.getText()); &#125;catch(Exception e1)&#123; JOptionPane.showMessageDialog(null, \"请注意页数格式\"); e1.printStackTrace(); return; &#125; if(page &lt; 1)&#123; JOptionPane.showMessageDialog(null, \"页数非法\"); return; &#125; if(k == 0)&#123; if( page &gt; n/15)&#123; JOptionPane.showMessageDialog(null, \"页数非法\"); return; &#125; k = 15; &#125;else&#123; if( page &gt; n/15 + 1)&#123; JOptionPane.showMessageDialog(null, \"页数非法\"); return; &#125; if( page &lt; n/15 + 1)&#123; k = 15; &#125; &#125; data.removeAllElements(); for(int i = (page - 1) * 15 ; i &lt; (page - 1) * 15 + k; i++)&#123; data.add(dataVector.get(i)); &#125; DefaultTableModel model = new DefaultTableModel(data,header); table.setModel(model); &#125; &#125;); first.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); previous.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); next.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); last.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); page.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); text.setColumns(5); buttonPanel.add(first); buttonPanel.add(previous); buttonPanel.add(page); buttonPanel.add(text); buttonPanel.add(next); buttonPanel.add(last); JScrollPane scrollPane = new JScrollPane(); contentPane.add(scrollPane, BorderLayout.CENTER); /*设置表头不可重排序*/ table.getTableHeader().setReorderingAllowed(false); /*设置表格字体*/ table.setFont(new Font(\"微软雅黑\", Font.PLAIN, 14)); /*设置表格行高*/ table.setRowHeight(30); /*设置表数据居中*/ DefaultTableCellRenderer renderer=new DefaultTableCellRenderer(); renderer.setHorizontalAlignment(DefaultTableCellRenderer.CENTER); table.setDefaultRenderer(Object.class, renderer); /*设置表头的字体以及宽度高度*/ JTableHeader header1 = table.getTableHeader(); header1.setFont(new Font(\"微软雅黑\", Font.PLAIN, 16)); header1.setPreferredSize(new Dimension(header1.getWidth(), 35)); scrollPane.setViewportView(table); this.setVisible(true); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"Swing","slug":"Java/Swing","permalink":"http://sivan0222.cn/categories/Java/Swing/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"JTable","slug":"JTable","permalink":"http://sivan0222.cn/tags/JTable/"}]},{"title":"Swing窗体取消标题如何拖动","slug":"Swing窗体取消标题如何拖动","date":"2017-05-05T00:24:13.000Z","updated":"2017-05-09T10:13:55.216Z","comments":true,"path":"2017/05/05/Swing窗体取消标题如何拖动/","link":"","permalink":"http://sivan0222.cn/2017/05/05/Swing窗体取消标题如何拖动/","excerpt":"众所周知，swing中的窗体默认提供了边框以及标题栏，但是我们设置undecorated为true之后，不会使用Swing中的窗体来修饰，但是默认窗体也将不会随着鼠标的拖动而移动，因此我们需要给我们自己窗体添加一个随着鼠标移动而移动的事件 添加鼠标监听器事件 窗体移动默认都是鼠标按下之后，鼠标开始移动，窗体也会跟着鼠标开始移动！鼠标移动之前，我们需要记录按下鼠标时相对于窗体的位置，因为移动将不会改变鼠标相对于窗体的位置 123456frame.addMouseListener(new MouseAdapter() &#123; @Override public void mousePressed(MouseEvent e) &#123; pressedPoint = e.getPoint();/*记录鼠标相对于窗体坐标*/ &#125; &#125;);","text":"众所周知，swing中的窗体默认提供了边框以及标题栏，但是我们设置undecorated为true之后，不会使用Swing中的窗体来修饰，但是默认窗体也将不会随着鼠标的拖动而移动，因此我们需要给我们自己窗体添加一个随着鼠标移动而移动的事件 添加鼠标监听器事件 窗体移动默认都是鼠标按下之后，鼠标开始移动，窗体也会跟着鼠标开始移动！鼠标移动之前，我们需要记录按下鼠标时相对于窗体的位置，因为移动将不会改变鼠标相对于窗体的位置 123456frame.addMouseListener(new MouseAdapter() &#123; @Override public void mousePressed(MouseEvent e) &#123; pressedPoint = e.getPoint();/*记录鼠标相对于窗体坐标*/ &#125; &#125;); 添加鼠标侦听器事件 窗体移动是一个实时的事件，并且将会持续一个过程，java为我们提供了一个鼠标侦听器事件的监听器，我们只需要实现侦听器就可以实现窗体跟随鼠标拖动而移动 让窗体移动的思路 记录下来按下鼠标的时候，鼠标相对于窗体的位置 记录窗体位置，鼠标移动了之后，鼠标相对于窗体位置并不会改变，但是在移动过程中，窗体位置将不会改变，鼠标相对于窗体位置会不断改变，因此我们只需要通过 窗体位置（不会动） + 移动过程中鼠标相对于窗体位置的坐标（移动过程中会动） - 鼠标相对于窗体的位置（按下鼠标的时候，不会动） = 窗体移动后的位置 1234567891011/*设置窗体移动*/ frame.addMouseMotionListener(new MouseMotionAdapter() &#123; @Override public void mouseDragged(MouseEvent e) &#123; Point point = e.getPoint(); /*获取当前坐标,得到的是鼠标位置相对于窗体的坐标*/ Point locationPoint = frame.getLocation();/*获取窗体坐标*/ int x = locationPoint.x + point.x - pressedPoint.x;/* 计算移动后的新坐标*/ int y = locationPoint.y + point.y - pressedPoint.y; frame.setLocation(x, y);/*改变窗体位置*/ &#125; &#125;);","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"Swing","slug":"Java/Swing","permalink":"http://sivan0222.cn/categories/Java/Swing/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"Swing","slug":"Swing","permalink":"http://sivan0222.cn/tags/Swing/"}]},{"title":"泛型","slug":"泛型","date":"2017-03-22T02:56:28.000Z","updated":"2017-05-09T10:10:56.679Z","comments":true,"path":"2017/03/22/泛型/","link":"","permalink":"http://sivan0222.cn/2017/03/22/泛型/","excerpt":"前言：泛型是JDK1.5开始，Java便允许定义泛型类，泛型接口，泛型方法。可以使用泛型对API中一些接口和类进行修改。 JDK1.5之前的java.lang.Comparable 1234package java.lang;public interface Comparable&#123; public int compareTo(Object o)&#125;","text":"前言：泛型是JDK1.5开始，Java便允许定义泛型类，泛型接口，泛型方法。可以使用泛型对API中一些接口和类进行修改。 JDK1.5之前的java.lang.Comparable 1234package java.lang;public interface Comparable&#123; public int compareTo(Object o)&#125; JDK1.5的java.lang.Comparable1234package java.lang;public interface Comparable&lt;T&gt;&#123; public int compareTo(T o)&#125; 泛型（参数化类型的能力） 从形式泛型类型转换为实际具体类型 称为泛型实例化 1List&lt;T&gt; --&gt; List&lt;Integer&gt; 泛型的优点： 使用泛型的主要优点是：能够在编译时而不是在运行时检查出错误，泛型类或方法规定了用户在使用这些类或方法的对象类型，如果我们使用了一个不兼容的类型，编译器就会检测出这个错误。同时使用泛型，我们可以保证软件的可靠性和可读性，保证了程序不是运行时产生错误，而是编译时产生错误。 1.例子一： 12345678public static void main(String[] args) &#123; Comparable c = new Date(); System.out.println(c.compareTo(\"Red\")); /* 曝出异常 ClassCastException: java.lang.String cannot be cast to java.util.Date */ &#125; 原因分析：这样的代码会产生运行错误，因为一个字符串和一个日期时间比较，显而易见会存在异常 2.例子二： 1234public static void main(String[] args) &#123; Comparable&lt;Date&gt; c = new Date(); System.out.println(c.compareTo(\"red\"));&#125; 对比两个例子代码，很明显泛型可以保证程序的健壮性，如果我们不适用泛型，默认泛型是Object，但是在转换就有很多弊端，很有可能就会曝出异常！ 泛型类12345678910111213141516171819202122 /*使用泛型方法要将泛型放到方法名后面*/public class GenericStack&lt;E1,E2&gt; &#123; public GenericStack() &#123; /*构造方法仍然这样写*/ &#125; public &lt;E1,E2&gt; void add()&#123; /*使用泛型方法要将泛型放到返回类型前面*/ &#125; public static void main(String[] args) &#123; GenericStack&lt;String, Integer&gt; gen = new GenericStack&lt;String,Integer&gt;(); gen.&lt;String, Integer&gt;add(); /*调用泛型方法，需要将实际类型放到尖括号内并作为方法名的前缀*/ &#125; /*将泛型指定为另外一种类型的子类型，被成为受限的泛型类型*/ public static &lt;E extends Object&gt; boolean isNull() &#123; return false; &#125;&#125; 泛型类 原始类型和向后兼容 原始类型：不使用类型参数的泛型类 Java允许使用原始类型向后兼容，但是原始类型并不安全，更好的方法是使用泛型 12345678910public class Max &#123; public static Comparable max(Comparable o1, Comparable o2) &#123; if(o1.compareTo(o2) &gt; 0) return o1; else return 02; &#125;&#125;/*如果我们调用方法Max.max(\"welcome\",23) 便会产生一个错误，因此不建议使用原始类型*/ 通配泛型1.为什么使用通配泛型？ 代码1： 12345678910111213141516171819202122232425public class WildCardDemo1 &#123; public static void main(String[] args) &#123; GenericStack&lt;Integer&gt; intStack = new GenericStack&lt;Integer&gt;(); intStack.push(1); intStack.push(2); intStack.push(-2); System.out.print(\"The max number is \" + max(intStack)); &#125; public static double max(GenericStack&lt;Number&gt; stack) &#123; double max = stack.pop().doubleValue(); while(!stack.isEmpty()) &#123; double value = stack.pop().doubleValue(); if(value &gt; max) max = value; &#125; return max; &#125;&#125;/*分析：第8行会出现编译错误，最开始自己也没想通，所以就拿来这道题目来作例题，*//*因为intStack不是GenericStack&lt;Number&gt;的实例*/ 为了避免上面例子中的问题，我们采用通配泛型类型，通配泛型类型有三种： ? ? Extends T 表示T或T的一个未知子类型 ? super T（其中T是某个泛型类型），表示T或T的一个未知父类型 第一种称为非受限通配， 第二三种称为受限通配，也叫下限通配 将max方法修改成public static double max(GenericStack? Extends Number&gt; Stack)便可以解决问题，其中? Extends Number 表示Number或者Number子类型的通配类型 代码2： 思考以下代码是否正确？ 12345678910111213141516public class WildCardDemo2 &#123; public static void main(String[] args) &#123; GenericStack&lt;Integer&gt; intStack = new GenericStack&lt;Integer&gt;(); intStack.push(1); intStack.push(2); intStack.push(-2); print(intStack); &#125; public static void print(GenericStack&lt;Object&gt; stack) &#123; while(!stack.isEmpty()) System.out.println(stack.pop() + \" \"); &#125;&#125; 上面代码是不合法的，尽管我们的stack的泛型类型是?（等价于&lt;? Extends Object&gt;） 我们intStack的泛型类型是Integer，但是如果调用print(intStack)将会报错，因为GenericStack并不是GenericStack的子类型，所以我们需要使用&lt;? super T&gt;通配符 泛型注意事项 泛型类型必须是引用类型，不可以使用基本数据类型来进行替换 泛型类中，构造方法不需要加上泛型 泛型类有多个参数的时候，我们需要","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"泛型","slug":"Java/泛型","permalink":"http://sivan0222.cn/categories/Java/泛型/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"泛型","slug":"泛型","permalink":"http://sivan0222.cn/tags/泛型/"}]},{"title":"Eclipse工具讲解（中文语言包的安装，活用workspace，添加新的JDK环境）","slug":"Eclipse","date":"2017-03-17T02:55:40.000Z","updated":"2017-05-05T04:18:29.979Z","comments":true,"path":"2017/03/17/Eclipse/","link":"","permalink":"http://sivan0222.cn/2017/03/17/Eclipse/","excerpt":"中文语言包的安装准备工作 安装好的Eclipse，可以去网上下载，免费，下载Eclipse 有网络环境","text":"中文语言包的安装准备工作 安装好的Eclipse，可以去网上下载，免费，下载Eclipse 有网络环境 下载中文语言包 进入语言包下载 找到自己所对应的Eclipse版本，并且点击，进入语言包界面 找到Language: Chinese (Simplified) 栏目 下载该栏目下所有文件 解压缩中文语言包 将所下载的压缩包解压到一个文件中 解压后的文件有两个子目录，features 和 plugins ，复制到Eclipse的安装目录，提示是否覆盖，选择是，打开Eclipse即可看到中文界面的Eclipse 添加新的JDK环境 Eclipse的成功运行需要Java运行环境的支持，才能够启动运行，并且Eclipse启动后，会把当前Java执行环境当作Eclipse的默认开发环境 选择 Window–&gt;Preferences–&gt;Java选项卡–&gt;Installed JREs –&gt;Add 选择 Standard VM 弹出的新界面，点击Directory，找到JDK安装路径，点击finish 注意：这里也可以点击 Variables 设置JRE环境的内存参数，在缺省VM参数的编辑框，写入 “-xmx200M”参数就可以为虚拟机添加内存，可以避免大型应用程序因为内存不足而无法运行 为项目添加类库 一个大型项目的开发，需要几个或多个JAR文件的支持，比如数据库连接的类库等等 构建路径就是把各个类库设置到CLASSPATH类路径当中，是一个环境变量，这样，在编译源文件时才能够找到引用的其他JAR文件中的API 方法一：自己新建一个文件夹 lib ，然后把所有用到的JAR文件复制粘贴过来 方法二： 对于重复使用的类库，不需要每次添加，直接添加到用户的类库中就可以 选择Window –&gt; Preferences–&gt; Java –&gt; Build Path –&gt; user libraries 选择import ，点击自己所存放类库的位置就可以 安装界面设计器（WindowBuilder插件） 由于Java Swing开发桌面应用程序比较灵活，由于API众多，因此开发难度增大，而且Swing为了实现跨平台的应用程序，使得程序员不得不边运行程序，边进行界面设计，因此这里介绍一个插件，帮助大家快速开发桌面应用程序 离线安装 进入 WindowBuilder下载界面 找到对应版本的Eclipse，选择 Release Version下的 Zipped Update Site （离线安装） 将压缩包中的文件解压，并覆盖Eclipse文件夹下的同名文件夹 在线安装 进入 WindowBuilder下载界面 找到对应版本的Eclipse，选择 Release Version下的Update Site 的link选项，点击，复制进入新界面的网址 打开Eclipse 点击 Help–&gt;Install new software–&gt; Add –&gt;输入名称（WindowBuilder），输入位置 （把复制的网址粘贴） 点击确定，然后选择出来的WindowBuilder，然后一路next","categories":[{"name":"Tools","slug":"Tools","permalink":"http://sivan0222.cn/categories/Tools/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","permalink":"http://sivan0222.cn/tags/Eclipse/"},{"name":"Tools","slug":"Tools","permalink":"http://sivan0222.cn/tags/Tools/"}]},{"title":"文件输入输出流","slug":"文件输入输出流","date":"2017-03-09T02:56:49.000Z","updated":"2017-05-09T10:11:33.376Z","comments":true,"path":"2017/03/09/文件输入输出流/","link":"","permalink":"http://sivan0222.cn/2017/03/09/文件输入输出流/","excerpt":"文本输入输出流–Scanner和PrintWriter–输入和输出针对Java虚拟机而言 PrintWriter输出流 使用PrintWriter可以创建一个文本文件，并且向文本文件写入数据 使用PrintWriter后，必须使用关闭输出流，可以手动也可以自动关闭，不关闭会导致数据不能正确的保存在文件中","text":"文本输入输出流–Scanner和PrintWriter–输入和输出针对Java虚拟机而言 PrintWriter输出流 使用PrintWriter可以创建一个文本文件，并且向文本文件写入数据 使用PrintWriter后，必须使用关闭输出流，可以手动也可以自动关闭，不关闭会导致数据不能正确的保存在文件中 手动关闭1234567891011121314151617public class WriteData &#123; public static void main(String[] args) throws FileNotFoundException &#123; File file = new File(\"H:/wored.txt\"); if(file.exists()) &#123; System.out.println(\"文件已经存在，操作不成功\"); System.exit(1); &#125; PrintWriter pw = new PrintWriter(file); //这里会自动创建一个新的文件 pw.write(\"FREE Code\"); pw.print(\"Jo hnTsMI TL\"); pw.close(); //必须调用该方法，如果没有调用，则不能正确保存在文件中 Scanner in = new Scanner(file); System.out.println(in.nextLine()); &#125;&#125; 使用try-with-resources自动关闭输出流1234567891011121314151617181920212223242526272829public class WriteDataWithAutoClose &#123; /** * 文件输出流PrintWriter注意事项 * @param args * @throws FileNotFoundException */ public static void main(String[] args) throws FileNotFoundException &#123; File file = new File(\"H:/wored.txt\"); if(file.exists()) &#123; System.out.println(\"File already exits\"); System.exit(0); &#125; try( PrintWriter pw = new PrintWriter(file); //这里的pw只会当作AutoCloseable的子类型，在try语句块有效，因此会自动关闭所创建的文件输出流,并不需要我们手动关闭 )&#123; pw.print(\"John T Smith\"); pw.print(90); pw.print(\"Eric K Jones\"); pw.println(\"Evet\"); pw.print(\"85\"); &#125; Scanner in = new Scanner(file); System.out.println(in.nextLine()); &#125;&#125; Scanner输入流 使用java.util.Scanner 类来从控制台或者文本读取数据到虚拟机 从键盘读取12 Scanner input1 = new Scanner(System.in); 从文件中读取12 Scanner input = new Scanner(new File(\"H:/wored.txt\")); 例子1： 123456789public class ReadData &#123; public static void main(String[] args) throws FileNotFoundException &#123; Scanner input = new Scanner(new File(\"H:/wored.txt\")); //从文件中读取数据 String str = null; while(input.hasNext()) str = input.nextLine(); System.out.println(str); input.close(); //当然这里自动关闭也是可以的 &#125; Scanner 如何工作 Scanner中的next()，nextInt()，nextDouble()等方法都是标记读取方法，默认标记符为空格，读取以分隔符分开的标记，当然分隔符也可以使用useDelimiter(String regex)方法进行设置 Scanner中的next()，nextInt()，nextDouble()首先都会跳过任意分隔符，知道下一次遇到分隔符，才会读取结束 例子2： 123456789public class ReadData &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(\"54 33\"); int sum = input.nextInt() + input.nextInt(); System.out.println(sum); &#125; //结果为87&#125; 例子3：123456789101112public class ReadData &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); //从键盘中输入数据34 换行 567 int intValue = input.nextInt(); String line = input.nextLine(); System.out.println(intValue); System.out.println(line); &#125; //结果只有34，因为line读取到换行符，因为在换行符之前为空，返回为空&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"File","slug":"Java/File","permalink":"http://sivan0222.cn/categories/Java/File/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"IO","slug":"IO","permalink":"http://sivan0222.cn/tags/IO/"}]},{"title":"版本管理工具-Git篇","slug":"版本管理工具-Git篇","date":"2017-01-15T02:56:21.000Z","updated":"2017-05-05T04:18:30.004Z","comments":true,"path":"2017/01/15/版本管理工具-Git篇/","link":"","permalink":"http://sivan0222.cn/2017/01/15/版本管理工具-Git篇/","excerpt":"版本管理工具的介绍作用：备份文件，与U盘等备份文件相比，可以随时随地，项目中经常使用。 版本管理工具可以记录历史网盘 u盘 保存了文件的最新状态，而不会记录修改的历史纪录，而版本管理工具对每次的修改都会进行备份，并且保留了时间和修改人，可以让我们回溯，如果不小心删除版本管理工具中的备份时，我们可以通过历史纪录对其进行找回，因此使用版本管理工具无需担心，而且使用版本管理工具，可以多端共享，例如我们经常所说的云盘，而且只要提交一次，我们就可以在任何地方通过版本管理工具对提交的代码进行下载。尤其对于，一些经常需要分开工作的工作人员比较实用","text":"版本管理工具的介绍作用：备份文件，与U盘等备份文件相比，可以随时随地，项目中经常使用。 版本管理工具可以记录历史网盘 u盘 保存了文件的最新状态，而不会记录修改的历史纪录，而版本管理工具对每次的修改都会进行备份，并且保留了时间和修改人，可以让我们回溯，如果不小心删除版本管理工具中的备份时，我们可以通过历史纪录对其进行找回，因此使用版本管理工具无需担心，而且使用版本管理工具，可以多端共享，例如我们经常所说的云盘，而且只要提交一次，我们就可以在任何地方通过版本管理工具对提交的代码进行下载。尤其对于，一些经常需要分开工作的工作人员比较实用 历史 CVS： 版本管理工具始祖，也是被第一个大规模使用的版本管理工具。由荷兰一所大学教授所开发，由于当时三个人分开工作，为了便于一起协调，创建了CVS。集中式的工具，放到中心服务器上，需要联网 SVN： 2000年诞生，也是集中式的工具 git： 2005年诞生，Geek社区主流工具，分布式工具！ Github： 程序员社区，托管代码基于Git操作。大牛多在这里！！！ 集中式 与 分布式 区别 集中式需要放到中心服务器上，并且操作需要联网，不方便 分布式则是只要有版本库，就可以在不联网的前提下，快速完成文件提交，记录查看，以及删除等操作，效率高！ 初探GitGit 下载 与 安装Linux下的安装 打开终端 执行 yum install git 然后键入 yes 等待既可以安装完成 Git 入门Github GitHub由于下载比较难，推荐离线安装包安装 Linux下检出项目到本地 使用 git clone Github上的仓库地址 首先创建一个 目录，用来存放 我们检出的项目，使用命令 mkdir Test 接下来，进入到Test目录，然后 git clone Github上的仓库地址，就可以了 Linux下提交项目 再修改之后，只停留到了本地，没有交到Github维护，因此我们需要同步到Github 首先使用 git status 查看工作区的状态 对于未跟踪的文件，使用git add 文件名（不包括文件类型），进行跟踪 然后键入 git commit 命令，并对修改进行描述，这里提交的是提交到了本地的仓库，并没有提交给Github维护 键入git push，输入Github账户和密码，然后成功提交给Github进行维护 Windows下检出并提交项目 首先进入GitHub官方主页，并进入项目所对应的仓库主页，然后点击 open in desktop，选择本地的一个目录，此时检出完成，只需要我们对其进行修改 修改之后，首先要做的提交修改的东东，并对修改的东西进行一个修改说明 之后进行同步就可以了","categories":[{"name":"Tools","slug":"Tools","permalink":"http://sivan0222.cn/categories/Tools/"}],"tags":[{"name":"Tools","slug":"Tools","permalink":"http://sivan0222.cn/tags/Tools/"},{"name":"Git","slug":"Git","permalink":"http://sivan0222.cn/tags/Git/"}]},{"title":"[Java]-8","slug":"Java-8","date":"2017-01-02T02:55:12.000Z","updated":"2017-05-09T10:13:42.295Z","comments":true,"path":"2017/01/02/Java-8/","link":"","permalink":"http://sivan0222.cn/2017/01/02/Java-8/","excerpt":"Util包Random类nextInt()方法范围只是包含【0，输入的数字）；生成一个输入数字以内的随机整数 Date 类，SimpleDateFormat类，以及Calendar类 1.Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用Calendar 类进行时间和日期的处理。 由于Date类中，许多方法已经过时，因此现在我们通常用Date来保存时间，而使用Calendar来修改时间 格式化时间通常使用Date类以及SimpleDateFormat类使用 Date 类的默认无参构造方法创建出的对象就代表当前时间，我们可以直接输出 Date 对象显示当前的时间 12345678public class Test4 &#123; public static void main(String[] args) &#123; Date d = new Date(); System.out.println(d); /*输出 Sat Jan 14 19:13:41 CST 2017*/ &#125;&#125; Sat 代表 Saturday (星期六)， Jan 代表 January (一月)， 14代表 14 号， CST 代表 China Standard Time (中国标准时间，也就是北京时间，东八区)。","text":"Util包Random类nextInt()方法范围只是包含【0，输入的数字）；生成一个输入数字以内的随机整数 Date 类，SimpleDateFormat类，以及Calendar类 1.Date 类最主要的作用就是获得当前时间，同时这个类里面也具有设置时间以及一些其他的功能，但是由于本身设计的问题，这些方法却遭到众多批评，不建议使用，更推荐使用Calendar 类进行时间和日期的处理。 由于Date类中，许多方法已经过时，因此现在我们通常用Date来保存时间，而使用Calendar来修改时间 格式化时间通常使用Date类以及SimpleDateFormat类使用 Date 类的默认无参构造方法创建出的对象就代表当前时间，我们可以直接输出 Date 对象显示当前的时间 12345678public class Test4 &#123; public static void main(String[] args) &#123; Date d = new Date(); System.out.println(d); /*输出 Sat Jan 14 19:13:41 CST 2017*/ &#125;&#125; Sat 代表 Saturday (星期六)， Jan 代表 January (一月)， 14代表 14 号， CST 代表 China Standard Time (中国标准时间，也就是北京时间，东八区)。 格式转换将日期格式化，并以字符串形式输出123456789101112public class Test4 &#123; public static void main(String[] args) &#123; Date d = new Date(); System.out.println(d); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd号 HH时mm分ss秒\"); String s = sdf.format(d); System.out.println(s); &#125;&#125; 这里年，月，号，时，分，秒 可以自由换符号表示，可以换成 - 等等，也就是分隔符可以自由切换，但是英文字固定 需要注意的是格式化日期的时候 yyyy代表年份，mm代表分钟，MM代表月份，dd代表号，HH代表24小时制度的时，hh代表12进制的时，ss代表秒 将字符串格式的日期转换为系统默认格式输出123456789101112public class Test &#123; public static void main(String[] args) throws ParseException &#123; String s = \"2016年12月14号 19时28分34秒\"; SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd号 HH时mm分ss秒\"); Date date = sdf.parse(s); System.out.println(date); &#125;&#125; 将日期格式化系统格式的时候，需要注意声明异常 Calendar类的使用 java.util.Calendar 类是一个抽象类，可以通过调用 getInstance() 静态方法获取一个 Calendar 对象，此对象已由当前日期时间初始化，即默认代表当前时间，如 Calendar c = Calendar.getInstance();这里很深刻的体现了Java设计模式中的单例模式 1234567891011121314151617181920public class Test4 &#123; public static void main(String[] args) &#123; /*1.得到系统当前时间*/ Date date = new Date(); Calendar calendar = Calendar.getInstance(); /*2.把要修改的时间给cal,同时进行修改*/ calendar.setTime(date); calendar.set(calendar.YEAR, 2016); calendar.set(calendar.MONTH, 11); calendar.set(calendar.DATE, 31); /*3.修改完成后转换成Date进行保存*/ date = calendar.getTime(); System.out.println(date); &#125;&#125; Calendar修改的时候，需要我们注意几个问题，月份的值是 0-11，而且一个月份的天数超过，则会自动进入下个月 集合 集合长度随时可以改变，动态数组中，增长因子默认为10，大小改变，元素不变，将原先的数组复制到该数组 Collection 是集合类的根接口，其中下辖子接口 List , Set, Queue. 动态数组 与 动态链表 区别动态数组：增删效率低，查询效率高，物理（实际的位置）和逻辑（花名册上的位置）均相邻，所以查询效率高 动态链表：增删效率高，查询效率低，物理不相邻，逻辑相邻，所以查询效率低 ArrayList 与 Vector 区别ArrayList ： 异步（允许同一时间操作）Vector ： 同步（不允许同一时间操作） 同步与异步区别同步：一个接一个，效率低，安全性高异步：一起，效率高，安全性低 练习例题一： 图书馆借阅时间判断合法性 1234567891011121314151617181920212223public class Test3 &#123; public static void main(String[] args) throws ParseException &#123; Scanner input = new Scanner(System.in); System.out.println(\"请输入借书时间：\"); String s = input.nextLine();/*只能扫描输入一行*/ System.out.println(\"请输入还书时间：\"); String s1 = input.nextLine(); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH-mm-ss\"); Date date = sdf.parse(s); Date date1 = sdf.parse(s1); if( date.getTime() &gt; date1.getTime() ) System.out.println(\"借书成功！\"); else System.out.println(\"借书失败！\"); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"Util基本类的使用","slug":"Java/Util基本类的使用","permalink":"http://sivan0222.cn/categories/Java/Util基本类的使用/"}],"tags":[]},{"title":"[Java]-7","slug":"Java-7","date":"2016-12-30T02:55:06.000Z","updated":"2017-05-05T04:18:29.990Z","comments":true,"path":"2016/12/30/Java-7/","link":"","permalink":"http://sivan0222.cn/2016/12/30/Java-7/","excerpt":"Java中类与类之间的转换 类与类之间的转换如果要强转，则必须要有继承关系。否则，编译器会报出，ClassCastException异常 包装类之间的转换 思路是：将包装类进行拆箱，转换成基础数据类型之后，再进行转换，最后进行装箱 例如：Integer与Double的转换 123456789101112public class Test &#123; public static void main(String[] args) &#123; Integer a = 10; int b = a; double m = b; Double c = m; System.out.println(c); &#125;&#125;","text":"Java中类与类之间的转换 类与类之间的转换如果要强转，则必须要有继承关系。否则，编译器会报出，ClassCastException异常 包装类之间的转换 思路是：将包装类进行拆箱，转换成基础数据类型之后，再进行转换，最后进行装箱 例如：Integer与Double的转换 123456789101112public class Test &#123; public static void main(String[] args) &#123; Integer a = 10; int b = a; double m = b; Double c = m; System.out.println(c); &#125;&#125; String类详解 String类也是Java中的lang包中的一个类，众所周知，lang包中的所有类都不需要导入就可以使用，String类与System,Scanner类一样，都是Java中的一个预定义类型，而且String类是一个引用类型，任何Java类型都可以将变量表示为引用类型。使用引用类型声明的变量都是引用变量，引用在一个对象里。 String 类中 hashcode根据内容而生成（生成方式不同，即使生成内容相同，也不能说地址相同） 字节是计算机存储信息的基本单位，1 个字节等于 8 位， gbk 编码中 1 个汉字字符存储需要 2 个字节，1 个英文字符存储需要 1 个字节。所以我们看到上面的程序运行结果中，每个汉字对应两个字节值，如“学”对应 “-47 -89” ，而英文字母 “J” 对应 “74” 。同时，我们还发现汉字对应的字节值为负数，原因在于每个字节是 8 位，最大值不能超过 127，而汉字转换为字节后超过127，如果超过就会溢出，以负数的形式显示。 例如 ： 代码如下 1234567891011public class Test &#123; public static void main(String[] args) &#123; Object object = new Object(); System.out.println(object.hashCode()); Integer integer = new Integer(7051261); System.out.println(integer.hashCode()); &#125;&#125; 创建的两种形式 常量池中创建（内容唯一，不允许重复出现，在编译的时候就可以确定） 堆中创建（在JVM中只存在一个堆，但是在运行时才可以确定）在堆中创建的时候，一般做两件事：第一，检查常量池是否存在与其相同的。第二，如果有则直接复制过来，如果没有，在堆中新建，并且保存常量池 从大体上来讲，Java中的内存分为 常量池，堆，以及栈（存放引用，也就是我们常说的遥控器，花名册），关于进一步内存详解，请移步 一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder（后面章节中会讲到）。 区别 常量池中创建的 String 对象创建后则不能被修改，是不可变的，所谓的修改其实是创建了新的副本，则会在常量池中产生一个副本，所指向的内存空间不同 另外需要注意的是 ： String类中重写了equals方法，比较的是内容是否相同，而 == 判断的是地址是否相同，也就是哈希码是否相同 常量在编译中就可以确定，但是变量在运行时才可以确定 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; /*编译时就已经创建，并且放在常量池中*/ String str = \"hello\"; /*执行时才会确定，因此放到堆中*/ String str2 = new String(\"hello\"); String s = \"a\" + \"bc\";/* 等同于 String s = \"abc\"; //编译的时候这里会进行优化 s = abc*/ String s4 = s + str ;/*运行时确定的值放堆中 */ System.out.println(str == str2); /*false*/ System.out.println(str.equals(str2)); /*true*/ &#125;&#125; 常用方法 使用注意事项 使用方法并没有赋值，因此结果仍然不变 使用charAt 方法的时候不要越界 使用 indexOf 进行字符或字符串查找时，如果匹配返回位置索引；如果没有匹配结果，返回 -1 使用 substring(beginIndex , endIndex) 进行字符串截取时，包括 beginIndex 位置的字符，不包括 endIndex 位置的字符，因此如果只是截取之后的字符，直接使用 subString(int beginIndex) 数组中，length是属性，而String类中，length()是方法， intern() 方法是将字符串对象放入到常量池中，如果已经存在，则返回池中的字符串。 String类中的trim()方法去除的是前后两端的空白字符，包括字符’ ‘,’\\t’,’\\r’,’\\n’ 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; String s = \"a\"; s = s.concat(\"bc\"); System.out.println(s.equals(\"abc\")); String s2 = \"abc\"; System.out.println(s==s2); System.out.println(s2.startsWith(\"ab\"));/*是否以小写ab开头*/ System.out.println(\"ABC\".equals(s2)); System.out.println(\"ABC\".equalsIgnoreCase(s2));/*忽略大小写，看是否匹配，具体查看API*/ String s11 = \"hello\"; String s12 = s11.concat(\" world\"); System.out.println(s11);/*hello*/ System.out.println(s12);/*hello world*/ String s13 = new String(\"indei\"); s13.intern(); &#125;&#125; 这里讲述了转义符，以及replaceAll方法的使用，”.” 号作为通配符，指的是所有的 1234567891011121314public class Test11 &#123; public static void main(String[] args) &#123; String s = \"http://www.baidu.com\"; String s1 = s; s = s.replaceAll(\"\\\\.\", \" \"); /*这里使用双\\转义，使用两个\\，首先对一个\\进行转译，然后只有一个\\. 再通过\\对点号进行转义*/ System.out.println(s); /*http://www baidu com*/ System.out.println(s1); /*http://www.baidu.com*/ s1 = s1.replace(\".\", \"\"); System.out.println(); /*输出为空*/ &#125;&#125; trim方法使用trim 方法需要注意，只能去掉首尾两个地方的空格，不可以去掉其他地方的空格 12345678public class Test &#123; public static void main(String[] args) &#123; String s = \" hello world! \"; System.out.println(s.trim()); /*hello world!*/ &#125;&#125; contact方法：拼接字符串123456789101112131415public class Test16 &#123; public static void main(String[] args) &#123; String s = \"abc\"; s = s + \"de\"; s = s + \"fg\"; System.out.println(s); StringBuffer sb = new StringBuffer(\"abc\"); sb.append(\"de\"); System.out.println(sb); String s2 = sb.toString(); System.out.println(s2); &#125;&#125; 从代码中我们可以看到，当频繁操作字符串时，就会额外产生很多临时变量。容易产生很多垃圾内存。使用 StringBuilder 或 StringBuffer 就可以避免这个问题。至于 StringBuilder 和StringBuffer ，它们基本相似，不同之处，StringBuffer 是线程安全的，而 StringBuilder 则没有实现线程安全功能，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。 练习一： 判断邮件格式以及Java源代码文件名是否合法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class HelloWorld &#123; public static void main(String[] args) &#123; /*Java文件名*/ String fileName = \"HelloWorld.java\"; /* 邮箱*/ String email = \"laurenyang@imooc.com\"; /* 判断.java文件名是否正确：合法的文件名应该以.java结尾*/ /* 参考步骤： 1、获取文件名中最后一次出现\".\"号的位置 2、根据\".\"号的位置，获取文件的后缀 3、判断\".\"号位置及文件后缀名 */ /*获取文件名中最后一次出现\".\"号的位置*/ int index = fileName.lastIndexOf('.'); /* 获取文件的后缀*/ String prefix = fileName.substring(index + 1, fileName.length()); System.out.println(prefix.equals(\"java\")); /* 判断必须包含\".\"号，且不能出现在首位，同时后缀名为\"java\"*/ if ( index != -1 &amp;&amp; index != 0 &amp;&amp; prefix.equals(\"java\") ) &#123; System.out.println(\"Java文件名正确\"); &#125; else &#123; System.out.println(\"Java文件名无效\"); &#125; /* 判断邮箱格式是否正确：合法的邮箱名中至少要包含\"@\", 并且\"@\"是在\".\"之前*/ /* 参考步骤： 1、获取文件名中\"@\"符号的位置 2、获取邮箱中\".\"号的位置 3、判断必须包含\"@\"符号，且\"@\"必须在\".\"之前 */ /* 获取邮箱中\"@\"符号的位置*/ int index2 = email.indexOf('@'); /* 获取邮箱中\".\"号的位置*/ int index3 = email.indexOf('.'); /*判断必须包含\"@\"符号，且\"@\"必须在\".\"之前*/ if (index2 != -1 &amp;&amp; index3 &gt; index2) &#123; System.out.println(\"邮箱格式正确\"); &#125; else &#123; System.out.println(\"邮箱格式无效\"); &#125;&#125;&#125; 练习二： 生成随机验证码 123456789101112131415161718192021222324public class Prac &#123; public static void main(String[] args) &#123; /*方法一：自己写*/ String s1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; for(int i = 0; i &lt; 4; i++) &#123; System.out.print(s1.charAt((int)(Math.random() * 63 ))); &#125; /*方法二：推荐使用的方法*/ String s = \"abcdefghijklmnopqrstuvwxyz\"; Random random = new Random(); char[] chs = new char[4]; for (int i = 0; i &lt; 4; i++) &#123; char ch = s.charAt(random.nextInt(26)); chs[i] = ch; &#125; String code = new String(chs); System.out.println(code); &#125;&#125; 注意：方法二将验证码保存了，方法与用户输入进行比对，然而方法一只是完成了生成验证码的任务，没有按照用户体验考虑 String与基本数据类型之间的转换String与int 类型之间的转换1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; System.out.println('a' + 'b');/*这里返回的是a与b的Ascii码的和*/ /*整数转字符串*/ /*方法一*/ int a = 10; String s = a + \"\"; /*方法二*/ Integer i = a; String s1 = i.toString(); /*字符串转整数*/ int a1 = Integer.parseInt(s); System.out.println(a1); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[]},{"title":"Windows常用命令","slug":"Windows常用命令","date":"2016-12-25T02:56:07.000Z","updated":"2017-05-05T04:18:29.998Z","comments":true,"path":"2016/12/25/Windows常用命令/","link":"","permalink":"http://sivan0222.cn/2016/12/25/Windows常用命令/","excerpt":"CMD命令： 开始－&gt;运行－&gt;键入cmd或command（在命令行里可以看到系统版本、文件系统版本） appwiz.cpl：程序和功能 calc：启动计算器 certmgr.msc：证书管理实用程序 charmap：启动字符映射表 chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符） cleanmgr: 打开磁盘清理工具 cliconfg：SQL SERVER 客户端网络实用工具 cmstp：连接管理器配置文件安装程序 cmd.exe：CMD命令提示符","text":"CMD命令： 开始－&gt;运行－&gt;键入cmd或command（在命令行里可以看到系统版本、文件系统版本） appwiz.cpl：程序和功能 calc：启动计算器 certmgr.msc：证书管理实用程序 charmap：启动字符映射表 chkdsk.exe：Chkdsk磁盘检查（管理员身份运行命令提示符） cleanmgr: 打开磁盘清理工具 cliconfg：SQL SERVER 客户端网络实用工具 cmstp：连接管理器配置文件安装程序 cmd.exe：CMD命令提示符 自动关机命令 Shutdown -s -t 600：表示600秒后自动关机 shutdown -a ：可取消定时关机 Shutdown -r -t 600：表示600秒后自动重启 其他rundll32 user32.dll,LockWorkStation：表示锁定计算机 colorcpl：颜色管理，配置显示器和打印机等中的色彩 CompMgmtLauncher：计算机管理 compmgmt.msc：计算机管理 credwiz：备份或还原储存的用户名和密码 comexp.msc：打开系统组件服务 control：控制面版 dcomcnfg：打开系统组件服务 Dccw：显示颜色校准 devmgmt.msc：设备管理器 desk.cpl：屏幕分辨率 dfrgui：优化驱动器 Windows 7→dfrg.msc：磁盘碎片整理程序 dialer：电话拨号程序 diskmgmt.msc：磁盘管理 dvdplay：DVD播放器 dxdiag：检查DirectX信息 eudcedit：造字程序 eventvwr：事件查看器 explorer：打开资源管理器 Firewall.cpl：Windows防火墙 FXSCOVER：传真封面编辑器 fsmgmt.msc：共享文件夹管理器 gpedit.msc：组策略 hdwwiz.cpl：设备管理器 inetcpl.cpl：Internet属性 intl.cpl：区域 iexpress：木马捆绑工具，系统自带 joy.cpl：游戏控制器 logoff：注销命令 lusrmgr.msc：本地用户和组 lpksetup：语言包安装/删除向导，安装向导会提示下载语言包 lusrmgr.msc：本机用户和组 main.cpl：鼠标属性 mmsys.cpl：声音 magnify：放大镜实用程序 mem.exe：显示内存使用情况（如果直接运行无效，可以先管理员身份运行命令提示符，在命令提示符里输入mem.exe&gt;d:a.txt 即可打开d盘查看a.txt，里面的就是内存使用情况了。当然什么盘什么文件名可自己决定。） MdSched:Windows内存诊断程序 mmc：打开控制台 mobsync：同步命令 mplayer2：简易widnows media player Msconfig.exe：系统配置实用程序msdt：微软支持诊断工具 msinfo32：系统信息 mspaint：画图 Msra：Windows远程协助 mstsc：远程桌面连接 NAPCLCFG.MSC：客户端配置 ncpa.cpl：网络连接 narrator：屏幕“讲述人” Netplwiz：高级用户帐户控制面板，设置登陆安全相关的选项 netstat : an(TC)命令检查接口 notepad：打开记事本 Nslookup：IP地址侦测器 odbcad32：ODBC数据源管理器 OptionalFeatures：打开“打开或关闭Windows功能”对话框 osk：打开屏幕键盘 perfmon.msc：计算机性能监测器 perfmon：计算机性能监测器 PowerShell：提供强大远程处理能力 printmanagement.msc：打印管理 powercfg.cpl：电源选项 psr：问题步骤记录器 Rasphone：网络连接 Recdisc：创建系统修复光盘 Resmon：资源监视器 Rstrui：系统还原 regedit.exe：注册表 regedt32：注册表编辑器 rsop.msc：组策略结果集 sdclt：备份状态与配置，就是查看系统是否已备份 secpol.msc：本地安全策略 services.msc：本地服务设置 sfc /scannow：扫描错误并复原/windows文件保护 sfc.exe：系统文件检查器 shrpubw：创建共享文件夹 sigverif：文件签名验证程序 slui：Windows激活，查看系统激活信息 slmgr.vbs -dlv ：显示详细的许可证信息 slmgr.vbs -dli ：显示许可证信息 slmgr.vbs -xpr ：当前许可证截止日期 slmgr.vbs -dti ：显示安装ID 以进行脱机激 slmgr.vbs -ipk ：(Product Key)安装产品密钥 slmgr.vbs -ato ：激活Windows slmgr.vbs -cpky ：从注册表中清除产品密钥（防止泄露引起的攻击） slmgr.vbs -ilc ：(License file)安装许可证 slmgr.vbs -upk ：卸载产品密钥 slmgr.vbs -skms ：(name[ort] )批量授权 snippingtool：截图工具，支持无规则截图 soundrecorder：录音机，没有录音时间的限制 StikyNot：便笺 sysdm.cpl：系统属性 sysedit：系统配置编辑器 syskey：系统加密，一旦加密就不能解开，保护系统的双重密码 taskmgr：任务管理器（旧版） TM任务管理器（新版） taskschd.msc：任务计划程序 timedate.cpl：日期和时间 UserAccountControlSettings用户账户控制设置 utilman：辅助工具管理器 wf.msc：高级安全Windows防火墙 WFS：Windows传真和扫描 wiaacmgr：扫描仪和照相机向导 winver：关于Windows wmimgmt.msc：打开windows管理体系结构(WMI) write：写字板 wscui.cpl：操作中心 wscript：windows脚本宿主设置 wuapp：Windows更新 gpedit.msc—–组策略 sndrec32——-录音机 Nslookup——-IP地址侦测器 ，是一个 监测网络中 DNS 服务器是否能正确实现域名解析的命令行工具。 它在 Windows NT/2000/XP 中均可使用 , 但在 Windows 98 中却没有集成这一个工具。 explorer——-打开资源管理器 logoff———注销命令 shutdown——-60秒倒计时关机命令 lusrmgr.msc—-本机用户和组 services.msc—本地服务设置 oobe/msoobe /a—-检查XP是否激活 notepad——–打开记事本 cleanmgr——-垃圾整理 net start messenger—-开始信使服务 compmgmt.msc—计算机管理 net stop messenger—–停止信使服务 conf———–启动netmeeting dvdplay——–DVD播放器 charmap——–启动字符映射表 diskmgmt.msc—磁盘管理实用程序 calc———–启动计算器 dfrg.msc——-磁盘碎片整理程序 chkdsk.exe—–Chkdsk磁盘检查 devmgmt.msc— 设备管理器 regsvr32 /u *.dll—-停止dll文件运行 drwtsn32—— 系统医生 rononce -p—-15秒关机 dxdiag———检查DirectX信息 regedt32——-注册表编辑器 Msconfig.exe—系统配置实用程序 rsop.msc——-组策略结果集 mem.exe——–显示内存使用情况 regedit.exe—-注册表 winchat——–XP自带局域网聊天 progman——–程序管理器 winmsd———系统信息 perfmon.msc—-计算机性能监测程序 winver———检查Windows版本 sfc /scannow—–扫描错误并复原 taskmgr—–任务管理器（2000/xp/2003 winver———检查Windows版本 wmimgmt.msc—-打开windows管理体系结构(WMI) wupdmgr——–windows更新程序 wscript——–windows脚本宿主设置 write———-写字板 winmsd———系统信息 wiaacmgr——-扫描仪和照相机向导 winchat——–XP自带局域网聊天 mem.exe——–显示内存使用情况 Msconfig.exe—系统配置实用程序 mplayer2——-简易widnows media player mspaint——–画图板 mstsc———-远程桌面连接 mplayer2——-媒体播放机 magnify——–放大镜实用程序 mmc————打开控制台 mobsync——–同步命令 dxdiag———检查DirectX信息 iexpress——-木马捆绑工具，系统自带 58. fsmgmt.msc—–共享文件夹管理器 utilman——–辅助工具管理器 diskmgmt.msc—磁盘管理实用程序 dcomcnfg——-打开系统组件服务 ddeshare——-打开DDE共享设置 osk————打开屏幕键盘 odbcad32——-ODBC数据源管理器 oobe/msoobe /a—-检查XP是否激活 114. logoff———注销命令 notepad——–打开记事本 nslookup——-网络管理的工具向导 ntbackup——-系统备份和还原 narrator——-屏幕“讲述人” ntmsmgr.msc—-移动存储管理器 ntmsoprq.msc—移动存储管理员操作请求 netstat -an—-(TC)命令检查接口 syncapp——–创建一个公文包 sysedit——–系统配置编辑器 sigverif——-文件签名验证程序 ciadv.msc——索引服务程序 shrpubw——–创建共享文件夹 secpol.msc—–本地安全策略 syskey———系统加密，一旦加密就不能解开，保护windows xp系统的双重密码 services.msc—本地服务设置 Sndvol32——-音量控制程序 sfc.exe——–系统文件检查器 sfc /scannow—windows文件保护 ciadv.msc——索引服务程序 tourstart——xp简介（安装完成后出现的漫游xp程序） taskmgr——–任务管理器 eventvwr——-事件查看器 eudcedit——-造字程序 compmgmt.msc—计算机管理 packager——-对象包装程序 perfmon.msc—-计算机性能监测程序 charmap——–启动字符映射表 cliconfg——-SQL SERVER 客户端网络实用程序 Clipbrd——–剪贴板查看器 conf———–启动netmeeting certmgr.msc—-证书管理实用程序 regsvr32 /u *.dll—-停止dll文件运行 regsvr32 /u zipfldr.dll——取消ZIP支持 cmd.exe——–CMD命令提示符 chkdsk.exe—–Chkdsk磁盘检查 基本的操作命令：磁盘操作 fdisk 隐含 参数 /mbr 重建主引导记录fdisk /mbr 重建主引导记录 fdisk 在DOS7.0以后增加了/cmbr参数，可在挂接多个物理硬盘时，重建排序在后面的硬盘的主引导记录，例如：fdisk /cmbr 2，可重写第二个硬盘的主引导记录。（在使用时要十分小心，避免把好的硬盘引导记录损坏） format 参数： /q 快速格式化 /u 不可恢复 /autotest 不提示 /s 创建 MS-DOS 引导盘 format c: /q /u /autotest 目录操作 DIR [目录名或文件名] [/S][/W][/P][/A] 列出目录 参数: /s 查找子目录/w 只显示文件名 /p 分页/a 显示隐藏文件 DIR format.exe /s查找该盘的format.exe文件并报告位置 MD (MKDIR) [目录名] 创建目录 MKDIR HELLOWORLD 创建HELLOWORLD目录 CD (CHDIR) [目录名] PS:可以使用相对目录或绝对目录 进入目录 CD AA 进入当前文件夹下的AA目录,cd .. 进入上一个文件夹cd \\返回根目录;cd c:\\windows 进入c:\\windows文件夹 RD ( RMDIR) [目录名] 删除目录 RD HELLOWORLD 删除HELLOWORLD目录 文件操作 删除目录及其文件： rmdir [目录名或文件名] [/S][/W][/P][/A] 。例 rmdir c:\\qqdownload/s 删除C盘的qqdownload目录。 del [目录名或文件名] [/f][/s][/q] 删除 参数:/f 删除只读文件/s 删除该目录及其下的所有内容 /q 删除前不确认 del c:\\del /s /q 自动删除c盘的del目录。 copy [源文件或目录] [目标目录] 复制文件 copy d:\\pwin98. c:\\presetup 将d盘的pwin98的所有文件复制到c盘的presetup下。 attrib [参数][源文件或目录] 文件属性操作命令，attrib命令可以列出或修改磁盘上文件的属性，文件属性包括文档（A）、只读(R)、隐藏(H)、系统(S)，例如：attrib -h -r -s io.sys 执行这一命令后，将把DOS系统文件io.sys文件的只读、隐藏、系统属性去掉，这时将可以直接通过dir命令看到io.sys文件。attrib +h +r +s autoexec.bat将为自动批处理文件增加以上属性。 内存操作 debug 调试内存 参数 -w [文件名] 写入二进制文件 -o [地址1] [地址2] 输出内存 -q 退出 exp:o 70 10[return] o 71 01 [return] 01[return] q[return] DOS下通过写70h/71h PORT改变BIOS密码在CMOS中存放的对应位置的值,用以清除AWARD BIOS密码.debug 还可以破解硬盘保护卡等,但只可以在纯DOS下用。 分区操作 给磁盘分区，一般都会分成四个区，磁盘分区由主分区、扩展分区、逻辑分区组成。 PQ和Acronis Disk Director这两个工具都可以在不丢失数据的情况下对分区进行调整大小，以及合并等操作，XP系统的话你用PQ，WIN7系统的话用Acronis Disk Director 操作基本一样，可以去网上找教程来看看，再不重装系统的情况下都能调整分区大小，但是建议你还是先备份下数据再调整，毕竟对硬盘直接进行的操作有一定的危险性。 net use ipipc$ “ “ /user:” “ 建立IPC空链接 net use ipipc$ “密码” /user:”用户名” 建立IPC非空链接 net use h: ipc$ “密码” /user:”用户名” 直接登陆后映射对方C：到本地为H: net use h: ipc$ 登陆后映射对方C：到本地为H: net use ipipc$ /del 删除IPC链接 net use h: /del 删除映射对方到本地的为H:的映射 net user 用户名 密码 /add 建立用户 net user guest /active:yes 激活guest用户 net user 查看有哪些用户 net user 帐户名 查看帐户的属性 net localgroup administrators 用户名 /add 把“用户”添加到管理员中使其具有管理员权限 net start 查看开启了哪些服务 net start 服务名 开启服务；(如:net start telnet， net start schedule) net stop 服务名 停止某服务 net time 目标ip 查看对方时间 net time 目标ip /set 设置本地计算机时间与“目标IP”主机的时间同步,加上参数/yes可取消确认信息 net view 查看本地局域网内开启了哪些共享 net view ip 查看对方局域网内开启了哪些共享 net config 显示系统网络设置 net logoff 断开连接的共享 net pause 服务名 暂停某服务 net send ip “文本信息” 向对方发信息 net ver 局域网内正在使用的网络连接类型和信息 net share 查看本地开启的共享 net share ipc开启ipc共享 net share ipc/del删除ipc共享 net share c$ /del 删除C：共享 net user guest 12345 用guest用户登陆后用将密码改为12345 net password 密码 更改系统登陆密码 netstat -a 查看开启了哪些端口,常用netstat -an netstat -n 查看端口的网络连接情况，常用netstat -an netstat -v 查看正在进行的工作 netstat -p 协议名 例：netstat -p tcq/ip 查看某协议使用情况 netstat -s 查看正在使用的所有协议使用情况 nbtstat -A ip 对方136到139其中一个端口开了的话，就可查看对方最近登陆的用户名 tracert -参数 ip(或计算机名) 跟踪路由（数据包），参数：“-w数字”用于设置超时间隔。 ping ip(或域名) 向对方主机发送默认大小为32字节的数据，参数：“-l[空格]数据包大小”；“-n发送数据次数”；“-t”指一直ping。 ping -t -l 65550 ip 死亡之ping(发送大于64K的文件并一直ping就成了死亡之ping) ipconfig (winipcfg) 用于windows NT及XP(windows 95 98)查看本地ip地址，ipconfig可用参数“/all”显示全部配置信息 tlist -t 以树行列表显示进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) kill -F 进程名 加-F参数后强制结束某进程(为系统的附加工具，默认是没有安装的，在安装目录的Support/tools文件夹内) del -F 文件名 加-F参数后就可删除只读文件,/AR、/AH、/AS、/AA分别表示删除只读、隐藏、系统、存档文件，/A-R、/A-H、/A-S、/A-A表示删除除只读、隐藏、系统、存档以外的文件。例如“DEL/AR .”表示删除当前目录下所有只读文件，“DEL/A-S .”表示删除当前目录下除系统文件以外的所有文件 del /S /Q 目录 或用：rmdir /s /Q 目录 /S删除目录及目录下的所有子目录和文件。同时使用参数/Q 可取消删除操作时的系统确认就直接删除。（二个命令作用相同） move 盘符路径要移动的文件名 存放移动文件的路径移动后文件名 移动文件,用参数/y将取消确认移动目录存在相同文件的提示就直接覆盖 fc one.txt two.txt &gt; 3st.txt 对比二个文件并把不同之处输出到3st.txt文件中，”&gt; “和”&gt; &gt;” 是重定向命令 at id号 开启已注册的某个计划任务 at /delete 停止所有计划任务，用参数/yes则不需要确认就直接停止 at id号 /delete 停止某个已注册的计划任务 at 查看所有的计划任务 at ip time 程序名(或一个命令) /r 在某时间运行对方某程序并重新启动计算机 finger username @host 查看最近有哪些用户登陆 telnet ip 端口 远和登陆服务器,默认端口为23 open ip 连接到IP（属telnet登陆后的命令） telnet 在本机上直接键入telnet 将进入本机的telnet copy 路径文件名1 路径文件名2 /y 复制文件1到指定的目录为文件2，用参数/y就同时取消确认你要改写一份现存目录文件 copy c:srv.exe ipadmin$ 复制本地c:srv.exe到对方的admin下 copy 1st.jpg/b+2st.txt/a 3st.jpg 将2st.txt的内容藏身到1st.jpg中生成3st.jpg新的文件，注：2st.txt文件头要空三排，参数：/b指二进制文件，/a指ASCLL格式文件 copy ipadminsvv.exec:或:copyipadmin. 复制对方admini$共享下的srv.exe文件（所有文件）至本地C： xcopy 要复制的文件或目录树 目标地址目录名 复制文件和目录树，用参数/Y将不提示覆盖相同文件 用参数/e才可连目录下的子目录一起复制到目标地址下。 tftp -i 自己IP(用肉机作跳板时这用肉机IP) get server.exec:server.exe 登陆后，将“IP”的server.exe下载到目标主机c:server.exe 参数：-i指以二进制模式传送，如传送exe文件时用，如不加-i 则以ASCII模式（传送文本文件模式）进行传送 tftp -i 对方IP put c:server.exe 登陆后，上传本地c:server.exe至主机 ftp ip 端口 用于上传文件至服务器或进行文件操作，默认端口为21。bin指用二进制方式传送（可执行文件进）；默认为ASCII格式传送(文本文件时) route print 显示出IP路由，将主要显示网络地址Network addres，子网掩码Netmask，网关地址Gateway addres，接口地址Interface arp 查看和处理ARP缓存，ARP是名字解析的意思，负责把一个IP解析成一个物理性的MAC地址。arp -a将显示出全部信息 start 程序名或命令 /max 或/min 新开一个新窗口并最大化（最小化）运行某程序或命令 mem 查看cpu使用情况 attrib 文件名(目录名) 查看某文件（目录）的属性 attrib 文件名 -A -R -S -H 或 +A +R +S +H 去掉(添加)某文件的 存档，只读，系统，隐藏 属性；用+则是添加为某属性 dir 查看文件，参数：/Q显示文件及目录属系统哪个用户，/T:C显示文件创建时间，/T:A显示文件上次被访问时间，/T:W上次被修改时间 date /t 、 time /t 使用此参数即“DATE/T”、“TIME/T”将只显示当前日期和时间，而不必输入新日期和时间 set 指定环境变量名称=要指派给变量的字符 设置环境变量 set 显示当前所有的环境变量 set p(或其它字符) 显示出当前以字符p(或其它字符)开头的所有环境变量 pause 暂停批处理程序，并显示出：请按任意键继续…. if 在批处理程序中执行条件处理（更多说明见if命令及变量） goto 标签 将cmd.exe导向到批处理程序中带标签的行（标签必须单独一行，且以冒号打头，例如：“：start”标签） call 路径批处理文件名 从批处理程序中调用另一个批处理程序 （更多说明见call /?） for 对一组文件中的每一个文件执行某个特定命令（更多说明见for命令及变量） echo on或off 打开或关闭echo，仅用echo不加参数则显示当前echo设置 echo 信息 在屏幕上显示出信息 echo 信息 &gt;&gt; pass.txt 将”信息”保存到pass.txt文件中 findstr “Hello” aa.txt 在aa.txt文件中寻找字符串hello find 文件名 查找某文件 title 标题名字 更改CMD窗口标题名字 color 颜色值 设置cmd控制台前景和背景颜色；0=黑、1=蓝、2=绿、3=浅绿、4=红、5=紫、6=黄、7=白、8=灰、9=淡蓝、A=淡绿、B=淡浅绿、C=淡红、D=淡紫、E=淡黄、F=亮白 prompt 名称 更改cmd.exe的显示的命令提示符(把C:、D:统一改为：EntSky ) ver 在DOS窗口下显示版本信息 winver 弹出一个窗口显示版本信息（内存大小、系统版本、补丁版本、计算机名） format 盘符 /FS:类型 格式化磁盘,类型:FAT、FAT32、NTFS ,例：Format D: /FS:NTFS md 目录名 创建目录 replace 源文件 要替换文件的目录 替换文件 ren 原文件名 新文件名 重命名文件名 tree 以树形结构显示出目录，用参数-f 将列出第个文件夹中文件名称 type 文件名 显示文本文件的内容 more 文件名 逐屏显示输出文件 doskey 要锁定的命令=字符 doskey 要解锁命令= 为DOS提供的锁定命令(编辑命令行，重新调用win2k命令，并创建宏)。如：锁定dir命令：doskey dir=entsky (不能用doskey dir=dir)；解锁：doskey dir= taskmgr 调出任务管理器 chkdsk /F D: 检查磁盘D并显示状态报告；加参数/f并修复磁盘上的错误 tlntadmn telnt服务admn,键入tlntadmn选择3，再选择8,就可以更改telnet服务默认端口23为其它任何端口 exit 退出cmd.exe程序或目前，用参数/B则是退出当前批处理脚本而不是cmd.exe path 路径可执行文件的文件名 为可执行文件设置一个路径。 cmd 启动一个win2K命令解释窗口。参数：/eff、/en 关闭、开启命令扩展；更我详细说明见cmd /? regedit /s 注册表文件名 导入注册表；参数/S指安静模式导入，无任何提示； regedit /e 注册表文件名 导出注册表 cacls 文件名 参数 显示或修改文件访问控制列表（ACL）——针对NTFS格式时。参数：/D 用户名:设定拒绝某用户访问；/P 用户名:perm 替换指定用户的访问权限；/G 用户名:perm 赋予指定用户访问权限；Perm 可以是: N 无，R 读取， W 写入， C 更改(写入)，F 完全控制；例：cacls D: est.txt /D pub 设定d: est.txt拒绝pub用户访问。 cacls 文件名 查看文件的访问用户权限列表 REM 文本内容 在批处理文件中添加注解 netsh 查看或更改本地网络配置情况","categories":[{"name":"常用命令","slug":"常用命令","permalink":"http://sivan0222.cn/categories/常用命令/"}],"tags":[{"name":"CMD","slug":"CMD","permalink":"http://sivan0222.cn/tags/CMD/"}]},{"title":"Hexo常用命令","slug":"Hexo常用命令","date":"2016-12-25T02:55:55.000Z","updated":"2017-05-05T04:18:29.980Z","comments":true,"path":"2016/12/25/Hexo常用命令/","link":"","permalink":"http://sivan0222.cn/2016/12/25/Hexo常用命令/","excerpt":"这里收录了一些常用的Hexo命令，经常用到 Hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化","text":"这里收录了一些常用的Hexo命令，经常用到 Hexonpm install hexo -g #安装npm update hexo -g #升级hexo init #初始化 注意：需要node.js环境 新建博客目录hexo init blog #生成一个blog目录 注解：在 hexo 目录下生成blog文件夹，包含 node_modules、scaffolds、source、themes、.gitignore、_config.yml、db.json、package.json，其中 _config.yml 为全局配置文件 简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo p == hexo publishhexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署 新建文件夹（或者说是页面）（自动在文件夹下新建index.md）hexo new page filehexo new page “file”INFO Created: D:…\\blog\\source\\file\\index.md 新建文章hexo n fileNamehexo new “fileName”hexo new post fileNamehexo new post “fileName”INFO Created: D:…\\blog\\source_posts\\fileName.md 服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP 备注：4000为默认端口，若站点 _config.yml 中 修改配置 root: /blog/ ，即访问地址对应为 htto://localhost:4000/blog/ hexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署 监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate –watch #监视文件变动","categories":[{"name":"常用命令","slug":"常用命令","permalink":"http://sivan0222.cn/categories/常用命令/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://sivan0222.cn/tags/Hexo/"}]},{"title":"[Java]-6","slug":"Java-6","date":"2016-12-25T02:55:02.000Z","updated":"2017-05-05T04:18:29.989Z","comments":true,"path":"2016/12/25/Java-6/","link":"","permalink":"http://sivan0222.cn/2016/12/25/Java-6/","excerpt":"常用JAVA开发工具 MyEclipse：收费软件，不过内部集成了很强大的插件，从而称霸武林(使用MyEclipse出错时，可以使用 ctrl + 1 快捷键来提示错误 ) Eclipse：开源软件 作为一个J2EE工作者，我很希望MyEclipse能够开源，毕竟Eclipse都开源了 Java中的包 说到JAVA中的包，其实类似于我们windows系统下的文件夹 包的作用如下 不同文件夹下的文件可以重名 方便对文件进行管理 使用包的注意事项： 包名要全部小写，经常倒着写，例如，可以用网站名字倒着写 不建议使用默认包 lang 包 lang包作为JAVA语言最基础的包之一，下辖了许多类和方法可以供我们使用，其中最长使用的类是Object类，Math类，以及基本数据类型的包装类，下面我们将对这两个进行讲解","text":"常用JAVA开发工具 MyEclipse：收费软件，不过内部集成了很强大的插件，从而称霸武林(使用MyEclipse出错时，可以使用 ctrl + 1 快捷键来提示错误 ) Eclipse：开源软件 作为一个J2EE工作者，我很希望MyEclipse能够开源，毕竟Eclipse都开源了 Java中的包 说到JAVA中的包，其实类似于我们windows系统下的文件夹 包的作用如下 不同文件夹下的文件可以重名 方便对文件进行管理 使用包的注意事项： 包名要全部小写，经常倒着写，例如，可以用网站名字倒着写 不建议使用默认包 lang 包 lang包作为JAVA语言最基础的包之一，下辖了许多类和方法可以供我们使用，其中最长使用的类是Object类，Math类，以及基本数据类型的包装类，下面我们将对这两个进行讲解 Object类 JAVA中的类都是单继承，这里说的单继承是指每个类只能有一个直接父类，而且JAVA中的Object类虽然是每个类的子类，但是每个类的直接父类并不一定是Object类 1234567public class Dog extends Animal&#123; //例如在这个类中,直接父类是Animal，因此直接父类是Animal，并不是Object public void bark() &#123; &#125;&#125; clone() 方法讲解 API 中这样说道 ：“创建并返回此对象的一个副本。” 使用的注意事项： clone（）返回的是一个Object类型，因此我们需要将类型进行转换，转成我们所需要的类型，作为一个设计人员，因为在写clone（）方法的时候，我们不知道如何该方法返回一个何类型，所以先返回Object类型，再进行强转 需要声明异常CloneNotSupportedException 在使用clone（）的类中，我们实现接口Cloneable 结果注意事项： 通过clone方法得到的副本，除了地址不同之外其他与原来的一样，克隆生成的是两个独立的对象，可以通过hashcode（）来进行判断，hashcode（）相同则为同一个对象，因为hashcode就是根据地址来生成的 通过clone方法克隆叫做浅度克隆，也就是只克隆基本数据类型，并且值相等，而引用数据类型，我们将不会克隆，但是在深度克隆中，我们将会将引用数据类型以及基本类型都克隆，从而产生新对象，深度克隆通过JAVA中的流来实现 1234567891011public class Dog implements Cloneable &#123; int age = 10; public static void main(String[] args) throws CloneNotSupportedException &#123; Dog dog = new Dog(); Dog dog2 = (Dog) dog.clone(); System.out.println(dog2.age); //10 System.out.println(dog == dog2); //false &#125;&#125; equals()方法与 == 讲解使用的注意事项： equals方法在Object类中，比较的是两个对象的地址（因为在其他类中，我们可能会对equals（）方法重写），==永远比较两个对象的地址 equals方法在包装类中 比较的是 内容 1234567891011public class Dog implements Cloneable &#123; int age = 10; public static void main(String[] args) throws CloneNotSupportedException &#123; Dog dog = new Dog(); Dog dog2 = (Dog) dog.clone(); System.out.println(dog.equals(dog2)); //false System.out.println(dog == dog2); //false &#125;&#125; finalize() API中说到：当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。 JAVA中的垃圾内存：没有引用指向的内存通过finalize（）：释放对象，回收内存， 而且JAVA是自动回收内存的，不需要程序员实现，比C/C++痛苦轻多了 使用的注意事项： 需要有垃圾 需要启动垃圾回收器 System.gc(); 12345678910111213141516public class Dog &#123; @Override protected void finalize() throws Throwable &#123; // TODO Auto-generated method stub super.finalize(); System.out.println(\"垃圾被回收了\"); //有垃圾 &#125; int age = 10; public static void main(String[] args) &#123; Dog dog = new Dog(); //所谓的垃圾内存 dog = new Dog(); System.gc(); //充当了一个垃圾回收人员来主动收垃圾 //输出：垃圾被回收了 &#125;&#125; 结果分析：有的由于JDK版本不同，偶尔会输出“垃圾被回收了”，因为这里垃圾回收涉及到了JAVA中的一个线程，而且JAVA中垃圾的回收就是通过一个线程进行管理，线程不会时时刻刻都会处在管理状态 Math类 ceil（）：向上取整（大于该数的最小整数） floor（）：向上取整（大于该数的最小整数） round（）：加上0.5，去掉小数点之后的东西，也就是四舍五入 Random（）：随机生成一个【0，1.0）的数字 Math中涉及到的关于JAVA中的单例设计模式：类似于Math类，我们只需要对其构造函数进行私有化，因此我们只能在该类中对其进行实例化，所以称为单例设计模式，也就是只允许有1个对象，因为该类所占空间太大，使用单例设计模式的最直接表现就是私有化该类的构造函数，因此属性和方法我们将会加上static修饰符 1234567public class Test &#123; public static void main(String[] args) &#123; Math math1 = new Math();//这里会报错 &#125;&#125; 包装类中，== 在new 和 不 new的时候有区分 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; Integer integer = 10; Integer integer2 = new Integer(\"10\"); System.out.println(integer == integer2); System.out.println(integer.hashCode()); System.out.println(integer2.hashCode()); System.out.println(integer.equals(integer2)); /* *false *10 *10 *true */ &#125;&#125; 包装类 包装类：所谓的JAVA中的基本数据类型中所对应，进行包装而成的类 装箱：基本数据类型转换为对应包装类型的过程拆箱：包装类型转换为基本数据类型的过程 包装类中，hashcode根据对象内容生成 JDK1.4的时候，需要手动进行拆箱和装箱，并且1.4不支持注解 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; Integer integer = new Integer(10); Integer integer1 = new Integer(10); System.out.println(integer); //10 System.out.println(integer1); //10 //在JDK1.4中，需要我们手动拆装箱 int i = integer1; System.out.println(i); //10 &#125;&#125; 需要注意的是：在JDK5.0之后，JAVA引入了自动装箱和拆箱 1234567891011public class Test &#123; public static void main(String[] args) &#123; Integer integer = 10; Integer integer1 = 10; System.out.println(integer); //10 System.out.println(integer1); //10 &#125;&#125; 使用的注意事项：看到拆装箱这么自如，是不是很想用包装类呢，但是这里需要注意：能用基本数据类型解决问题，我们就用基本数据类型，因为基本数据类型效率高，占用空间小，比如我们项目中所涉及到的客户端传参","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[]},{"title":"[Android]-目录字典","slug":"Android-目录字典","date":"2016-12-25T02:52:50.000Z","updated":"2017-05-05T04:18:29.977Z","comments":true,"path":"2016/12/25/Android-目录字典/","link":"","permalink":"http://sivan0222.cn/2016/12/25/Android-目录字典/","excerpt":"src存放Android应用程序源代码的文件，通过在该文件夹下，通常创建包来进行区分不同的功能，在相应的包写上对应功能的程序代码，比如将服务，广播，还有活动区别分来","text":"src存放Android应用程序源代码的文件，通过在该文件夹下，通常创建包来进行区分不同的功能，在相应的包写上对应功能的程序代码，比如将服务，广播，还有活动区别分来 gengen文件夹是由应用程序自动生成的配置文件，不需要去手动修改 gen文件夹下面的R.java文件是该Android 应用程序资源管理文件，也就是通俗的字典，该文件将所有资源生成相对应的唯一的ID，可以通过ID对与其对应的资源进行引用 说到R.java 有时候可能无法正常生成R.java 自已有过亲身经历，自从修改了ADT之后，问题就消失了 assets:该文件会放一些资源文件，例如多媒体文件 下面讲到的res文件夹也可以存放资源, 不过assets 与 res有一些实质性的区别： assests下的资源文件不会自动生成资源ID 和占用apk(Android发布的可执行文件) 空间 assests文件可以通过AssetsManager类进行访问，存放到这里的资源在运行打包的时候都会打入程序安装包中 bin:存放编译后的文件，例如 apk,dex(Android上可执行文件的类型),class,资源文件等 libs:存放第三方使用到的JAVA架包 res:存放各种类型的资源文件，包含不同的目录drawble:存放图片文件，但是由于设备的不同，需要存放不同分辨率下的图片，ldpi–&gt;mdpi–&gt;hdpi–&gt;xhdpi–&gt;xxhdpi 分辨率由低到高layout:存放布局问文件menu:存放菜单文件values：dimens:存放尺寸大小strings:存放字符串资源styles:存放主题或者样式colors:存放颜色 AndroidManifest.xml这是android项目的系统清单文件，也是整个android应用的全局描述文件。清单文件说明了android应用的名称、所使用的图标以及包含的组件等， proguard-project.txt:代码混淆相关文件 project.properties：工程属性的配置文件，配置编译的版本等","categories":[{"name":"Android","slug":"Android","permalink":"http://sivan0222.cn/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://sivan0222.cn/tags/Android/"}]},{"title":"[Java]-5","slug":"Java-5","date":"2016-12-23T02:54:55.000Z","updated":"2017-05-05T04:18:29.988Z","comments":true,"path":"2016/12/23/Java-5/","link":"","permalink":"http://sivan0222.cn/2016/12/23/Java-5/","excerpt":"注意: 在JAVA方法中，不允许再定义方法，只可以调用 封装访问修饰符所有类当前包以及不同包的子类同包的类当前类publicYYYYprotectedNYYY默认(不写)NNYYprivateNNNN 其实访问修饰符就是帮助JAVA实现封装，封装就是我们生活中的包装，例如食物不包装会腐烂，汽车不包装会生锈，但是在JAVA中，我们封装可以提高安全性，可以避免恶意程序的调用，当然完全封装也不利于我们对功能的实现，所以我们在封装的时候，会留下接口，其实接口就是我们在封装所设置的set以及get方法 1注意：JAVA中方法的重写时，子类方法的访问修饰符 &gt;= 父类的访问修饰符","text":"注意: 在JAVA方法中，不允许再定义方法，只可以调用 封装访问修饰符所有类当前包以及不同包的子类同包的类当前类publicYYYYprotectedNYYY默认(不写)NNYYprivateNNNN 其实访问修饰符就是帮助JAVA实现封装，封装就是我们生活中的包装，例如食物不包装会腐烂，汽车不包装会生锈，但是在JAVA中，我们封装可以提高安全性，可以避免恶意程序的调用，当然完全封装也不利于我们对功能的实现，所以我们在封装的时候，会留下接口，其实接口就是我们在封装所设置的set以及get方法 1注意：JAVA中方法的重写时，子类方法的访问修饰符 &gt;= 父类的访问修饰符 例如： 首先创建一个Animal类 创建一个Tiger类 创建一个Test类 123456789//Animal类public class Animal &#123; String name; int age; protected void sayHello() &#123; &#125;&#125; 1234567//Tiger类public class Tiger extends Animal&#123; void sayHello() &#123; &#125;&#125; 12345678//Test类public class Test &#123; public static void main(String[] args) &#123; Tiger tiger = new Tiger(); tiger.sayHello(); &#125;&#125; 结果：编译报错，因为子类访问权限低于父类访问权限 多态 方法的重载和覆盖都属于多态 接口 接口在我们做一些小型项目的时候，不会常用到，但是在做一些大型项目的时候，我们经常会用到，尤其是接口的应用，一定程度上决定了项目的好坏，以及延展性，这里我们将对接口进行一些介绍 接口只是一个规范，只要求要做什么，没有要求我们如何去做（得到的一个结论就是扩展性强，从而一定程度上弥补了JAVA中单继承的缺点） JAVA中的接口与接口之间是多继承的关系，也就是一个接口可以有多个父接口，但是类与类之间是单继承 接口中的方法不能有方法体 通过文件定义接口的时候，注意接口名字与文件名前缀相同 接口的作用：被类实现，该类叫做接口的实现类，实现类也会获取接口中的方法和属性 非抽象类实现接口，必须对接口中的抽象方法进行实现 关于接口中的变量以及方法，看下面代码 12345678910//源代码public interface Test &#123; int foot = 4; void say();&#125;//进行反编译后的代码public interface Test &#123; public static final int foot; public abstract void say();&#125; 结论：JAVA中的接口，变量前面自动加上了public static final 修饰符，方法加上了public abstract 修饰符，并且我们不写修饰符的时候也会自动加上！ 常用关键字static关键字 修饰属性 和 方法：可以通过类直接调用 修饰类: 只能是内部类 静态块：在类加载的时候执行（也就是在主方法执行前执行） 静态成员(包括属性和方法)不能访问非静态成员(包括属性和方法)，因为静态成员优先于非静态成- 员分配内存 静态成员在内存中公共（所有对象都可以对其进行操作，并且结果保留），并且唯一（在内存中只有一份，被大家一起所有，而不是像其他属性，对象才有） final关键字 修饰类：该类不能有子类 修饰属性：表示属性不能被重新赋值，也就是所说的常量 修饰方法：该方法不能被重写（覆盖） abstract关键字 修饰类：该类是抽象类，不能被实例化 修饰方法：该方法是抽象方法，不能有方法体，例如 public abstract void setAge(int age); 有抽象方法的类一定是抽象类，抽象类不一定有抽象方法 抽象类作用就在于可以被继承 abstract 和 final关键字不可以共存 instanceof 关键字使用:(返回 true 或者 false) 基本语法：对象 instanceof 类名 123456789 public class Test&#123; public static void main(String[] args) &#123; Test t1 = new Test(); System.out.println(t1 instanceof Test); &#125; //打印结果为true&#125; 约定名称书写规范 全部大写：常量名字 全部小写：工程名字 包名字 Pascal命名法： 每个单词首字母大写 类名 驼峰命名法: 第一个单词首字母小写，其他单词首字母全部大写 方法名字，以及类的属性 类成员执行优先级顺序： static 优先于 非static 同级别 属性&gt;块&gt;主方法&gt;普通方法 构造方法的话得看他调用的先后 1234567891011121314151617public class Test&#123; static int a; public static void main(String[] args) &#123; Test t1 = new Test(); t1.a=500; System.out.println(\"a:\"+t1.a); //500 &#125; class b &#123; &#125;&#125; class c &#123; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://sivan0222.cn/tags/OOP/"},{"name":"static","slug":"static","permalink":"http://sivan0222.cn/tags/static/"},{"name":"final","slug":"final","permalink":"http://sivan0222.cn/tags/final/"}]},{"title":"[Java]-怪题-1","slug":"Java-怪题-1","date":"2016-12-22T02:57:19.000Z","updated":"2017-11-09T07:24:23.145Z","comments":true,"path":"2016/12/22/Java-怪题-1/","link":"","permalink":"http://sivan0222.cn/2016/12/22/Java-怪题-1/","excerpt":"例题一：不使用中间变量的情况下将两个数字进行交换并成功输出： 1234567891011121314151617181920212223242526272829303132public class Exchange &#123; public static void main(String[] args) &#123; int a = 20; int b = 10; /*方法一：通过加减法进行交换*/ a = a + b; b = a - b; a = a - b; System.out.println(\"a:\" + a + \" b:\" + b);/*a:10 b:20*/ /*方法二：通过乘除法进行交换*/ a = a * b; b = a / b; a = a / b; System.out.println(\"a:\" + a + \" b:\" + b); /*a:20 b:10*/ /*方法三：通过位运算进行交换*/ /*20：1 0100*/ /*10： 1010*/ a = a&gt;&gt;1; /*右移1位*/ b = b&lt;&lt;1; /*左移1位*/ System.out.println(\"a:\" + a + \" b:\" + b);/*a:10 b:20*/ /*方法四：通过异或运算进行交换*/ /*原理：一个数异或本身等于0，而且异或运算符合交换律*/ a = a ^ b; b = a ^ b; a = a ^ b; System.out.println(a); System.out.println(b); &#125; &#125;","text":"例题一：不使用中间变量的情况下将两个数字进行交换并成功输出： 1234567891011121314151617181920212223242526272829303132public class Exchange &#123; public static void main(String[] args) &#123; int a = 20; int b = 10; /*方法一：通过加减法进行交换*/ a = a + b; b = a - b; a = a - b; System.out.println(\"a:\" + a + \" b:\" + b);/*a:10 b:20*/ /*方法二：通过乘除法进行交换*/ a = a * b; b = a / b; a = a / b; System.out.println(\"a:\" + a + \" b:\" + b); /*a:20 b:10*/ /*方法三：通过位运算进行交换*/ /*20：1 0100*/ /*10： 1010*/ a = a&gt;&gt;1; /*右移1位*/ b = b&lt;&lt;1; /*左移1位*/ System.out.println(\"a:\" + a + \" b:\" + b);/*a:10 b:20*/ /*方法四：通过异或运算进行交换*/ /*原理：一个数异或本身等于0，而且异或运算符合交换律*/ a = a ^ b; b = a ^ b; a = a ^ b; System.out.println(a); System.out.println(b); &#125; &#125; 例题二：1234567891011public class Exchange &#123; public static void main(String[] args) &#123; double num = 1.0/0; /*计算的时候将0转换成0.0*/ System.out.println(num); /*输出infinity*/ &#125; &#125;/* 特别注意： 这里计算num的 时候将除数的0 转换成0.0*/ 例题三：关于下面这个代码快 123456789101112public class Test&#123; public static void main(String[] args) &#123; int millSeconds = 365 * 24 * 60 * 60 * 1000 * 1000; int seconds = 365 * 24 * 60 * 60 * 1000; System.out.println(millSeconds); System.out.println(seconds); System.out.println(millSeconds/seconds); System.out.println(millSeconds + Integer.MIN_VALUE - Integer.MAX_VALUE - 1); &#125;&#125; 结果 //-1944854528//1471228928//-1//-1944854528 ###原因分析： 首先millSeconds变量产生了溢出，对于溢出的变量，如果达到了最大值，那么将继续从最小值开始，补足剩余的差值，因此最后输出的数字是-1944854528","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[]},{"title":"数据类型注意事项","slug":"数据类型注意事项","date":"2016-12-22T02:56:59.000Z","updated":"2017-11-09T07:13:47.214Z","comments":true,"path":"2016/12/22/数据类型注意事项/","link":"","permalink":"http://sivan0222.cn/2016/12/22/数据类型注意事项/","excerpt":"例题1： 给出如下一段代码，判断会输出什么 12345678910111213public class Second &#123; public static void main(String[] args) &#123; byte a = 1; byte b = 1; byte c = a + b; /*1*/ byte d = (byte)a + (byte)b; /*2*/ System.out.println(c); System.out.println(d); &#125;&#125; 结果： 其实，这里什么都不会输出，并且会报错 原因分析： 这里有一条规律，JAVA中 int以及int以下的类型进行运算，结果是int类型，这个程序中，注释标为1和2的地方都是byte类型经过加法运算，所以最终结果是int类型，而且int转byte是不可以自动转换的，需要进行强制转换 总结一下： int及int以下的类型，经过运算结果仍为intl类型 JAVA是一种强类型语言，大类型转小类型强转，小转大自动转","text":"例题1： 给出如下一段代码，判断会输出什么 12345678910111213public class Second &#123; public static void main(String[] args) &#123; byte a = 1; byte b = 1; byte c = a + b; /*1*/ byte d = (byte)a + (byte)b; /*2*/ System.out.println(c); System.out.println(d); &#125;&#125; 结果： 其实，这里什么都不会输出，并且会报错 原因分析： 这里有一条规律，JAVA中 int以及int以下的类型进行运算，结果是int类型，这个程序中，注释标为1和2的地方都是byte类型经过加法运算，所以最终结果是int类型，而且int转byte是不可以自动转换的，需要进行强制转换 总结一下： int及int以下的类型，经过运算结果仍为intl类型 JAVA是一种强类型语言，大类型转小类型强转，小转大自动转 例题2： 给出如下一段代码，判断会输出什么 123456789public class Test&#123; public static void main(String[] args) &#123; short s = 10; short s2 = 20; char ch = s + s2; System.out.println(ch); &#125;&#125; 结果： 这里会报错 原因分析： 首先要明确，int 与 char[^footnote]：是无法转换的，而且char类型取值范围与int无大小之分，因此这里会报错 总结一下： 没有大小之分的数据类型，通过转换，精度出现损失的时候，需要进行强转 char的取值范围从0开始，而其他6个基本数值型则从负数开始 例题3： 给出如下一段代码，判断会输出什么 12345678910111213141516public class Second &#123; public static void main(String[] args) &#123; byte b = 10; short s = b; System.out.println(s); byte b2 = s; System.out.println(b2); &#125;&#125; 结果： 依然会报错 原因分析： short类型转换为byte需要进行强制转换，因为会有精度损失 例题4： 给出如下一段代码，判断会输出什么 12345678public class Second &#123; public static void main(String[] args) &#123; byte b = -10; char ch = b; System.out.println(ch); &#125;&#125; 结果： 报错 原因： byte与char无大小之分，需要进行强转 例题5 给出如下一段代码，判断会输出什么 1234567891011public class Second &#123; public static void main(String[] args) &#123; short s = 10; char ch = (char)s; System.out.println(ch + 1 - 1 ); &#125;&#125; 结果： 程序可以正常运行，因为自己在写的时候特意加上了（char） 原因分析： 因为short 类型是有符号的，而char类型是无符号的，因此尽管char类型与short类型字节数相同，但是在这里还是不能进行强转的 问题来了：为什么输出的时候ch + 1 - 1就会输出一个数字呢（直接用ch输出看不到效果，因为输出的是字符） 例题6 给出如下一段代码，判断会输出什么 123456789public class Second public static void main(String[] args) &#123; long l = 100; float f = l; System.out.println(f); &#125;&#125; 结果： 正常输出 100.0 原因分析： JAVA数据类型中，虽然long比float的字节数多，但是他们表示的方法不同，long采用的是二进制，而float采用的是科学计数法，因此float虽然字节数少，但是范围较long还要大些 例题7 给出如下一段代码，判断会输出什么 1234567public class Second &#123; public static void main(String[] args) &#123; float f = 10.0f/0; System.out.println(f); &#125;&#125; 结果： infinity 原因： 这里进行计算的时候，将0转换成0.0，因此结果是Infinity 例题8 给出如下一段代码，判断会输出什么 123456789public class Second &#123; public static void main(String[] args) &#123; long a = 10; int b = 20; int c = a + b; System.out.println(c); &#125;&#125; 结果： 报错 原因分析： int 与 int以上的类型进行运算，结果仍为大类型 总结：关于数据类型的注意事项，上面一些题目，都需要注意","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"数据类型","slug":"数据类型","permalink":"http://sivan0222.cn/tags/数据类型/"}]},{"title":"[Java]-4","slug":"Java-4","date":"2016-12-17T02:54:51.000Z","updated":"2017-11-09T07:13:45.622Z","comments":true,"path":"2016/12/17/Java-4/","link":"","permalink":"http://sivan0222.cn/2016/12/17/Java-4/","excerpt":"面向过程 与 面向对象 面向过程：通过事件发生的过程来进行分析 面向对象：通过事件的参与者来进行分析 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 定义一个类如何描述一个JAVA中的类： 属性 方法 cmd下的JAVA命令，只可以运行有主方法的类Javac 进行编译含有主方法类的时候，会自动将里面所涉及到的类自动编译，不需要手动对其他类进行编译 1234567891011public class Test &#123; String name; int age; public static void main(String[] args) &#123; Animal animal = new Animal(); /*这里的animal只是一个名字，不是指新建出来的对象*/ /*Head First Java中将其形象的说成了遥控器*/ &#125;&#125;","text":"面向过程 与 面向对象 面向过程：通过事件发生的过程来进行分析 面向对象：通过事件的参与者来进行分析 面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了。 面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。 定义一个类如何描述一个JAVA中的类： 属性 方法 cmd下的JAVA命令，只可以运行有主方法的类Javac 进行编译含有主方法类的时候，会自动将里面所涉及到的类自动编译，不需要手动对其他类进行编译 1234567891011public class Test &#123; String name; int age; public static void main(String[] args) &#123; Animal animal = new Animal(); /*这里的animal只是一个名字，不是指新建出来的对象*/ /*Head First Java中将其形象的说成了遥控器*/ &#125;&#125; 类中特殊的方法-构造方法 作为JAVA中的最特殊方法—构造方法，并非浪得虚名，通过构造方法，我们可以给属性进行赋值，同时产生一个对象，当一个子类继承了一个父类的时候，子类的构造方法的第一句一定是通过super调用父类的构造方法。 注意事项： 与类同名 无返回类型（与void不同，void是返回为空） 不能通过对象调用，只在new的时候调用 如果用户没有定义，系统提供一个默认的无参构造方法 构造方法不可以被继承 不可以被重写，只可以被重载 这里我们可以先对类进行编译，编译之后通过dos下的javap 类名 即可进行反编译 1234567891011121314151617181920public class Test &#123; public static void main(String[] args) &#123; Animal1 animal = new Animal1(10); /*animal.age = 10;*/ System.out.println(animal.age); &#125;&#125;class Animal1 &#123; int age; public Animal1(int age) &#123; age = age; &#125;&#125; 结果：输出0原因分析：所有方法中，局部变量优先于全局变量，在这里就是 把局部变量的 age = 10; 父类引用指向子类对象移步 OOP四大特性 抽象：描述一个类，只是通过我们在业务中所用到的一些方法和属性进行描述 继承：JAVA中的继承包括两种，类与类之间的继承是单继承（子类继承父类的属性和方法（这句话局部正确，毕竟构造方法肯定不可以）），类与接口的继承是多继承 封装 多态：通过重载与覆盖表现出来 关于继承的时候：一般都是一对多，此时我们需要由多的一方进行维护，这和我们在数据库中所涉及到的是一样的 this 与 superthis：一般常用于方法中，哪个对象调用就指的是这个对象，特指当前对象 12345678910public class Animal &#123; int age; public Animal(int age) &#123; this.age = age;/*在这里就是该对象的age属性被赋值成age(所谓的局部变量)*/ &#125;&#125; super：只是一个关键字，并不是父类对象，但是我们可以通过super来调用父类的属性和方法 注意： 12345678910public class Test &#123; public static void main(String[] args) &#123; Animal1 animal = new Animal1(10); /*animal.age = 10;*/ System.out.println(animal.age); System.out.println(animal);/*这里输出 类名@哈希码 通过哈希码我们可以判断是不是同一个对象，相同则是同一个对象*/ &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[{"name":"OOP","slug":"OOP","permalink":"http://sivan0222.cn/tags/OOP/"}]},{"title":"[Java]-怪题-3","slug":"Java-怪题-3","date":"2016-12-14T02:57:28.000Z","updated":"2017-11-09T07:13:50.117Z","comments":true,"path":"2016/12/14/Java-怪题-3/","link":"","permalink":"http://sivan0222.cn/2016/12/14/Java-怪题-3/","excerpt":"这里介绍一个之前曾经遇到过的一个问题 例题：采用递归的方法求100以内的数字和 方法一： 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; int s = 100; System.out.println(getSum(100)); &#125; /*这里自己另外写了一个方法*/ public static int getSum(int n) &#123; if(n &lt; 1) return n; else return n + getSum(n-1); &#125;&#125;","text":"这里介绍一个之前曾经遇到过的一个问题 例题：采用递归的方法求100以内的数字和 方法一： 1234567891011121314151617public class Test &#123; public static void main(String[] args) &#123; int s = 100; System.out.println(getSum(100)); &#125; /*这里自己另外写了一个方法*/ public static int getSum(int n) &#123; if(n &lt; 1) return n; else return n + getSum(n-1); &#125;&#125; 方法二： 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; int s = 100; System.out.println(sum(100)); &#125; /*这种方法代码量少，而且富有技巧，但是不是自己写的，还是需要加强 */ public static int sum(int number) &#123; int s = 0; if(number &gt;= 1) s = number-- + sum(number); return s; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"}]},{"title":"[Java]-3","slug":"Java-3","date":"2016-12-14T02:54:47.000Z","updated":"2017-05-05T04:18:29.985Z","comments":true,"path":"2016/12/14/Java-3/","link":"","permalink":"http://sivan0222.cn/2016/12/14/Java-3/","excerpt":"数组 数组作为最常使用的引用数据类型，在项目中使用较为广泛，这里进行一些相关介绍 数组的创建 首先声明数组 创建数组 数组赋初值（不赋初值，系统会默认赋值，byte short int long 系统赋初值0 ，float double系统赋初值0.0 boolean系统赋初值false） 需要注意的是：数组在定义长度和赋初值同时操作会报错，同时数组长度一旦确定将不能发生改变 类中的方法形参与实参的区别 形参只是一个形式参数，最主要的是方法中的参数的数据类型，而不是形参本身 实参是一个实际参数，指定了使用方法时所需传递的数据","text":"数组 数组作为最常使用的引用数据类型，在项目中使用较为广泛，这里进行一些相关介绍 数组的创建 首先声明数组 创建数组 数组赋初值（不赋初值，系统会默认赋值，byte short int long 系统赋初值0 ，float double系统赋初值0.0 boolean系统赋初值false） 需要注意的是：数组在定义长度和赋初值同时操作会报错，同时数组长度一旦确定将不能发生改变 类中的方法形参与实参的区别 形参只是一个形式参数，最主要的是方法中的参数的数据类型，而不是形参本身 实参是一个实际参数，指定了使用方法时所需传递的数据 方法的调用本质条件 方法名字 参数(参数要分顺序) 方法的返回值类型与void的使用 方法返回值类型不是void时，则必须加上return 和相对应的返回类型。 方法返回值是void类型的时候，加上return语句也可以，(例如下面的代码) 1234567891011121314public class Person &#123; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; return; &#125; &#125; break : 强制退出当次循环continue : 进入下一次循环return : 跳出当前方法 方法的重载条件 发生在同一个类中 方法名字相同 参数不同（参数的类型，参数的顺序，参数的个数） 注意根据方法名与参数只能找到一个与其对应的方法，则编译正确 例如：（代码将会报错） 123456789101112public class Test&#123; public static String add(String a, int b) &#123; return a; &#125; public static int add(String a, int b )&#123; return b; &#125; &#125; 运算符三元运算符著名的三元运算符 ？ ： 12 System.out.println(5 &gt; 3 ? 5 : 3); 注意：?号前面的运算结果必须为boolean类型，不可以为其他类型 逻辑运算符 逻辑运算符中，包含有 &amp;&amp; || &amp; | ^ ! ####详解 &amp; 与 &amp;&amp; &amp;&amp;只可以做逻辑运算，&amp;则既可以做逻辑运算，也可以做位运算 &amp;&amp; 与 &amp; 做逻辑运算规则相同 &amp; 做位运算，规则是 将两个数字转换为二进制，对比每个二进制位，有0的便为0，全为1便为1 | 与 || 也同理 &amp;&amp;在做逻辑运算的时候会部分短路，（在假与真或的时候）","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[]},{"title":"[Java]-2","slug":"Java-2","date":"2016-12-10T02:54:43.000Z","updated":"2017-05-05T04:18:29.984Z","comments":true,"path":"2016/12/10/Java-2/","link":"","permalink":"http://sivan0222.cn/2016/12/10/Java-2/","excerpt":"Java中的基本数据类型数值型byte1字节short char2字节int4字节long8字节float4字节double8字节 非数值型boolean","text":"Java中的基本数据类型数值型byte1字节short char2字节int4字节long8字节float4字节double8字节 非数值型boolean 注意： 这8种数据类型都是Java的基本数据类型，值得注意的是Java中的int与float字节数相同，但是表示方法不同，从而范围不同， float采用科学计数法 char类型是数值型中唯一一个无符号位的数据类型，而其他数据类型中，使用二进制对其进行表示的时候，最开始的一位便是符号位，1为负数 0 为正数 虽然0000 0000 与 1000 0000 都可以代表0，但是计算机中采用补码来表示0 short与char 的字节数相同，但是因为char无符号位，因此char: 0-65535 short:-32768-32767 Java的基本类型数据转换注意事项 Java中对于数据类型的转换，有着默认的规则，这里将记录一些常用的套路，对于更深层次的研究，请移步 小类型转换成大类型自动转换，大类型转换成小类型需要进行强转（可能会产生溢出） 当数据类型所表示的范围无大小之分时，产生精度损失就需要进行强转（例如char和int类型进行转换） int以及int类型以下的数据类型运算结果为int char类型是数值型中唯一一个没有符号位的数据类型，同时char类型在定义的时候还可以用单个字符来进行定义 大类型 + 小类型 = 大类型 float以及double 都采用科学计数法来表示一个数字，虽然float和int所占用字节数相同，long和double所占字节数相同，但是两者表示方法不同，从而所表示的数值范围不同。Java中的小数类型默认是double类型 char类型数据可以转换为任意一个数据类型，但是将整数转换为一个char类型的时候，只用到该整数的低16位，其余被忽略。 将一个浮点型数转换为一个char类型的数字的时候，首先将浮点型数值转换成int类型，然后转换为char类型。如果转换结果适用于目标变量，则隐式转换，否则显式转换 所有数值操作符都可以用在char类型操作数上，如果另一个操作数是一个数字或字符，那么char类型操作数就会被自动转换成一个数字，如果另一个操作数是一个字符串，字符就会与该字符串相连。 Java一些语句的注意事项 当采用记事本编程Java的时候，需要使用ctrl + c 退出dos下的死循环，然后dos下键入cls清屏 switch语句中，条件只能是int以及int一下的数据类型，从JDK1.7开始支持字符串 switch语句执行，每个case语句一旦触发，没有break时，后面的语句都会得到执行 Java中 + 号作为被重载的运算符具有两个功能： 第一，如果+号两边都是数字，则计算结果为数字。第二，如果+号两边，出现字符串，则会对字符串进行拼接。 float内存详解 这里将会介绍一些float的内存详解，用来区分int与float，从而更深层次的理解int 与 float为什么会字节数相同，表示的数据类型范围不同，不仅仅是体现在了方法上面 表示方法 定点数表达法的缺点在于其形式过于僵硬，固定的小数点位置决定了固定位数的整数部分和小数部分，不利于同时表达特别大的数或者特别小的数。 计算机系统采纳了所谓的浮点数表达方式。这种表达方式利用科学计数法来表达实数，即用一个尾数（Mantissa也叫有效数字 ），一个基数（Base），一个指数（Exponent）以及一个表示正负的符号来表达实数。浮点数利用指数达到了浮动小数点的效果，从而可以灵活地表达更大范围的实数。 当一个浮点数的尾数为0，不论其阶码为何值，该浮点数的值都为0。当阶码的值为它能表示的最小一个值或更小的值时,不管其尾数为何值，计算机都把该浮点数看成零值,通常称其为机器零，此时该浮点数的所有各位（包括阶码位和尾数位）都清为0值。 Java 平台上的浮点数类型 float 和 double 采纳了 IEEE 754 标准中所定义的单精度 32 位浮点数和双精度 64 位浮点数的格式。在 IEEE 标准中，浮点数是将特定长度的连续字节的所有二进制位分割为特定宽度的符号域，指数域和尾数域三个域，其中保存的值分别用于表示给定二进制浮点数中的符号，指数和尾数。这样，通过尾数和可以调节的指数就可以表达给定的数值了。 表示原理讲解 第一个域为符号域。其中 0 表示数值为正数，而 1 则表示负数。 第二个域为指数域，对应于我们之前介绍的二进制科学计数法中的指数部分。其中单精度数为 8 位，双精度数为 11 位。以单精度数为例，8 位的指数为可以表达 0 到 255 之间的 255 个指数值（注：指数8位的最高位都是数值位，没有符号位）。但是，指数可以为正数，也可以为负数。为了处理负指数的情况，实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值，单精度数的偏差值为 127（2^7-1），而双精度数的偏差值为1023（2^10-1）。比如，单精度的实际指数值 0 在指数域中将保存为 127；而保存在指数域中的 64 则表示实际的指数值 -63（64-127=-63）。 偏差的引入使得对于单精度数，实际可以表达的指数值的范围就变成 -127（表示小数点需向左移动127位） 到128（表示小数点需向右移动128位） 之间（包含两端）。我们不久还将看到，实际的指数值 -127（全 0）以及 +128（全 1）保留用作特殊值的处理。这样，实际可以表达的有效指数范围就在 -127 和 127 之间。 第三个域为尾数域，其中单精度数为 23 位长，双精度数为 52 位长。除了我们将要讲到的某些特殊值外，IEEE 标准要求浮点数必须是规范的。这意味着尾数的小数点左侧必须为1，因此我们在保存尾数的时候，可以省略小数点前面这个 1，从而腾出一个二进制位来保存更多的尾数。这样我们实际上用 23 位长的尾数域表达了 24 位的尾数。比如对于单精度数而言，二进制的 1001.101（对应于十进制的 9.625）可以表达为 1.001101 × 2^3，所以实际保存在尾数域中的值为 00110100000000000000000，即去掉小数点左侧的 1，并用 0 在右侧补齐。 注意值得注意的是，对于单精度数，由于我们只有 24 位的尾数（其中一位隐藏），所以可以表达的最大尾数为 2^24- 1 = 16,777,215。特别的，16,777,216 是偶数，所以我们可以通过将它除以 2 并相应地调整指数来保存这个数，这样 16,777,216 同样可以被精确的保存。相反，数值 16,777,217 则无法被精确的保存。由此，我们可以看到单精度的浮点数可以表达的十进制数值中，真正有效的数字不高于 8 位。事实上，对相对误差的数值分析结果显示有效的精度大约为 7.22 位（由于位数不可取小数，所以单精度的精度为7，即可精确到小数点后7位）。参考下面的示例： 12345678910111213141516171819202122System.out.println(16777215f);/*1.6777215E7 */System.out.println(16777216f);/*1.6777216E7 */System.out.println(16777217f);/*1.6777216E7 */System.out.println(16777218f);/*1.6777218E7 */System.out.println(16777219f);/*1.677722E7 */System.out.println(16777220f);/*1.677722E7 */System.out.println(16777221f);/*1.677722E7 */System.out.println(16777222f);/*1.6777222E7 */System.out.println(16777223f);/*1.6777224E7 */System.out.println(16777224f);/*1.6777224E7 */System.out.println(16777225f);/*1.6777224E7 */System.out.println(16777215f);/*1.6777215E7*/System.out.println(16777216f);/*1.6777216E7*/System.out.println(16777217f);/*1.6777216E7*/System.out.println(16777218f);/*1.6777218E7*/System.out.println(16777219f);/*1.677722E7*/System.out.println(16777220f);/*1.677722E7*/System.out.println(16777221f);/*1.677722E7*/System.out.println(16777222f);/*1.6777222E7*/System.out.println(16777223f);/*1.6777224E7*/System.out.println(16777224f);/*1.6777224E7*/System.out.println(16777225f);/*1.6777224E7*/ 请看结果推导分析： 111111111111111111111111 16777215f1.11111111111111111111111 刚好是23位，不会丢失精度，能精确表示 0 23+127 11111111111111111111111 0 10010110 11111111111111111111111 1000000000000000000000000 16777216f1.00000000000000000000000 0 去掉的是0，所以还是能准确表示 0 24+127 00000000000000000000000 0 10010111 00000000000000000000000 1000000000000000000000001 16777217f1.00000000000000000000000 1 不能准确表示。先试着进位1.00000000000000000000001 由于进位后，结果的最末们不是0，所以直接舍掉1.00000000000000000000000 到这里结果就是16777216f 1000000000000000000000010 16777218f1.0000000000000000000001 0 去掉的是0，所以还是能准确表示 0 24+127 00000000000000000000001 0 10010111 00000000000000000000001 1000000000000000000000011 16777219f1.0000000000000000000001 1 不能准确表示。先试着进位1.0000000000000000000010 进位后的结果，最末们为0，所以进位成功 0 24+127 00000000000000000000010 0 10010111 000000000000000000000101.000000000000000000000100*2^24 16777219f存储在内存中的结","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[{"name":"基本数据类型","slug":"基本数据类型","permalink":"http://sivan0222.cn/tags/基本数据类型/"}]},{"title":"[Java]-1","slug":"Java-1","date":"2016-12-07T02:54:38.000Z","updated":"2017-05-05T04:18:29.981Z","comments":true,"path":"2016/12/07/Java-1/","link":"","permalink":"http://sivan0222.cn/2016/12/07/Java-1/","excerpt":"程序 编译执行 ：例如我们所说的C/C++ 解释执行 Java应用开发方向: JAVA SE:桌面应用程序开发，是JAVA基础！ JAVA EE:web开发 jsp(Java Server Pages)也是网站开发，但是具有高大上，生命周期长，安全稳定的优点 JAVA ME: 移动端开发(手机)，物联网移动应用程序开发","text":"程序 编译执行 ：例如我们所说的C/C++ 解释执行 Java应用开发方向: JAVA SE:桌面应用程序开发，是JAVA基础！ JAVA EE:web开发 jsp(Java Server Pages)也是网站开发，但是具有高大上，生命周期长，安全稳定的优点 JAVA ME: 移动端开发(手机)，物联网移动应用程序开发 JAVA组成： JVM:（JAVA虚拟机），JAVA的核心组件，JAVA实现跨平台的前提条件 JRE:(JAVA运行时环境)，是java程序运行的充分必备条件.(JRE=JVM+LIB(基本类库))，JRE可从官网下载，面向客户，而不是开发者 JDK:(JAVA，面向程序员，JDK=JRE+LIB(类库,比JRE的LIB更加强大)+编译器JAVA程序(.java)—–(.class)—-&gt;虚拟机(虚拟机面向的对象根据自己电脑系统来决定)——–&gt;OS(操作系统) 虚拟机：程序虚拟出来的机器，如果一个java程序在windows下执行，虚拟机是for windows ,在linux下执行，虚拟机是for linux，也就是说字节码可以跨平台，但是虚拟机不可以跨平台，而且虚拟机不识别源代码 缺点:由于有JVM存在而使得JAVA程序运行效率低 优点：虚拟机的垃圾收集机制；开发效率高；安全性高 部署开发环境:安装JDK配置环境变量(在操作系统中注册Java这个软件)１．新建环境变量(在下面的系统变量新建) JAVA_HOME: (值就是存放jdk的目录)(JAVA_HOME小写也可以，因为在windows系统中是不区分大小写的，大小写只是为了兼容linux系统) ２．找到Path: 按下HOME键使光标移到最左边，添加 %JAVA_HOME%\\bin; (末尾的分号是用来隔开后面的文件) Ｐａｔｈ：配到ＪＤＫ下的ｂｉｎ目录ＣＬＡＳＳＰＡＴＨ：ｌｉｂ目录 ＋ 当前目录（用点号表示）Path目录讲解：可以存放一些我们在dos下可以执行的东西，例如我们把QQ启动程序放到Path中，便可以在dos窗口下输入QQ，就可以启动QQ，同理Path对JAVA也是这样处理的，因为我们需要执行JAVA以及JAVAC命令 ３．新建CLASSPATH(作用是为了找到lib目录，同时也是为了可以运行自己写的类而进行配置): 值是 %JAVA_HOME%\\lib;. (末尾必须是分号点号) 如果我们写ＪＡＶＡ程序出现乱码，只需要把中文改成英文就可以了 JDK目录功能(里面包含include文件夹，说明JAVA是可以调用C语言的): bin：存放二进制文件（可执行文件） lib：类库文件、 jre：JAVA运行时环境 sample：一些简单例子 src.zip：源代码 测试验证JAVA环境搭配好的方法:在DOS窗口下，输入javac 正常输出配置信息，便成功！ 注意事项： 在验证JAVA开发环境的时候，也就是验证Java环境变量是否正确设置在系统上的时候，请注意：JRE的命令是嵌入在系统中的，例如，java.exe会复制到system32文件夹中，因此该命令可以随处运行，从而不能够作为验证环境变量正确配置的标志 WinRAR对JAR文件的关联： WinRAR以及JRE安装之后都需要设置其对JAR文件的关联，不同的是通过关联使用JRE操作JAR文件之后会尝试运行这个文件，而WinRAR则会把它当作压缩包文件。所以要使计算机能够正确运行JAR文件，必须在WinRAR等压缩软件之后安装JRE环境。 编写代码并测试: 编写源程序代码 编译（例如 javac Test.java）（目的一是为了检查是否有错误，而是生成字节码(.class)文件(二进制文件)，可以在虚拟机上直接运行，而源代码是不可以的！） 运行( java Test)","categories":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://sivan0222.cn/categories/Java/基础/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://sivan0222.cn/tags/Java/"},{"name":"JDK","slug":"JDK","permalink":"http://sivan0222.cn/tags/JDK/"}]}]}